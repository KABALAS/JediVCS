(*-----------------------------------------------------------------------------
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in compliance
with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/MPL-1.1.html

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is JVCSNewClientObj.pas.

Componentes and used code which is used in this code are explictly stated to
be copyright of the respective author(s).

This unit has been generated by JVCSGen utility. 
It contains MidWare JEDI VCS client classes.

Generation settings:
[ ] LOGGING
[ ] USER INPUT FORMS
[ ] COM Version
   [ ] COM Version with IFDEF's

Last Modified: see History

Known Issues:
-----------------------------------------------------------------------------

Unit history:

!!! this unit should not be altered manually !!!

2008/11/07  USchuster  - new unit
2008/11/15  USchuster  - added GET_LABELS_BY_MODULE and GET_SUPPORTED_FUNCTIONS
2010/01/23  USchuster  - changes for the latest server version of LIST_FILES

-----------------------------------------------------------------------------*)

unit JVCSNewClientObj;

interface

{$I jedi.inc}

uses
  Classes, SysUtils, RFormat, CBroker, JVCSCrypt, JVCSTypes, JVCSClientObjBase;

type

  // ADD_UPDATE_PROPERTIES

  TJVCSAddUpdateProperties = class(TJVCSClientObject)
  private
    // input
    FTable: Integer;
    FTableID: Integer;
    FTablePropertyID: Integer;
    FPropertyID: Integer;
    FHeader: string;
    FContent: TMemoryStream;
    // output
    FRequestAccepted: Boolean;
    FErrorMessage: string;
    FNewTablePropertyID: Integer;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property Table: Integer read FTable write FTable;
    property TableID: Integer read FTableID write FTableID;
    property TablePropertyID: Integer read FTablePropertyID write FTablePropertyID;
    property PropertyID: Integer read FPropertyID write FPropertyID;
    property Header: string read FHeader write FHeader;
    property Content: TMemoryStream read FContent write FContent;
    // output
    property RequestAccepted: Boolean read FRequestAccepted;
    property ErrorMessage: string read FErrorMessage;
    property NewTablePropertyID: Integer read FNewTablePropertyID;
  end;

  // GET_PROPERTIES

  PGetPropertiesOutputItem = ^TGetPropertiesOutputItem;
  TGetPropertiesOutputItem = record
    TableID: Integer;
    PropertyID: Integer;
    TablePropertyID: Integer;
    Header: string;
    ContentSize: Integer;
    Content: TMemoryStream;
  end;
  TJVCSGetProperties = class(TJVCSClientObject)
  private
    // input
    FTable: Integer;
    FTableID: Integer;
    FTablePropertyID: Integer;
    FPropertyID: Integer;
    FIncludeContent: Boolean;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetPropertiesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property Table: Integer read FTable write FTable;
    property TableID: Integer read FTableID write FTableID;
    property TablePropertyID: Integer read FTablePropertyID write FTablePropertyID;
    property PropertyID: Integer read FPropertyID write FPropertyID;
    property IncludeContent: Boolean read FIncludeContent write FIncludeContent;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetPropertiesOutputItem read GetOutputItems;
  end;

  // GET_MODULE_REVISION_PROPERTIES

  PGetModuleRevisionPropertiesOutputItem = ^TGetModuleRevisionPropertiesOutputItem;
  TGetModuleRevisionPropertiesOutputItem = record
    RevisionID: Integer;
    PropertyID: Integer;
    TablePropertyID: Integer;
    Header: string;
    ContentSize: Integer;
    Content: TMemoryStream;
  end;
  TJVCSGetModuleRevisionProperties = class(TJVCSClientObject)
  private
    // input
    FModuleID: Integer;
    FPropertyID: Integer;
    FIncludeContent: Boolean;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetModuleRevisionPropertiesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    property PropertyID: Integer read FPropertyID write FPropertyID;
    property IncludeContent: Boolean read FIncludeContent write FIncludeContent;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetModuleRevisionPropertiesOutputItem read GetOutputItems;
  end;

  // REMOVE_PROPERTIES

  TJVCSRemoveProperties = class(TJVCSClientObject)
  private
    // input
    FTable: Integer;
    FTablePropertyID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    // input
    property Table: Integer read FTable write FTable;
    property TablePropertyID: Integer read FTablePropertyID write FTablePropertyID;
  end;

  // GET_PROPERTY_LIST

  PGetPropertyListOutputItem = ^TGetPropertyListOutputItem;
  TGetPropertyListOutputItem = record
    PropertyID: Integer;
    PropertyName: JVCSString100;
    PropertyDescription: string;
  end;
  TJVCSGetPropertyList = class(TJVCSClientObject)
  private
    // input
    FIncludeDescription: Boolean;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetPropertyListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property IncludeDescription: Boolean read FIncludeDescription write FIncludeDescription;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetPropertyListOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_PROPERTY

  TJVCSAddUpdateProperty = class(TJVCSClientObject)
  private
    // input
    FPropertyID: Integer;
    FPropertyName: JVCSString100;
    FPropertyDescription: string;
    // output
    FRequestAccepted: Boolean;
    FErrorMessage: string;
    FNewPropertyID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property PropertyID: Integer read FPropertyID write FPropertyID;
    property PropertyName: JVCSString100 read FPropertyName write FPropertyName;
    property PropertyDescription: string read FPropertyDescription write FPropertyDescription;
    // output
    property RequestAccepted: Boolean read FRequestAccepted;
    property ErrorMessage: string read FErrorMessage;
    property NewPropertyID: Integer read FNewPropertyID;
  end;

  // REMOVE_PROPERTY

  TJVCSRemoveProperty = class(TJVCSClientObject)
  private
    // input
    FPropertyID: Integer;
    // output
    FPropertyRemoved: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property PropertyID: Integer read FPropertyID write FPropertyID;
    // output
    property PropertyRemoved: Boolean read FPropertyRemoved;
  end;

  // LIST_FILES

  PListFilesOutputItem = ^TListFilesOutputItem;
  TListFilesOutputItem = record
    Name: JVCSString255;
    Kind: Integer;
    ModuleID: Integer;
    LatestRevisionID: Integer;
    LatestRevisionUser: string;
    LatestRevisionVersion: Integer;
    LatestRevisionRevision: Integer;
    LatestRevisionComment_I: string;
    LatestRevisionExtension: JVCSString20;
    LatestRevisionTS: TDateTime;
    LatestRevisionOrigSize: Integer;
  end;
  TJVCSListFiles = class(TJVCSClientObject)
  private
    // input
    FDir: string;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TListFilesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property Dir: string read FDir write FDir;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TListFilesOutputItem read GetOutputItems;
  end;

  // SEARCH_REVISIONS_BY_COMMENT

  PSearchRevisionsByCommentOutputItem = ^TSearchRevisionsByCommentOutputItem;
  TSearchRevisionsByCommentOutputItem = record
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Comment_I: string;
    Comment_O: string;
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
  end;
  TJVCSSearchRevisionsByComment = class(TJVCSClientObject)
  private
    // input
    FMaskString: JVCSString255;
    FIncludeModuleInfo: Boolean;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TSearchRevisionsByCommentOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property MaskString: JVCSString255 read FMaskString write FMaskString;
    property IncludeModuleInfo: Boolean read FIncludeModuleInfo write FIncludeModuleInfo;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TSearchRevisionsByCommentOutputItem read GetOutputItems;
  end;

  // SEARCH_MODULE_REVISIONS_BY_CRC

  PSearchModuleRevisionsByCrcInputItem = ^TSearchModuleRevisionsByCrcInputItem;
  TSearchModuleRevisionsByCrcInputItem = record
    ModuleID: Integer;
    ModuleExtension: JVCSString20;
    ModuleOrigCRC: Integer;
  end;
  PSearchModuleRevisionsByCrcOutputItem = ^TSearchModuleRevisionsByCrcOutputItem;
  TSearchModuleRevisionsByCrcOutputItem = record
    ModuleID: Integer;
    ModuleExtension: JVCSString20;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
  end;
  TJVCSSearchModuleRevisionsByCrc = class(TJVCSClientObject)
  private
    // input
    FInputItems: TList;
    // output
    FOutputItems: TList;
    procedure ClearInputItems;
    procedure ClearOutputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TSearchModuleRevisionsByCrcInputItem;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TSearchModuleRevisionsByCrcOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(AModuleID: Integer; const AModuleExtension: string; AModuleOrigCRC: Integer): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TSearchModuleRevisionsByCrcInputItem read GetInputItems;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TSearchModuleRevisionsByCrcOutputItem read GetOutputItems;
  end;

  // GET_LABELS_BY_MODULE

  PGetLabelsByModuleOutputItem = ^TGetLabelsByModuleOutputItem;
  TGetLabelsByModuleOutputItem = record
    RevisionID: Integer;
    LabelID: Integer;
    LabelName: JVCSString50;
    Description: string;
  end;
  TJVCSGetLabelsByModule = class(TJVCSClientObject)
  private
    // input
    FModuleID: Integer;
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLabelsByModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLabelsByModuleOutputItem read GetOutputItems;
  end;

  // GET_SUPPORTED_FUNCTIONS

  PGetSupportedFunctionsOutputItem = ^TGetSupportedFunctionsOutputItem;
  TGetSupportedFunctionsOutputItem = record
    FunctionName: JVCSString100;
  end;
  TJVCSGetSupportedFunctions = class(TJVCSClientObject)
  private
    // output
    FOutputItems: TList;
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetSupportedFunctionsOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetSupportedFunctionsOutputItem read GetOutputItems;
  end;

implementation

uses
  JVCSClientFunctions;

const
  BoolStrings: array[Boolean] of string = ('False', 'True');

{ TJVCSAddUpdateProperties protected }

procedure TJVCSAddUpdateProperties.DoExecute;
var
  nAutoExpand: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FTable]);
      WriteFields(False, [FTableID]);
      WriteFields(False, [FTablePropertyID]);
      WriteFields(False, [FPropertyID]);
      WriteFields(False, [FHeader]);
      nAutoExpand := AutoExpand;
      AutoExpand := FContent.Size + (FContent.Size div 4) + 256;
      try
        FContent.Seek(0, soFromBeginning);
        WriteStreamField(False, mwBlob, FContent);
      finally
        AutoExpand := nAutoExpand;
      end;
    end;
end;

{ TJVCSAddUpdateProperties public }

constructor TJVCSAddUpdateProperties.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FContent := TMemoryStream.Create;
end;

destructor TJVCSAddUpdateProperties.Destroy;
begin
  FContent.Free;
  inherited Destroy;
end;

procedure TJVCSAddUpdateProperties.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateProperties) then
    begin
      FTable := TJVCSAddUpdateProperties(Reference).FTable;
      FTableID := TJVCSAddUpdateProperties(Reference).FTableID;
      FTablePropertyID := TJVCSAddUpdateProperties(Reference).FTablePropertyID;
      FPropertyID := TJVCSAddUpdateProperties(Reference).FPropertyID;
      FHeader := TJVCSAddUpdateProperties(Reference).FHeader;
      FContent.Clear;
      FContent.CopyFrom(TJVCSAddUpdateProperties(Reference).FContent, 0);
      FContent.Seek(0, soFromBeginning);
      FRequestAccepted := TJVCSAddUpdateProperties(Reference).FRequestAccepted;
      FErrorMessage := TJVCSAddUpdateProperties(Reference).FErrorMessage;
      FNewTablePropertyID := TJVCSAddUpdateProperties(Reference).FNewTablePropertyID;
    end;
end;

procedure TJVCSAddUpdateProperties.Initialize; 
begin
  inherited Initialize;
  FRequestAccepted := False;
  FErrorMessage := '';
  FNewTablePropertyID := -1;
end;

procedure TJVCSAddUpdateProperties.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FRequestAccepted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FNewTablePropertyID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
    end;
  end;
end;


{ TJVCSGetProperties private }

procedure TJVCSGetProperties.ClearOutputItems;
var
  I: Integer;
  Item: TGetPropertiesOutputItem;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Item := PGetPropertiesOutputItem(FOutputItems[I])^;
    Item.Content.Free;
    Item.Content := nil;
    Finalize(PGetPropertiesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetProperties.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProperties.GetOutputItems(Index: Integer): TGetPropertiesOutputItem;
begin
  Result := PGetPropertiesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProperties protected }

procedure TJVCSGetProperties.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FTable]);
      WriteFields(False, [FTableID]);
      WriteFields(False, [FTablePropertyID]);
      WriteFields(False, [FPropertyID]);
      WriteFields(False, [FIncludeContent]);
    end;
end;

{ TJVCSGetProperties public }

constructor TJVCSGetProperties.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSGetProperties.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProperties.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProperties) then
    begin
      FTable := TJVCSGetProperties(Reference).FTable;
      FTableID := TJVCSGetProperties(Reference).FTableID;
      FTablePropertyID := TJVCSGetProperties(Reference).FTablePropertyID;
      FPropertyID := TJVCSGetProperties(Reference).FPropertyID;
      FIncludeContent := TJVCSGetProperties(Reference).FIncludeContent;
      ClearOutputItems;
      for I := 0 to TJVCSGetProperties(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetPropertiesOutputItem));
        try
          with PGetPropertiesOutputItem(P)^ do
          begin
            TableID := TJVCSGetProperties(Reference).OutputItems[I].TableID;
            PropertyID := TJVCSGetProperties(Reference).OutputItems[I].PropertyID;
            TablePropertyID := TJVCSGetProperties(Reference).OutputItems[I].TablePropertyID;
            Header := TJVCSGetProperties(Reference).OutputItems[I].Header;
            ContentSize := TJVCSGetProperties(Reference).OutputItems[I].ContentSize;
            Content := TMemoryStream.Create;
            try
              if Assigned(TJVCSGetProperties(Reference).OutputItems[I].Content) then
                Content.CopyFrom(TJVCSGetProperties(Reference).OutputItems[I].Content, 0);
              Content.Seek(0, soFromBeginning);
            except
              Content.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProperties.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProperties.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  FieldType: TMWFieldType;
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetPropertiesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetPropertiesOutputItem(P)^.TableID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetPropertiesOutputItem(P)^.PropertyID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetPropertiesOutputItem(P)^.TablePropertyID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetPropertiesOutputItem(P)^.Header := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetPropertiesOutputItem(P)^.ContentSize := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwBlob) then
          begin
            PGetPropertiesOutputItem(P)^.Content := TMemoryStream.Create;
            try
              PGetPropertiesOutputItem(P)^.Content.Clear;
              ResponseBuffer.GetStreamField(5, PGetPropertiesOutputItem(P)^.Content, FieldType);
              PGetPropertiesOutputItem(P)^.Content.Seek(0, soFromBeginning);
            except
              PGetPropertiesOutputItem(P)^.Content.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSGetModuleRevisionProperties private }

procedure TJVCSGetModuleRevisionProperties.ClearOutputItems;
var
  I: Integer;
  Item: TGetModuleRevisionPropertiesOutputItem;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Item := PGetModuleRevisionPropertiesOutputItem(FOutputItems[I])^;
    Item.Content.Free;
    Item.Content := nil;
    Finalize(PGetModuleRevisionPropertiesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetModuleRevisionProperties.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetModuleRevisionProperties.GetOutputItems(Index: Integer): TGetModuleRevisionPropertiesOutputItem;
begin
  Result := PGetModuleRevisionPropertiesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetModuleRevisionProperties protected }

procedure TJVCSGetModuleRevisionProperties.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
      WriteFields(False, [FPropertyID]);
      WriteFields(False, [FIncludeContent]);
    end;
end;

{ TJVCSGetModuleRevisionProperties public }

constructor TJVCSGetModuleRevisionProperties.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSGetModuleRevisionProperties.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetModuleRevisionProperties.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetModuleRevisionProperties) then
    begin
      FModuleID := TJVCSGetModuleRevisionProperties(Reference).FModuleID;
      FPropertyID := TJVCSGetModuleRevisionProperties(Reference).FPropertyID;
      FIncludeContent := TJVCSGetModuleRevisionProperties(Reference).FIncludeContent;
      ClearOutputItems;
      for I := 0 to TJVCSGetModuleRevisionProperties(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetModuleRevisionPropertiesOutputItem));
        try
          with PGetModuleRevisionPropertiesOutputItem(P)^ do
          begin
            RevisionID := TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].RevisionID;
            PropertyID := TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].PropertyID;
            TablePropertyID := TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].TablePropertyID;
            Header := TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].Header;
            ContentSize := TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].ContentSize;
            Content := TMemoryStream.Create;
            try
              if Assigned(TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].Content) then
                Content.CopyFrom(TJVCSGetModuleRevisionProperties(Reference).OutputItems[I].Content, 0);
              Content.Seek(0, soFromBeginning);
            except
              Content.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetModuleRevisionProperties.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetModuleRevisionProperties.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  FieldType: TMWFieldType;
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetModuleRevisionPropertiesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetModuleRevisionPropertiesOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetModuleRevisionPropertiesOutputItem(P)^.PropertyID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetModuleRevisionPropertiesOutputItem(P)^.TablePropertyID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetModuleRevisionPropertiesOutputItem(P)^.Header := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetModuleRevisionPropertiesOutputItem(P)^.ContentSize := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwBlob) then
          begin
            PGetModuleRevisionPropertiesOutputItem(P)^.Content := TMemoryStream.Create;
            try
              PGetModuleRevisionPropertiesOutputItem(P)^.Content.Clear;
              ResponseBuffer.GetStreamField(5, PGetModuleRevisionPropertiesOutputItem(P)^.Content, FieldType);
              PGetModuleRevisionPropertiesOutputItem(P)^.Content.Seek(0, soFromBeginning);
            except
              PGetModuleRevisionPropertiesOutputItem(P)^.Content.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSRemoveProperties protected }

procedure TJVCSRemoveProperties.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FTable]);
      WriteFields(False, [FTablePropertyID]);
    end;
end;

{ TJVCSRemoveProperties public }

procedure TJVCSRemoveProperties.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProperties) then
    begin
      FTable := TJVCSRemoveProperties(Reference).FTable;
      FTablePropertyID := TJVCSRemoveProperties(Reference).FTablePropertyID;
    end;
end;


{ TJVCSGetPropertyList private }

procedure TJVCSGetPropertyList.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetPropertyListOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetPropertyList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetPropertyList.GetOutputItems(Index: Integer): TGetPropertyListOutputItem;
begin
  Result := PGetPropertyListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetPropertyList protected }

procedure TJVCSGetPropertyList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FIncludeDescription]);
    end;
end;

{ TJVCSGetPropertyList public }

constructor TJVCSGetPropertyList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSGetPropertyList.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetPropertyList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetPropertyList) then
    begin
      FIncludeDescription := TJVCSGetPropertyList(Reference).FIncludeDescription;
      ClearOutputItems;
      for I := 0 to TJVCSGetPropertyList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetPropertyListOutputItem));
        try
          with PGetPropertyListOutputItem(P)^ do
          begin
            PropertyID := TJVCSGetPropertyList(Reference).OutputItems[I].PropertyID;
            PropertyName := TJVCSGetPropertyList(Reference).OutputItems[I].PropertyName;
            PropertyDescription := TJVCSGetPropertyList(Reference).OutputItems[I].PropertyDescription;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetPropertyList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetPropertyList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetPropertyListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetPropertyListOutputItem(P)^.PropertyID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetPropertyListOutputItem(P)^.PropertyName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetPropertyListOutputItem(P)^.PropertyDescription := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSAddUpdateProperty protected }

procedure TJVCSAddUpdateProperty.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FPropertyID]);
      WriteFields(False, [FPropertyName]);
      WriteFields(False, [FPropertyDescription]);
    end;
end;

{ TJVCSAddUpdateProperty public }

procedure TJVCSAddUpdateProperty.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateProperty) then
    begin
      FPropertyID := TJVCSAddUpdateProperty(Reference).FPropertyID;
      FPropertyName := TJVCSAddUpdateProperty(Reference).FPropertyName;
      FPropertyDescription := TJVCSAddUpdateProperty(Reference).FPropertyDescription;
      FRequestAccepted := TJVCSAddUpdateProperty(Reference).FRequestAccepted;
      FErrorMessage := TJVCSAddUpdateProperty(Reference).FErrorMessage;
      FNewPropertyID := TJVCSAddUpdateProperty(Reference).FNewPropertyID;
    end;
end;

procedure TJVCSAddUpdateProperty.Initialize; 
begin
  inherited Initialize;
  FRequestAccepted := False;
  FErrorMessage := '';
  FNewPropertyID := -1;
end;

procedure TJVCSAddUpdateProperty.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FRequestAccepted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FNewPropertyID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
    end;
  end;
end;


{ TJVCSRemoveProperty protected }

procedure TJVCSRemoveProperty.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FPropertyID]);
    end;
end;

{ TJVCSRemoveProperty public }

procedure TJVCSRemoveProperty.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProperty) then
    begin
      FPropertyID := TJVCSRemoveProperty(Reference).FPropertyID;
      FPropertyRemoved := TJVCSRemoveProperty(Reference).FPropertyRemoved;
    end;
end;

procedure TJVCSRemoveProperty.Initialize; 
begin
  inherited Initialize;
  FPropertyRemoved := False;
end;

procedure TJVCSRemoveProperty.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FPropertyRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;


{ TJVCSListFiles private }

procedure TJVCSListFiles.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PListFilesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSListFiles.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSListFiles.GetOutputItems(Index: Integer): TListFilesOutputItem;
begin
  Result := PListFilesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSListFiles protected }

procedure TJVCSListFiles.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FDir]);
    end;
end;

{ TJVCSListFiles public }

constructor TJVCSListFiles.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSListFiles.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSListFiles.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSListFiles) then
    begin
      FDir := TJVCSListFiles(Reference).FDir;
      ClearOutputItems;
      for I := 0 to TJVCSListFiles(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TListFilesOutputItem));
        try
          with PListFilesOutputItem(P)^ do
          begin
            Name := TJVCSListFiles(Reference).OutputItems[I].Name;
            Kind := TJVCSListFiles(Reference).OutputItems[I].Kind;
            ModuleID := TJVCSListFiles(Reference).OutputItems[I].ModuleID;
            LatestRevisionID := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionID;
            LatestRevisionUser := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionUser;
            LatestRevisionVersion := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionVersion;
            LatestRevisionRevision := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionRevision;
            LatestRevisionComment_I := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionComment_I;
            LatestRevisionExtension := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionExtension;
            LatestRevisionTS := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionTS;
            LatestRevisionOrigSize := TJVCSListFiles(Reference).OutputItems[I].LatestRevisionOrigSize;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSListFiles.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSListFiles.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TListFilesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PListFilesOutputItem(P)^.Name := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PListFilesOutputItem(P)^.Kind := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PListFilesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionUser := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionVersion := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionRevision := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionComment_I := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionExtension := ResponseBuffer.Fields[8];
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionTS := SafeStrToFloat(ResponseBuffer.Fields[9]);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PListFilesOutputItem(P)^.LatestRevisionOrigSize := StrToInt64Def(ResponseBuffer.Fields[10], -1);
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSSearchRevisionsByComment private }

procedure TJVCSSearchRevisionsByComment.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PSearchRevisionsByCommentOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSSearchRevisionsByComment.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSSearchRevisionsByComment.GetOutputItems(Index: Integer): TSearchRevisionsByCommentOutputItem;
begin
  Result := PSearchRevisionsByCommentOutputItem(FOutputItems[Index])^;
end;

{ TJVCSSearchRevisionsByComment protected }

procedure TJVCSSearchRevisionsByComment.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FMaskString]);
      WriteFields(False, [FIncludeModuleInfo]);
    end;
end;

{ TJVCSSearchRevisionsByComment public }

constructor TJVCSSearchRevisionsByComment.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSSearchRevisionsByComment.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSSearchRevisionsByComment.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSSearchRevisionsByComment) then
    begin
      FMaskString := TJVCSSearchRevisionsByComment(Reference).FMaskString;
      FIncludeModuleInfo := TJVCSSearchRevisionsByComment(Reference).FIncludeModuleInfo;
      ClearOutputItems;
      for I := 0 to TJVCSSearchRevisionsByComment(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TSearchRevisionsByCommentOutputItem));
        try
          with PSearchRevisionsByCommentOutputItem(P)^ do
          begin
            RevisionID := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].RevisionID;
            Version := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].Version;
            Revision := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].Revision;
            Comment_I := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].Comment_I;
            Comment_O := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].Comment_O;
            ModuleID := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSSearchRevisionsByComment(Reference).OutputItems[I].ModulePath;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSSearchRevisionsByComment.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSSearchRevisionsByComment.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TSearchRevisionsByCommentOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.Comment_I := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.Comment_O := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.ModuleName := ResponseBuffer.Fields[6];
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PSearchRevisionsByCommentOutputItem(P)^.ModulePath := ResponseBuffer.Fields[7];
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSSearchModuleRevisionsByCrc private }

procedure TJVCSSearchModuleRevisionsByCrc.ClearInputItems;
var
  I: Integer;
begin
  for I := 0 to FInputItems.Count - 1 do
    FreeMem(FInputItems[I]);
  FInputItems.Clear;
end;

procedure TJVCSSearchModuleRevisionsByCrc.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSSearchModuleRevisionsByCrc.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSSearchModuleRevisionsByCrc.GetInputItems(Index: Integer): TSearchModuleRevisionsByCrcInputItem;
begin
  Result := PSearchModuleRevisionsByCrcInputItem(FInputItems[Index])^;
end;

function TJVCSSearchModuleRevisionsByCrc.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSSearchModuleRevisionsByCrc.GetOutputItems(Index: Integer): TSearchModuleRevisionsByCrcOutputItem;
begin
  Result := PSearchModuleRevisionsByCrcOutputItem(FOutputItems[Index])^;
end;

{ TJVCSSearchModuleRevisionsByCrc protected }

procedure TJVCSSearchModuleRevisionsByCrc.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [ModuleID]);
          WriteFields(False, [ModuleExtension]);
          WriteFields(False, [ModuleOrigCRC]);
        end;
    end;
end;

{ TJVCSSearchModuleRevisionsByCrc public }

constructor TJVCSSearchModuleRevisionsByCrc.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  FOutputItems := TList.Create;
end;

destructor TJVCSSearchModuleRevisionsByCrc.Destroy;
begin
  ClearInputItems;
  FInputItems.Free;
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

function TJVCSSearchModuleRevisionsByCrc.AddInputItem(AModuleID: Integer; const AModuleExtension: string; AModuleOrigCRC: Integer): Integer;
var
  P: PSearchModuleRevisionsByCrcInputItem;
begin
  P := AllocMem(SizeOf(TSearchModuleRevisionsByCrcInputItem));
  try
    P^.ModuleID := AModuleID;
    P^.ModuleExtension := AModuleExtension;
    P^.ModuleOrigCRC := AModuleOrigCRC;
    Result := FInputItems.Add(P);
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSSearchModuleRevisionsByCrc.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSSearchModuleRevisionsByCrc) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSSearchModuleRevisionsByCrc(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TSearchModuleRevisionsByCrcInputItem));
        try
          with PSearchModuleRevisionsByCrcInputItem(P)^ do
          begin
            ModuleID := TJVCSSearchModuleRevisionsByCrc(Reference).InputItems[I].ModuleID;
            ModuleExtension := TJVCSSearchModuleRevisionsByCrc(Reference).InputItems[I].ModuleExtension;
            ModuleOrigCRC := TJVCSSearchModuleRevisionsByCrc(Reference).InputItems[I].ModuleOrigCRC;
          end;
          FInputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
      ClearOutputItems;
      for I := 0 to TJVCSSearchModuleRevisionsByCrc(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TSearchModuleRevisionsByCrcOutputItem));
        try
          with PSearchModuleRevisionsByCrcOutputItem(P)^ do
          begin
            ModuleID := TJVCSSearchModuleRevisionsByCrc(Reference).OutputItems[I].ModuleID;
            ModuleExtension := TJVCSSearchModuleRevisionsByCrc(Reference).OutputItems[I].ModuleExtension;
            RevisionID := TJVCSSearchModuleRevisionsByCrc(Reference).OutputItems[I].RevisionID;
            Version := TJVCSSearchModuleRevisionsByCrc(Reference).OutputItems[I].Version;
            Revision := TJVCSSearchModuleRevisionsByCrc(Reference).OutputItems[I].Revision;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSSearchModuleRevisionsByCrc.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSSearchModuleRevisionsByCrc.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TSearchModuleRevisionsByCrcOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PSearchModuleRevisionsByCrcOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PSearchModuleRevisionsByCrcOutputItem(P)^.ModuleExtension := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PSearchModuleRevisionsByCrcOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PSearchModuleRevisionsByCrcOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PSearchModuleRevisionsByCrcOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSGetLabelsByModule private }

procedure TJVCSGetLabelsByModule.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetLabelsByModuleOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetLabelsByModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLabelsByModule.GetOutputItems(Index: Integer): TGetLabelsByModuleOutputItem;
begin
  Result := PGetLabelsByModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLabelsByModule protected }

procedure TJVCSGetLabelsByModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetLabelsByModule public }

constructor TJVCSGetLabelsByModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSGetLabelsByModule.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLabelsByModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLabelsByModule) then
    begin
      FModuleID := TJVCSGetLabelsByModule(Reference).FModuleID;
      ClearOutputItems;
      for I := 0 to TJVCSGetLabelsByModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLabelsByModuleOutputItem));
        try
          with PGetLabelsByModuleOutputItem(P)^ do
          begin
            RevisionID := TJVCSGetLabelsByModule(Reference).OutputItems[I].RevisionID;
            LabelID := TJVCSGetLabelsByModule(Reference).OutputItems[I].LabelID;
            LabelName := TJVCSGetLabelsByModule(Reference).OutputItems[I].LabelName;
            Description := TJVCSGetLabelsByModule(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLabelsByModule.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLabelsByModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLabelsByModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLabelsByModuleOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLabelsByModuleOutputItem(P)^.LabelID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLabelsByModuleOutputItem(P)^.LabelName := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetLabelsByModuleOutputItem(P)^.Description := ResponseBuffer.Fields[3];
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


{ TJVCSGetSupportedFunctions private }

procedure TJVCSGetSupportedFunctions.ClearOutputItems;
var
  I: Integer;
begin
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetSupportedFunctions.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetSupportedFunctions.GetOutputItems(Index: Integer): TGetSupportedFunctionsOutputItem;
begin
  Result := PGetSupportedFunctionsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetSupportedFunctions public }

constructor TJVCSGetSupportedFunctions.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
end;

destructor TJVCSGetSupportedFunctions.Destroy;
begin
  ClearOutputItems;
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetSupportedFunctions.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSupportedFunctions) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetSupportedFunctions(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetSupportedFunctionsOutputItem));
        try
          with PGetSupportedFunctionsOutputItem(P)^ do
          begin
            FunctionName := TJVCSGetSupportedFunctions(Reference).OutputItems[I].FunctionName;
          end;
          FOutputItems.Add(P);
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetSupportedFunctions.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetSupportedFunctions.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetSupportedFunctionsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetSupportedFunctionsOutputItem(P)^.FunctionName := ResponseBuffer.Fields[0];
          FOutputItems.Add(P);
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;


end.
