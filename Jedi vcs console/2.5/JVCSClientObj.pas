(*-----------------------------------------------------------------------------
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in compliance
with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/MPL-1.1.html

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is JVCSClientObj.pas.

Componentes and used code which is used in this code are explictly stated to
be copyright of the respective author(s).

This unit has been generated by JVCSGen utility. 
It contains MidWare JEDI VCS client classes.

Generation settings:
[ ] LOGGING
[ ] USER INPUT FORMS
[X] COM Version
   [X] COM Version with IFDEF's

Last Modified: see History

Known Issues:
-----------------------------------------------------------------------------

Unit history:

!!! this unit should not be altered manually !!!

2003/03/06  USchuster  - fast migration from JEDI FreeVCS to test some stuff
2003/03/07  USchuster  - added object TFVCSGetArchiveTstamp
2003/03/11  USchuster  - added more objects
2003/03/15  USchuster  - is now completely generated with JVCSGen
                       - changed ...FVCS... into ...JVCS...
                       - added JVCSCliEnCrypt2 and TJVCSClientObject.BlobAsText
                       - moved some stuff from TJVCSClientObject.Execute to
                         .DoExecute (because TransactionNr and ServerUserID are 
                         not necessary for Login)
2003/10/23  USchuster  - excluded stuff from JEDI FreeVCS and JEDI VCS units
                         because now the migrated units from JEDI FreeVCS are used 
                       - included THuber's fix from 2003/02/17 in the the generator
                         (bugfix in VCSLogin.DoExecute - if Server / Client are in 
                          different Timezones with > 2hours difference)
2003/12/01  USchuster  - fixed memory leak
2004/01/18  USchuster  - fixed GET_USERLIST (had a wrong name - GET_USER_LIST)
2005/04/10  USchuster  - added implementation of the client object COM interfaces
                         (optional - see Generation settings above)
2005/04/11  CSchuette  - mantis #2815
2005/09/24  THuber     - #3212 added midware autoexpand adjusting for blob field
2008/06/08  USchuster  - fixed memory leaks (Mantis #3082)

-----------------------------------------------------------------------------*)

unit JVCSClientObj;

interface

{$I jedi.inc}

uses
  Classes, SysUtils, RFormat, CBroker, JVCSCrypt, JVCSTypes, JVCSClientObjBase
  {$IFDEF COMVERSION}
  , Contnrs, jvcsclient_TLB, JVCSCOMStream
  {$ENDIF COMVERSION}
  ;

type
  {$IFDEF COMVERSION}
  INativeClientObject = interface(IUnknown)
    ['{EC9C62A9-83B3-496E-83B2-30090B6EFF00}']
    function GetClientObject: TJVCSClientObject;
  end;

  TJVCSCOMClientObject = class(TJVCSClientObject, IJVCSClientObject, INativeClientObject)
  public
    function GetClientObject: TJVCSClientObject;
  end;
  {$ELSE}
  TJVCSCOMClientObject = TJVCSClientObject;
  {$ENDIF COMVERSION}

  // LOGIN

  TJVCSLogin = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSLogin {$ENDIF})
  private
    // input
    FUserName: JVCSString50;
    FUserPassword: JVCSString200;
    FClientVersion: Integer;
    FServerTimestamp: TDateTime;
    // output
    FAccepted: Boolean;
    FUserID: Integer;
    FTransactionID: Integer;
    FLoginMessage: JVCSString50;
    FServerVersion: Integer;
    FServerType: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserName: WideString; safecall;
    procedure Set_UserName(const Value: WideString); safecall;
    function Get_UserPassword: WideString; safecall;
    procedure Set_UserPassword(const Value: WideString); safecall;
    function Get_ClientVersion: Integer; safecall;
    procedure Set_ClientVersion(Value: Integer); safecall;
    function Get_ServerTimestamp: TDateTime; safecall;
    procedure Set_ServerTimestamp(Value: TDateTime); safecall;
    function Get_Accepted: WordBool; safecall;
    function Get_UserID: Integer; safecall;
    function Get_TransactionID: Integer; safecall;
    function Get_LoginMessage: WideString; safecall;
    function Get_ServerVersion: Integer; safecall;
    function Get_ServerType: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserName: JVCSString50 read FUserName write FUserName;
    property UserPassword: JVCSString200 read FUserPassword write FUserPassword;
    property ClientVersion: Integer read FClientVersion write FClientVersion;
    property ServerTimestamp: TDateTime read FServerTimestamp write FServerTimestamp;
    // output
    property Accepted: Boolean read FAccepted;
    property UserID: Integer read FUserID;
    property TransactionID: Integer read FTransactionID;
    property LoginMessage: JVCSString50 read FLoginMessage;
    property ServerVersion: Integer read FServerVersion;
    property ServerType: string read FServerType;
  end;

  // LOGOUT

  TJVCSLogout = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSLogout {$ENDIF})
  private
    // input
    FUserID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
  end;

  // WHOAMI

  TJVCSWhoami = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSWhoami {$ENDIF})
  private
    // output
    FUserID: Integer;
    FUserName: JVCSString50;
    FAccessLevel: Integer;
    FAccessLabel: string;
    FLoginExpires: Boolean;
    FLoginTime: TDateTime;
    FLoginTimeout: TDateTime;
    FStoredUserIP: JVCSString50;
    FCurrentUserIP: string;
    FServerLabel: JVCSString255;
    FDBType: string;
    FProjectAccessLevel: Integer;
    FProjectAccessLabel: string;
    FServerGMTDiff: string;
  protected
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    function Get_UserName: WideString; safecall;
    function Get_AccessLevel: Integer; safecall;
    function Get_AccessLabel: WideString; safecall;
    function Get_LoginExpires: WordBool; safecall;
    function Get_LoginTime: TDateTime; safecall;
    function Get_LoginTimeout: TDateTime; safecall;
    function Get_StoredUserIP: WideString; safecall;
    function Get_CurrentUserIP: WideString; safecall;
    function Get_ServerLabel: WideString; safecall;
    function Get_DBType: WideString; safecall;
    function Get_ProjectAccessLevel: Integer; safecall;
    function Get_ProjectAccessLabel: WideString; safecall;
    function Get_ServerGMTDiff: WideString; safecall;
    {$ENDIF COMVERSION}
    // output
    property UserID: Integer read FUserID;
    property UserName: JVCSString50 read FUserName;
    property AccessLevel: Integer read FAccessLevel;
    property AccessLabel: string read FAccessLabel;
    property LoginExpires: Boolean read FLoginExpires;
    property LoginTime: TDateTime read FLoginTime;
    property LoginTimeout: TDateTime read FLoginTimeout;
    property StoredUserIP: JVCSString50 read FStoredUserIP;
    property CurrentUserIP: string read FCurrentUserIP;
    property ServerLabel: JVCSString255 read FServerLabel;
    property DBType: string read FDBType;
    property ProjectAccessLevel: Integer read FProjectAccessLevel;
    property ProjectAccessLabel: string read FProjectAccessLabel;
    property ServerGMTDiff: string read FServerGMTDiff;
  end;

  // GET_SERVER_OPTIONS

  TJVCSGetServerOptions = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetServerOptions {$ENDIF})
  private
    // output
    FConnectionTimeout: Integer;
    FLoginTimeout: TDateTime;
    FCasualCheckin: Boolean;
    FWriteVCSLog: Boolean;
    FCheckClientIP: Boolean;
    FLoginExpires: Boolean;
    FWriteServerLog: Boolean;
    FServerLogSize: Integer;
    FLiveBackupPath: string;
    FLastLiveBackup: TDateTime;
    FLocalLoginNoPassword: Boolean;
    FORBObjectCount: Integer;
    FAutoLoginAvailable: Boolean;
    FAutoLogin: Boolean;
    FLogAccessFaults: Boolean;
    FUptime: JVCSString255;
    FRequestCount: Integer;
    FArchiveDrive: JVCSString255;
    FArchiveDriveAvailable: JVCSString255;
    FArchiveDriveTotal: JVCSString255;
    FCheckinCount: Integer;
    FCheckoutCount: Integer;
    FNewFileCount: Integer;
    FUserCount: Integer;
    FBytesTransmitted: JVCSString255;
    FBytesReceived: JVCSString255;
    FGetFilesCount: Integer;
  protected
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ConnectionTimeout: Integer; safecall;
    function Get_LoginTimeout: TDateTime; safecall;
    function Get_CasualCheckin: WordBool; safecall;
    function Get_WriteVCSLog: WordBool; safecall;
    function Get_CheckClientIP: WordBool; safecall;
    function Get_LoginExpires: WordBool; safecall;
    function Get_WriteServerLog: WordBool; safecall;
    function Get_ServerLogSize: Integer; safecall;
    function Get_LiveBackupPath: WideString; safecall;
    function Get_LastLiveBackup: TDateTime; safecall;
    function Get_LocalLoginNoPassword: WordBool; safecall;
    function Get_ORBObjectCount: Integer; safecall;
    function Get_AutoLoginAvailable: WordBool; safecall;
    function Get_AutoLogin: WordBool; safecall;
    function Get_LogAccessFaults: WordBool; safecall;
    function Get_Uptime: WideString; safecall;
    function Get_RequestCount: Integer; safecall;
    function Get_ArchiveDrive: WideString; safecall;
    function Get_ArchiveDriveAvailable: WideString; safecall;
    function Get_ArchiveDriveTotal: WideString; safecall;
    function Get_CheckinCount: Integer; safecall;
    function Get_CheckoutCount: Integer; safecall;
    function Get_NewFileCount: Integer; safecall;
    function Get_UserCount: Integer; safecall;
    function Get_BytesTransmitted: WideString; safecall;
    function Get_BytesReceived: WideString; safecall;
    function Get_GetFilesCount: Integer; safecall;
    {$ENDIF COMVERSION}
    // output
    property ConnectionTimeout: Integer read FConnectionTimeout;
    property LoginTimeout: TDateTime read FLoginTimeout;
    property CasualCheckin: Boolean read FCasualCheckin;
    property WriteVCSLog: Boolean read FWriteVCSLog;
    property CheckClientIP: Boolean read FCheckClientIP;
    property LoginExpires: Boolean read FLoginExpires;
    property WriteServerLog: Boolean read FWriteServerLog;
    property ServerLogSize: Integer read FServerLogSize;
    property LiveBackupPath: string read FLiveBackupPath;
    property LastLiveBackup: TDateTime read FLastLiveBackup;
    property LocalLoginNoPassword: Boolean read FLocalLoginNoPassword;
    property ORBObjectCount: Integer read FORBObjectCount;
    property AutoLoginAvailable: Boolean read FAutoLoginAvailable;
    property AutoLogin: Boolean read FAutoLogin;
    property LogAccessFaults: Boolean read FLogAccessFaults;
    property Uptime: JVCSString255 read FUptime;
    property RequestCount: Integer read FRequestCount;
    property ArchiveDrive: JVCSString255 read FArchiveDrive;
    property ArchiveDriveAvailable: JVCSString255 read FArchiveDriveAvailable;
    property ArchiveDriveTotal: JVCSString255 read FArchiveDriveTotal;
    property CheckinCount: Integer read FCheckinCount;
    property CheckoutCount: Integer read FCheckoutCount;
    property NewFileCount: Integer read FNewFileCount;
    property UserCount: Integer read FUserCount;
    property BytesTransmitted: JVCSString255 read FBytesTransmitted;
    property BytesReceived: JVCSString255 read FBytesReceived;
    property GetFilesCount: Integer read FGetFilesCount;
  end;

  // SET_SERVER_OPTIONS

  TJVCSSetServerOptions = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSSetServerOptions {$ENDIF})
  private
    // input
    FConnectionTimeout: Integer;
    FLoginTimeout: TDateTime;
    FCasualCheckin: Boolean;
    FWriteVCSLog: Boolean;
    FCheckClientIP: Boolean;
    FLoginExpires: Boolean;
    FWriteServerLog: Boolean;
    FLiveBackupPath: string;
    FLocalLoginNoPassword: Boolean;
    FAutoLogin: Boolean;
    FLogAccessFaults: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ConnectionTimeout: Integer; safecall;
    procedure Set_ConnectionTimeout(Value: Integer); safecall;
    function Get_LoginTimeout: TDateTime; safecall;
    procedure Set_LoginTimeout(Value: TDateTime); safecall;
    function Get_CasualCheckin: WordBool; safecall;
    procedure Set_CasualCheckin(Value: WordBool); safecall;
    function Get_WriteVCSLog: WordBool; safecall;
    procedure Set_WriteVCSLog(Value: WordBool); safecall;
    function Get_CheckClientIP: WordBool; safecall;
    procedure Set_CheckClientIP(Value: WordBool); safecall;
    function Get_LoginExpires: WordBool; safecall;
    procedure Set_LoginExpires(Value: WordBool); safecall;
    function Get_WriteServerLog: WordBool; safecall;
    procedure Set_WriteServerLog(Value: WordBool); safecall;
    function Get_LiveBackupPath: WideString; safecall;
    procedure Set_LiveBackupPath(const Value: WideString); safecall;
    function Get_LocalLoginNoPassword: WordBool; safecall;
    procedure Set_LocalLoginNoPassword(Value: WordBool); safecall;
    function Get_AutoLogin: WordBool; safecall;
    procedure Set_AutoLogin(Value: WordBool); safecall;
    function Get_LogAccessFaults: WordBool; safecall;
    procedure Set_LogAccessFaults(Value: WordBool); safecall;
    {$ENDIF COMVERSION}
    // input
    property ConnectionTimeout: Integer read FConnectionTimeout write FConnectionTimeout;
    property LoginTimeout: TDateTime read FLoginTimeout write FLoginTimeout;
    property CasualCheckin: Boolean read FCasualCheckin write FCasualCheckin;
    property WriteVCSLog: Boolean read FWriteVCSLog write FWriteVCSLog;
    property CheckClientIP: Boolean read FCheckClientIP write FCheckClientIP;
    property LoginExpires: Boolean read FLoginExpires write FLoginExpires;
    property WriteServerLog: Boolean read FWriteServerLog write FWriteServerLog;
    property LiveBackupPath: string read FLiveBackupPath write FLiveBackupPath;
    property LocalLoginNoPassword: Boolean read FLocalLoginNoPassword write FLocalLoginNoPassword;
    property AutoLogin: Boolean read FAutoLogin write FAutoLogin;
    property LogAccessFaults: Boolean read FLogAccessFaults write FLogAccessFaults;
  end;

  // GET_PROJECT_RIGHTS

  PGetProjectRightsOutputItem = ^TGetProjectRightsOutputItem;
  TGetProjectRightsOutputItem = record
    UserID: Integer;
    ProjectID: Integer;
    AccessLevel: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectRights = class;

  TJVCSGetProjectRightsOutputItem = class(TComponent, IJVCSGetProjectRightsOutputItem)
  private
    FPtr: PGetProjectRightsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectRightsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_UserID: Integer; safecall;
    function Get_ProjectID: Integer; safecall;
    function Get_AccessLevel: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectRights = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectRights {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectRightsOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectRightsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectRightsOutputItem read GetOutputItems;
  end;

  // SET_PROJECT_RIGHTS

  TJVCSSetProjectRights = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSSetProjectRights {$ENDIF})
  private
    // input
    FUserID: Integer;
    FProjectID: Integer;
    FAccessLevel: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_AccessLevel: Integer; safecall;
    procedure Set_AccessLevel(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property ProjectID: Integer read FProjectID write FProjectID;
    property AccessLevel: Integer read FAccessLevel write FAccessLevel;
  end;

  // GET_USERLIST

  PGetUserlistOutputItem = ^TGetUserlistOutputItem;
  TGetUserlistOutputItem = record
    UserID: Integer;
    UserName: JVCSString50;
    UserAccessLevel: Integer;
    UserAccessID: Integer;
    UserDeleted: Boolean;
    UserDescription: string;
    UserIP: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetUserlist = class;

  TJVCSGetUserlistOutputItem = class(TComponent, IJVCSGetUserlistOutputItem)
  private
    FPtr: PGetUserlistOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetUserlistOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_UserID: Integer; safecall;
    function Get_UserName: WideString; safecall;
    function Get_UserAccessLevel: Integer; safecall;
    function Get_UserAccessID: Integer; safecall;
    function Get_UserDeleted: WordBool; safecall;
    function Get_UserDescription: WideString; safecall;
    function Get_UserIP: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetUserlist = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetUserlist {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetUserlistOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetUserlistOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetUserlistOutputItem read GetOutputItems;
  end;

  // GET_USERS

  PGetUsersOutputItem = ^TGetUsersOutputItem;
  TGetUsersOutputItem = record
    UserID: Integer;
    UserName: JVCSString50;
    UserAcessLevel: Integer;
    UserDeleted: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetUsers = class;

  TJVCSGetUsersOutputItem = class(TComponent, IJVCSGetUsersOutputItem)
  private
    FPtr: PGetUsersOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetUsersOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_UserID: Integer; safecall;
    function Get_UserName: WideString; safecall;
    function Get_UserAcessLevel: Integer; safecall;
    function Get_UserDeleted: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetUsers = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetUsers {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetUsersOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetUsersOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetUsersOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_USER

  TJVCSAddUpdateUser = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateUser {$ENDIF})
  private
    // input
    FUserID: Integer;
    FUserName: JVCSString50;
    FUserPassword: JVCSString50;
    FUserAccessLevel: Integer;
    FUserDescription: string;
    FUserIP: JVCSString50;
    // output
    FAccepted: Boolean;
    FErrorMessage: string;
    FNewUserID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_UserName: WideString; safecall;
    procedure Set_UserName(const Value: WideString); safecall;
    function Get_UserPassword: WideString; safecall;
    procedure Set_UserPassword(const Value: WideString); safecall;
    function Get_UserAccessLevel: Integer; safecall;
    procedure Set_UserAccessLevel(Value: Integer); safecall;
    function Get_UserDescription: WideString; safecall;
    procedure Set_UserDescription(const Value: WideString); safecall;
    function Get_UserIP: WideString; safecall;
    procedure Set_UserIP(const Value: WideString); safecall;
    function Get_Accepted: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    function Get_NewUserID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property UserName: JVCSString50 read FUserName write FUserName;
    property UserPassword: JVCSString50 read FUserPassword write FUserPassword;
    property UserAccessLevel: Integer read FUserAccessLevel write FUserAccessLevel;
    property UserDescription: string read FUserDescription write FUserDescription;
    property UserIP: JVCSString50 read FUserIP write FUserIP;
    // output
    property Accepted: Boolean read FAccepted;
    property ErrorMessage: string read FErrorMessage;
    property NewUserID: Integer read FNewUserID;
  end;

  // CHANGE_PASSWORD

  TJVCSChangePassword = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSChangePassword {$ENDIF})
  private
    // input
    FUserID: Integer;
    FOldPassword: JVCSString50;
    FNewPassword: JVCSString50;
    // output
    FAccepted: Boolean;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_OldPassword: WideString; safecall;
    procedure Set_OldPassword(const Value: WideString); safecall;
    function Get_NewPassword: WideString; safecall;
    procedure Set_NewPassword(const Value: WideString); safecall;
    function Get_Accepted: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property OldPassword: JVCSString50 read FOldPassword write FOldPassword;
    property NewPassword: JVCSString50 read FNewPassword write FNewPassword;
    // output
    property Accepted: Boolean read FAccepted;
    property ErrorMessage: string read FErrorMessage;
  end;

  // REMOVE_USER

  TJVCSRemoveUser = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveUser {$ENDIF})
  private
    // input
    FUserID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
  end;

  // GET_SERVER_TIME

  TJVCSGetServerTime = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetServerTime {$ENDIF})
  private
    // output
    FServerTime: TDateTime;
    FLocalGMTDiff: Integer;
  protected
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ServerTime: TDateTime; safecall;
    function Get_LocalGMTDiff: Integer; safecall;
    {$ENDIF COMVERSION}
    // output
    property ServerTime: TDateTime read FServerTime;
    property LocalGMTDiff: Integer read FLocalGMTDiff;
  end;

  // GET_SERVER_LOG

  TJVCSGetServerLog = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetServerLog {$ENDIF})
  private
    // output
    FFileFound: Boolean;
    FServerLogFile: TMemoryStream;
    {$IFDEF COMVERSION}
    FServerLogFileStreamAdapter: TJVCSStreamAdapter;
    {$ENDIF COMVERSION}
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_FileFound: WordBool; safecall;
    function Get_ServerLogFile: IJVCSReadonlyStream; safecall;
    {$ENDIF COMVERSION}
    // output
    property FileFound: Boolean read FFileFound;
    property ServerLogFile: TMemoryStream read FServerLogFile;
  end;

  // CLEAR_SERVER_LOG

  TJVCSClearServerLog = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSClearServerLog {$ENDIF})
  private
  protected
  public
    {$IFDEF COMVERSION}
    {$ENDIF COMVERSION}
  end;

  // GET_ARCHIVE_TSTAMP

  TJVCSGetArchiveTstamp = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetArchiveTstamp {$ENDIF})
  private
    // output
    FTimestamp: TDateTime;
  protected
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_Timestamp: TDateTime; safecall;
    {$ENDIF COMVERSION}
    // output
    property Timestamp: TDateTime read FTimestamp;
  end;

  // GET_PROJECT_ID

  TJVCSGetProjectId = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectId {$ENDIF})
  private
    // input
    FProjectName: string;
    // output
    FProjectID: Integer;
    FProjectDeleted: Boolean;
    FTransactionID: Integer;
    FAccessLevel: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectName: WideString; safecall;
    procedure Set_ProjectName(const Value: WideString); safecall;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectDeleted: WordBool; safecall;
    function Get_TransactionID: Integer; safecall;
    function Get_AccessLevel: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectName: string read FProjectName write FProjectName;
    // output
    property ProjectID: Integer read FProjectID;
    property ProjectDeleted: Boolean read FProjectDeleted;
    property TransactionID: Integer read FTransactionID;
    property AccessLevel: Integer read FAccessLevel;
  end;

  // GET_PROJECT_RIGHT

  TJVCSGetProjectRight = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectRight {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FProjectRight: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ProjectRight: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property ProjectRight: Integer read FProjectRight;
  end;

  // SEARCH_MODULES

  PSearchModulesOutputItem = ^TSearchModulesOutputItem;
  TSearchModulesOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    Path: JVCSString255;
    AssignedToProject: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSSearchModules = class;

  TJVCSSearchModulesOutputItem = class(TComponent, IJVCSSearchModulesOutputItem)
  private
    FPtr: PSearchModulesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PSearchModulesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_Path: WideString; safecall;
    function Get_AssignedToProject: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSSearchModules = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSSearchModules {$ENDIF})
  private
    // input
    FMaskString: JVCSString255;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TSearchModulesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_MaskString: WideString; safecall;
    procedure Set_MaskString(const Value: WideString); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSSearchModulesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property MaskString: JVCSString255 read FMaskString write FMaskString;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TSearchModulesOutputItem read GetOutputItems;
  end;

  // GET_DESERTED_MODULES

  PGetDesertedModulesOutputItem = ^TGetDesertedModulesOutputItem;
  TGetDesertedModulesOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetDesertedModules = class;

  TJVCSGetDesertedModulesOutputItem = class(TComponent, IJVCSGetDesertedModulesOutputItem)
  private
    FPtr: PGetDesertedModulesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetDesertedModulesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetDesertedModules = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetDesertedModules {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetDesertedModulesOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetDesertedModulesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetDesertedModulesOutputItem read GetOutputItems;
  end;

  // GET_SPACE_BY_PROJECTS

  PGetSpaceByProjectsOutputItem = ^TGetSpaceByProjectsOutputItem;
  TGetSpaceByProjectsOutputItem = record
    ProjectName: JVCSString50;
    RevisionCount: Integer;
    ModuleSizeTotal: Integer;
    CompressedSizeTotal: Integer;
    LastAccessed: TDateTime;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetSpaceByProjects = class;

  TJVCSGetSpaceByProjectsOutputItem = class(TComponent, IJVCSGetSpaceByProjectsOutputItem)
  private
    FPtr: PGetSpaceByProjectsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetSpaceByProjectsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectName: WideString; safecall;
    function Get_RevisionCount: Integer; safecall;
    function Get_ModuleSizeTotal: Integer; safecall;
    function Get_CompressedSizeTotal: Integer; safecall;
    function Get_LastAccessed: TDateTime; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetSpaceByProjects = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetSpaceByProjects {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetSpaceByProjectsOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetSpaceByProjectsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetSpaceByProjectsOutputItem read GetOutputItems;
  end;

  // GET_SPACE_BY_MODULES

  PGetSpaceByModulesOutputItem = ^TGetSpaceByModulesOutputItem;
  TGetSpaceByModulesOutputItem = record
    ModuleName: JVCSString50;
    RevisionCount: Integer;
    ModuleSizeTotal: Integer;
    CompressedSizeTotal: Integer;
    LastAccessed: TDateTime;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetSpaceByModules = class;

  TJVCSGetSpaceByModulesOutputItem = class(TComponent, IJVCSGetSpaceByModulesOutputItem)
  private
    FPtr: PGetSpaceByModulesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetSpaceByModulesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleName: WideString; safecall;
    function Get_RevisionCount: Integer; safecall;
    function Get_ModuleSizeTotal: Integer; safecall;
    function Get_CompressedSizeTotal: Integer; safecall;
    function Get_LastAccessed: TDateTime; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetSpaceByModules = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetSpaceByModules {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetSpaceByModulesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetSpaceByModulesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetSpaceByModulesOutputItem read GetOutputItems;
  end;

  // LIVE_BACKUP

  PLiveBackupOutputItem = ^TLiveBackupOutputItem;
  TLiveBackupOutputItem = record
    TableName: string;
    TableSize: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSLiveBackup = class;

  TJVCSLiveBackupOutputItem = class(TComponent, IJVCSLiveBackupOutputItem)
  private
    FPtr: PLiveBackupOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PLiveBackupOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_TableName: WideString; safecall;
    function Get_TableSize: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSLiveBackup = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSLiveBackup {$ENDIF})
  private
    // input
    FTargetFolder: string;
    // output
    FBackupSuccess: Boolean;
    FErrorMessage: string;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TLiveBackupOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_TargetFolder: WideString; safecall;
    procedure Set_TargetFolder(const Value: WideString); safecall;
    function Get_BackupSuccess: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSLiveBackupOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property TargetFolder: string read FTargetFolder write FTargetFolder;
    // output
    property BackupSuccess: Boolean read FBackupSuccess;
    property ErrorMessage: string read FErrorMessage;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TLiveBackupOutputItem read GetOutputItems;
  end;

  // PURGE_PROJECT

  TJVCSPurgeProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSPurgeProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FRevisionsToKeep: Integer;
    FExec: Boolean;
    // output
    FAffectedFileCount: Integer;
    FDeletedRevisionCount: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_RevisionsToKeep: Integer; safecall;
    procedure Set_RevisionsToKeep(Value: Integer); safecall;
    function Get_Exec: WordBool; safecall;
    procedure Set_Exec(Value: WordBool); safecall;
    function Get_AffectedFileCount: Integer; safecall;
    function Get_DeletedRevisionCount: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property RevisionsToKeep: Integer read FRevisionsToKeep write FRevisionsToKeep;
    property Exec: Boolean read FExec write FExec;
    // output
    property AffectedFileCount: Integer read FAffectedFileCount;
    property DeletedRevisionCount: Integer read FDeletedRevisionCount;
  end;

  // READ_CONFIG_DATA

  PReadConfigDataInputItem = ^TReadConfigDataInputItem;
  TReadConfigDataInputItem = record
    Value: string;
  end;
  PReadConfigDataOutputItem = ^TReadConfigDataOutputItem;
  TReadConfigDataOutputItem = record
    Value: string;
    Data: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSReadConfigData = class;

  TJVCSReadConfigDataInputItem = class(TComponent, IJVCSReadConfigDataInputItem)
  private
    FPtr: PReadConfigDataInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReadConfigDataInputItem); reintroduce;
    destructor Destroy; override;
    function Get_Value: WideString; safecall;
  end;

  TJVCSReadConfigDataOutputItem = class(TComponent, IJVCSReadConfigDataOutputItem)
  private
    FPtr: PReadConfigDataOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReadConfigDataOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_Value: WideString; safecall;
    function Get_Data: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSReadConfigData = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSReadConfigData {$ENDIF})
  private
    // input
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    procedure ClearOutputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TReadConfigDataInputItem;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TReadConfigDataOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(const AValue: string): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function IJVCSReadConfigData.AddInputItem = COMAddInputItem;
    function COMAddInputItem(const AValue: WideString): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSReadConfigDataInputItem; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSReadConfigDataOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TReadConfigDataInputItem read GetInputItems;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TReadConfigDataOutputItem read GetOutputItems;
  end;

  // WRITE_CONFIG_DATA

  PWriteConfigDataInputItem = ^TWriteConfigDataInputItem;
  TWriteConfigDataInputItem = record
    Value: string;
    Data: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSWriteConfigData = class;

  TJVCSWriteConfigDataInputItem = class(TComponent, IJVCSWriteConfigDataInputItem)
  private
    FPtr: PWriteConfigDataInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PWriteConfigDataInputItem); reintroduce;
    destructor Destroy; override;
    function Get_Value: WideString; safecall;
    function Get_Data: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSWriteConfigData = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSWriteConfigData {$ENDIF})
  private
    // input
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TWriteConfigDataInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(const AValue: string; const AData: string): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function IJVCSWriteConfigData.AddInputItem = COMAddInputItem;
    function COMAddInputItem(const AValue: WideString; const AData: WideString): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSWriteConfigDataInputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TWriteConfigDataInputItem read GetInputItems;
  end;

  // GET_PROJECT_MODULE_LIST

  PGetProjectModuleListOutputItem = ^TGetProjectModuleListOutputItem;
  TGetProjectModuleListOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectModuleList = class;

  TJVCSGetProjectModuleListOutputItem = class(TComponent, IJVCSGetProjectModuleListOutputItem)
  private
    FPtr: PGetProjectModuleListOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectModuleListOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectModuleList = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectModuleList {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectModuleListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectModuleListOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectModuleListOutputItem read GetOutputItems;
  end;

  // GET_BLANK_MODULE_LIST

  PGetBlankModuleListOutputItem = ^TGetBlankModuleListOutputItem;
  TGetBlankModuleListOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    Hidden: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetBlankModuleList = class;

  TJVCSGetBlankModuleListOutputItem = class(TComponent, IJVCSGetBlankModuleListOutputItem)
  private
    FPtr: PGetBlankModuleListOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetBlankModuleListOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_Hidden: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetBlankModuleList = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetBlankModuleList {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetBlankModuleListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetBlankModuleListOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetBlankModuleListOutputItem read GetOutputItems;
  end;

  // GET_SHARED_BY

  PGetSharedByOutputItem = ^TGetSharedByOutputItem;
  TGetSharedByOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetSharedBy = class;

  TJVCSGetSharedByOutputItem = class(TComponent, IJVCSGetSharedByOutputItem)
  private
    FPtr: PGetSharedByOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetSharedByOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetSharedBy = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetSharedBy {$ENDIF})
  private
    // input
    FModuleID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetSharedByOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetSharedByOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetSharedByOutputItem read GetOutputItems;
  end;

  // ADD_NEW_PROJECT

  TJVCSAddNewProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddNewProject {$ENDIF})
  private
    // input
    FUserID: Integer;
    FProjectName: JVCSString50;
    FDescription: string;
    // output
    FIsNewProject: Boolean;
    FProjectID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ProjectName: WideString; safecall;
    procedure Set_ProjectName(const Value: WideString); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    function Get_IsNewProject: WordBool; safecall;
    function Get_ProjectID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property ProjectName: JVCSString50 read FProjectName write FProjectName;
    property Description: string read FDescription write FDescription;
    // output
    property IsNewProject: Boolean read FIsNewProject;
    property ProjectID: Integer read FProjectID;
  end;

  // REMOVE_PROJECT

  PRemoveProjectOutputItem = ^TRemoveProjectOutputItem;
  TRemoveProjectOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSRemoveProject = class;

  TJVCSRemoveProjectOutputItem = class(TComponent, IJVCSRemoveProjectOutputItem)
  private
    FPtr: PRemoveProjectOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRemoveProjectOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRemoveProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FRemoved: Boolean;
    FErrorMessage: string;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TRemoveProjectOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_Removed: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSRemoveProjectOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property Removed: Boolean read FRemoved;
    property ErrorMessage: string read FErrorMessage;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TRemoveProjectOutputItem read GetOutputItems;
  end;

  // RESTORE_PROJECT

  TJVCSRestoreProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRestoreProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
  end;

  // GET_PROJECT_REFERENCES

  PGetProjectReferencesOutputItem = ^TGetProjectReferencesOutputItem;
  TGetProjectReferencesOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectReferences = class;

  TJVCSGetProjectReferencesOutputItem = class(TComponent, IJVCSGetProjectReferencesOutputItem)
  private
    FPtr: PGetProjectReferencesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectReferencesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectReferences = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectReferences {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectReferencesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectReferencesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectReferencesOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_PROJECT_REFERENCES

  PAddUpdateProjectReferencesInputItem = ^TAddUpdateProjectReferencesInputItem;
  TAddUpdateProjectReferencesInputItem = record
    ReferenceID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSAddUpdateProjectReferences = class;

  TJVCSAddUpdateProjectReferencesInputItem = class(TComponent, IJVCSAddUpdateProjectReferencesInputItem)
  private
    FPtr: PAddUpdateProjectReferencesInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PAddUpdateProjectReferencesInputItem); reintroduce;
    destructor Destroy; override;
    function Get_ReferenceID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSAddUpdateProjectReferences = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateProjectReferences {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUpdate: Boolean;
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TAddUpdateProjectReferencesInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(AReferenceID: Integer): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_Update: WordBool; safecall;
    procedure Set_Update(Value: WordBool); safecall;
    function IJVCSAddUpdateProjectReferences.AddInputItem = COMAddInputItem;
    function COMAddInputItem(AReferenceID: Integer): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSAddUpdateProjectReferencesInputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property Update: Boolean read FUpdate write FUpdate;
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TAddUpdateProjectReferencesInputItem read GetInputItems;
  end;

  // REMOVE_PROJECT_REFERENCES

  TJVCSRemoveProjectReferences = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveProjectReferences {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FReferenceID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ReferenceID: Integer; safecall;
    procedure Set_ReferenceID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ReferenceID: Integer read FReferenceID write FReferenceID;
  end;

  // GET_PROJECT_INFORMATION

  PGetProjectInformationOutputItem = ^TGetProjectInformationOutputItem;
  TGetProjectInformationOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString50;
    Created: TDateTime;
    CreatedBy: JVCSString50;
    LastWriteAccess: TDateTime;
    LastUser: JVCSString50;
    Description: string;
    Deleted: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectInformation = class;

  TJVCSGetProjectInformationOutputItem = class(TComponent, IJVCSGetProjectInformationOutputItem)
  private
    FPtr: PGetProjectInformationOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectInformationOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
    function Get_Created: TDateTime; safecall;
    function Get_CreatedBy: WideString; safecall;
    function Get_LastWriteAccess: TDateTime; safecall;
    function Get_LastUser: WideString; safecall;
    function Get_Description: WideString; safecall;
    function Get_Deleted: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectInformation = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectInformation {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectInformationOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectInformationOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectInformationOutputItem read GetOutputItems;
  end;

  // GET_PROJECT_LIST

  PGetProjectListOutputItem = ^TGetProjectListOutputItem;
  TGetProjectListOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString50;
    ProjectDeleted: Boolean;
    History: string;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectList = class;

  TJVCSGetProjectListOutputItem = class(TComponent, IJVCSGetProjectListOutputItem)
  private
    FPtr: PGetProjectListOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectListOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
    function Get_ProjectDeleted: WordBool; safecall;
    function Get_History: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectList = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectList {$ENDIF})
  private
    // input
    FPurpose: JVCSString1;
    FIncludeDetails: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_Purpose: WideString; safecall;
    procedure Set_Purpose(const Value: WideString); safecall;
    function Get_IncludeDetails: WordBool; safecall;
    procedure Set_IncludeDetails(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectListOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property Purpose: JVCSString1 read FPurpose write FPurpose;
    property IncludeDetails: Boolean read FIncludeDetails write FIncludeDetails;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectListOutputItem read GetOutputItems;
  end;

  // GET_VERSION_LIST

  PGetVersionListOutputItem = ^TGetVersionListOutputItem;
  TGetVersionListOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Timestamp: TDateTime;
    UserID: Integer;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Hidden: Boolean;
    Owner: JVCSString50;
    RevisionCount: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetVersionList = class;

  TJVCSGetVersionListOutputItem = class(TComponent, IJVCSGetVersionListOutputItem)
  private
    FPtr: PGetVersionListOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetVersionListOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_UserID: Integer; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_Hidden: WordBool; safecall;
    function Get_Owner: WideString; safecall;
    function Get_RevisionCount: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetVersionList = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetVersionList {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetVersionListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetVersionListOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetVersionListOutputItem read GetOutputItems;
  end;

  // GET_REVISION_LIST

  PGetRevisionListOutputItem = ^TGetRevisionListOutputItem;
  TGetRevisionListOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Timestamp: TDateTime;
    UserID: Integer;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Hidden: Boolean;
    Owner: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRevisionList = class;

  TJVCSGetRevisionListOutputItem = class(TComponent, IJVCSGetRevisionListOutputItem)
  private
    FPtr: PGetRevisionListOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRevisionListOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_UserID: Integer; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_Hidden: WordBool; safecall;
    function Get_Owner: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRevisionList = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionList {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRevisionListOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRevisionListOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRevisionListOutputItem read GetOutputItems;
  end;

  // GET_LATEST_REVISIONS

  PGetLatestRevisionsOutputItem = ^TGetLatestRevisionsOutputItem;
  TGetLatestRevisionsOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    RevisionTimestamp: TDateTime;
    RevisionExtension: JVCSString20;
    RevisionCRC32: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLatestRevisions = class;

  TJVCSGetLatestRevisionsOutputItem = class(TComponent, IJVCSGetLatestRevisionsOutputItem)
  private
    FPtr: PGetLatestRevisionsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLatestRevisionsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionTimestamp: TDateTime; safecall;
    function Get_RevisionExtension: WideString; safecall;
    function Get_RevisionCRC32: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLatestRevisions = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLatestRevisions {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    FLabelID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLatestRevisionsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLatestRevisionsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    property LabelID: Integer read FLabelID write FLabelID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLatestRevisionsOutputItem read GetOutputItems;
  end;

  // GET_VERSION_REVISION

  PGetVersionRevisionOutputItem = ^TGetVersionRevisionOutputItem;
  TGetVersionRevisionOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    RevisionTimestamp: TDateTime;
    RevisionExtension: JVCSString20;
    RevisionCRC32: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetVersionRevision = class;

  TJVCSGetVersionRevisionOutputItem = class(TComponent, IJVCSGetVersionRevisionOutputItem)
  private
    FPtr: PGetVersionRevisionOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetVersionRevisionOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionTimestamp: TDateTime; safecall;
    function Get_RevisionExtension: WideString; safecall;
    function Get_RevisionCRC32: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetVersionRevision = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetVersionRevision {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    FVersion: Integer;
    FRevision: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetVersionRevisionOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_Version: Integer; safecall;
    procedure Set_Version(Value: Integer); safecall;
    function Get_Revision: Integer; safecall;
    procedure Set_Revision(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetVersionRevisionOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    property Version: Integer read FVersion write FVersion;
    property Revision: Integer read FRevision write FRevision;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetVersionRevisionOutputItem read GetOutputItems;
  end;

  // GET_ROLLBACK_REVISIONS

  PGetRollbackRevisionsOutputItem = ^TGetRollbackRevisionsOutputItem;
  TGetRollbackRevisionsOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    RevisionTimestamp: TDateTime;
    RevisionExtension: JVCSString20;
    RevisionCRC32: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRollbackRevisions = class;

  TJVCSGetRollbackRevisionsOutputItem = class(TComponent, IJVCSGetRollbackRevisionsOutputItem)
  private
    FPtr: PGetRollbackRevisionsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRollbackRevisionsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionTimestamp: TDateTime; safecall;
    function Get_RevisionExtension: WideString; safecall;
    function Get_RevisionCRC32: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRollbackRevisions = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRollbackRevisions {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FExcludeHiddenModules: Boolean;
    FRollbackDate: TDateTime;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRollbackRevisionsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_RollbackDate: TDateTime; safecall;
    procedure Set_RollbackDate(Value: TDateTime); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRollbackRevisionsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    property RollbackDate: TDateTime read FRollbackDate write FRollbackDate;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRollbackRevisionsOutputItem read GetOutputItems;
  end;

  // GET_LOCKED_MODULES

  PGetLockedModulesOutputItem = ^TGetLockedModulesOutputItem;
  TGetLockedModulesOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    Version: Integer;
    Revision: Integer;
    LockedTimestamp: TDateTime;
    Owner: JVCSString50;
    OwnerID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLockedModules = class;

  TJVCSGetLockedModulesOutputItem = class(TComponent, IJVCSGetLockedModulesOutputItem)
  private
    FPtr: PGetLockedModulesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLockedModulesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_LockedTimestamp: TDateTime; safecall;
    function Get_Owner: WideString; safecall;
    function Get_OwnerID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLockedModules = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLockedModules {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLockedModulesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLockedModulesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLockedModulesOutputItem read GetOutputItems;
  end;

  // RENAME_PROJECT

  PRenameProjectInputItem = ^TRenameProjectInputItem;
  TRenameProjectInputItem = record
    ModuleID: Integer;
    NewModuleName: JVCSString255;
  end;
  PRenameProjectOutputItem = ^TRenameProjectOutputItem;
  TRenameProjectOutputItem = record
    ModuleName: JVCSString255;
  end;
  {$IFDEF COMVERSION}
  TJVCSRenameProject = class;

  TJVCSRenameProjectInputItem = class(TComponent, IJVCSRenameProjectInputItem)
  private
    FPtr: PRenameProjectInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRenameProjectInputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_NewModuleName: WideString; safecall;
  end;

  TJVCSRenameProjectOutputItem = class(TComponent, IJVCSRenameProjectOutputItem)
  private
    FPtr: PRenameProjectOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRenameProjectOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRenameProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRenameProject {$ENDIF})
  private
    // input
    FUserID: Integer;
    FProjectID: Integer;
    FNewProjectName: JVCSString50;
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    // output
    FRenamed: Boolean;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    procedure ClearOutputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TRenameProjectInputItem;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TRenameProjectOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(AModuleID: Integer; const ANewModuleName: string): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_NewProjectName: WideString; safecall;
    procedure Set_NewProjectName(const Value: WideString); safecall;
    function IJVCSRenameProject.AddInputItem = COMAddInputItem;
    function COMAddInputItem(AModuleID: Integer; const ANewModuleName: WideString): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSRenameProjectInputItem; safecall;
    function Get_Renamed: WordBool; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSRenameProjectOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property ProjectID: Integer read FProjectID write FProjectID;
    property NewProjectName: JVCSString50 read FNewProjectName write FNewProjectName;
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TRenameProjectInputItem read GetInputItems;
    // output
    property Renamed: Boolean read FRenamed;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TRenameProjectOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_PROJECT_GROUP

  TJVCSAddUpdateProjectGroup = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateProjectGroup {$ENDIF})
  private
    // input
    FGroupID: Integer;
    FParentID: Integer;
    FGroupLevel: Integer;
    FFlags: Integer;
    FGroupName: JVCSString50;
    FGroupDescription: string;
    // output
    FAddedGroupID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_GroupID: Integer; safecall;
    procedure Set_GroupID(Value: Integer); safecall;
    function Get_ParentID: Integer; safecall;
    procedure Set_ParentID(Value: Integer); safecall;
    function Get_GroupLevel: Integer; safecall;
    procedure Set_GroupLevel(Value: Integer); safecall;
    function Get_Flags: Integer; safecall;
    procedure Set_Flags(Value: Integer); safecall;
    function Get_GroupName: WideString; safecall;
    procedure Set_GroupName(const Value: WideString); safecall;
    function Get_GroupDescription: WideString; safecall;
    procedure Set_GroupDescription(const Value: WideString); safecall;
    function Get_AddedGroupID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property GroupID: Integer read FGroupID write FGroupID;
    property ParentID: Integer read FParentID write FParentID;
    property GroupLevel: Integer read FGroupLevel write FGroupLevel;
    property Flags: Integer read FFlags write FFlags;
    property GroupName: JVCSString50 read FGroupName write FGroupName;
    property GroupDescription: string read FGroupDescription write FGroupDescription;
    // output
    property AddedGroupID: Integer read FAddedGroupID;
  end;

  // REMOVE_PROJECT_GROUP

  TJVCSRemoveProjectGroup = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveProjectGroup {$ENDIF})
  private
    // input
    FGroupID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_GroupID: Integer; safecall;
    procedure Set_GroupID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property GroupID: Integer read FGroupID write FGroupID;
  end;

  // GET_PROJECT_GROUP_INFORMATION

  PGetProjectGroupInformationOutputItem = ^TGetProjectGroupInformationOutputItem;
  TGetProjectGroupInformationOutputItem = record
    RecordType: JVCSString1;
    GroupID: Integer;
    ParentID: Integer;
    GroupLevel: Integer;
    Flags: Integer;
    GroupName: JVCSString50;
    GroupDescription: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectGroupInformation = class;

  TJVCSGetProjectGroupInformationOutputItem = class(TComponent, IJVCSGetProjectGroupInformationOutputItem)
  private
    FPtr: PGetProjectGroupInformationOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectGroupInformationOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_RecordType: WideString; safecall;
    function Get_GroupID: Integer; safecall;
    function Get_ParentID: Integer; safecall;
    function Get_GroupLevel: Integer; safecall;
    function Get_Flags: Integer; safecall;
    function Get_GroupName: WideString; safecall;
    function Get_GroupDescription: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectGroupInformation = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectGroupInformation {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectGroupInformationOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectGroupInformationOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectGroupInformationOutputItem read GetOutputItems;
  end;

  // ADD_REMOVE_PROJECT_TO_GROUP

  TJVCSAddRemoveProjectToGroup = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddRemoveProjectToGroup {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FGroupID: Integer;
    FAdd: Boolean;
    // output
    FAdded: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_GroupID: Integer; safecall;
    procedure Set_GroupID(Value: Integer); safecall;
    function Get_Add: WordBool; safecall;
    procedure Set_Add(Value: WordBool); safecall;
    function Get_Added: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property GroupID: Integer read FGroupID write FGroupID;
    property Add: Boolean read FAdd write FAdd;
    // output
    property Added: Boolean read FAdded;
  end;

  // GET_MODULE_ID

  TJVCSGetModuleId = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetModuleId {$ENDIF})
  private
    // input
    FModuleName: string;
    // output
    FModuleID: Integer;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_ModuleID: Integer; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleName: string read FModuleName write FModuleName;
    // output
    property ModuleID: Integer read FModuleID;
    property ErrorMessage: string read FErrorMessage;
  end;

  // GET_MODULE_NAME

  TJVCSGetModuleName = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetModuleName {$ENDIF})
  private
    // input
    FModuleID: Integer;
    // output
    FModuleName: string;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property ModuleName: string read FModuleName;
    property ErrorMessage: string read FErrorMessage;
  end;

  // RENAME_MODULE

  TJVCSRenameModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRenameModule {$ENDIF})
  private
    // input
    FModuleID: Integer;
    FNewModuleName: string;
    FProjectID: Integer;
    // output
    FSuccess: Boolean;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_NewModuleName: WideString; safecall;
    procedure Set_NewModuleName(const Value: WideString); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_Success: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    property NewModuleName: string read FNewModuleName write FNewModuleName;
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property Success: Boolean read FSuccess;
    property ErrorMessage: string read FErrorMessage;
  end;

  // GET_MODULES_LIKE

  PGetModulesLikeOutputItem = ^TGetModulesLikeOutputItem;
  TGetModulesLikeOutputItem = record
    ModuleID: Integer;
    ModulePath: JVCSString250;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetModulesLike = class;

  TJVCSGetModulesLikeOutputItem = class(TComponent, IJVCSGetModulesLikeOutputItem)
  private
    FPtr: PGetModulesLikeOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetModulesLikeOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModulePath: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetModulesLike = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetModulesLike {$ENDIF})
  private
    // input
    FModuleName: string;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetModulesLikeOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetModulesLikeOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleName: string read FModuleName write FModuleName;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetModulesLikeOutputItem read GetOutputItems;
  end;

  // GET_REVISION_LIST_BY_NAME

  PGetRevisionListByNameOutputItem = ^TGetRevisionListByNameOutputItem;
  TGetRevisionListByNameOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Timestamp: TDateTime;
    UserID: Integer;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Owner: JVCSString50;
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRevisionListByName = class;

  TJVCSGetRevisionListByNameOutputItem = class(TComponent, IJVCSGetRevisionListByNameOutputItem)
  private
    FPtr: PGetRevisionListByNameOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRevisionListByNameOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_UserID: Integer; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_Owner: WideString; safecall;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRevisionListByName = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionListByName {$ENDIF})
  private
    // input
    FModuleName: string;
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRevisionListByNameOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRevisionListByNameOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleName: string read FModuleName write FModuleName;
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRevisionListByNameOutputItem read GetOutputItems;
  end;

  // GET_REVISION_LIST_BY_ID

  PGetRevisionListByIdOutputItem = ^TGetRevisionListByIdOutputItem;
  TGetRevisionListByIdOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Timestamp: TDateTime;
    UserID: Integer;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Owner: JVCSString50;
    ProjectID: Integer;
    Hidden: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRevisionListById = class;

  TJVCSGetRevisionListByIdOutputItem = class(TComponent, IJVCSGetRevisionListByIdOutputItem)
  private
    FPtr: PGetRevisionListByIdOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRevisionListByIdOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_UserID: Integer; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_Owner: WideString; safecall;
    function Get_ProjectID: Integer; safecall;
    function Get_Hidden: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRevisionListById = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionListById {$ENDIF})
  private
    // input
    FModuleID: Integer;
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRevisionListByIdOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRevisionListByIdOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRevisionListByIdOutputItem read GetOutputItems;
  end;

  // GET_REVISION_LIST_BY_VERSION

  PGetRevisionListByVersionOutputItem = ^TGetRevisionListByVersionOutputItem;
  TGetRevisionListByVersionOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Timestamp: TDateTime;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    Owner: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRevisionListByVersion = class;

  TJVCSGetRevisionListByVersionOutputItem = class(TComponent, IJVCSGetRevisionListByVersionOutputItem)
  private
    FPtr: PGetRevisionListByVersionOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRevisionListByVersionOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_Owner: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRevisionListByVersion = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionListByVersion {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FVersion: Integer;
    FRevision: Integer;
    FExcludeHiddenModules: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRevisionListByVersionOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_Version: Integer; safecall;
    procedure Set_Version(Value: Integer); safecall;
    function Get_Revision: Integer; safecall;
    procedure Set_Revision(Value: Integer); safecall;
    function Get_ExcludeHiddenModules: WordBool; safecall;
    procedure Set_ExcludeHiddenModules(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRevisionListByVersionOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property Version: Integer read FVersion write FVersion;
    property Revision: Integer read FRevision write FRevision;
    property ExcludeHiddenModules: Boolean read FExcludeHiddenModules write FExcludeHiddenModules;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRevisionListByVersionOutputItem read GetOutputItems;
  end;

  // GET_REVISION_STATUS

  PGetRevisionStatusOutputItem = ^TGetRevisionStatusOutputItem;
  TGetRevisionStatusOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
    ModulePath: JVCSString255;
    CheckedOut: Boolean;
    Version: Integer;
    Revision: Integer;
    RevisionOriginalTime: TDateTime;
    RevisionOriginalSize: Integer;
    RevisionOriginalCRC: Integer;
    RevisionCompressedSize: Integer;
    RevisionExtension: JVCSString20;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetRevisionStatus = class;

  TJVCSGetRevisionStatusOutputItem = class(TComponent, IJVCSGetRevisionStatusOutputItem)
  private
    FPtr: PGetRevisionStatusOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetRevisionStatusOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionOriginalTime: TDateTime; safecall;
    function Get_RevisionOriginalSize: Integer; safecall;
    function Get_RevisionOriginalCRC: Integer; safecall;
    function Get_RevisionCompressedSize: Integer; safecall;
    function Get_RevisionExtension: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetRevisionStatus = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionStatus {$ENDIF})
  private
    // input
    FRevisionID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetRevisionStatusOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetRevisionStatusOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property RevisionID: Integer read FRevisionID write FRevisionID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetRevisionStatusOutputItem read GetOutputItems;
  end;

  // GET_REVISION_COMMENT

  TJVCSGetRevisionComment = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetRevisionComment {$ENDIF})
  private
    // input
    FRevisionID: Integer;
    // output
    FCheckinComment: string;
    FCheckoutComment: string;
    FVersionState: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_CheckinComment: WideString; safecall;
    function Get_CheckoutComment: WideString; safecall;
    function Get_VersionState: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property RevisionID: Integer read FRevisionID write FRevisionID;
    // output
    property CheckinComment: string read FCheckinComment;
    property CheckoutComment: string read FCheckoutComment;
    property VersionState: Integer read FVersionState;
  end;

  // CHANGE_REVISION_COMMENT

  TJVCSChangeRevisionComment = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSChangeRevisionComment {$ENDIF})
  private
    // input
    FRevisionID: Integer;
    FCommentType: JVCSString1;
    FCommentValue: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_CommentType: WideString; safecall;
    procedure Set_CommentType(const Value: WideString); safecall;
    function Get_CommentValue: WideString; safecall;
    procedure Set_CommentValue(const Value: WideString); safecall;
    {$ENDIF COMVERSION}
    // input
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property CommentType: JVCSString1 read FCommentType write FCommentType;
    property CommentValue: string read FCommentValue write FCommentValue;
  end;

  // GET_BLOB_STATUS

  PGetBlobStatusOutputItem = ^TGetBlobStatusOutputItem;
  TGetBlobStatusOutputItem = record
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    RevisionOriginalTime: TDateTime;
    RevisionOriginalSize: Integer;
    RevisionOriginalCRC: Integer;
    RevisionCompressedSize: Integer;
    RevisionExtension: JVCSString20;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetBlobStatus = class;

  TJVCSGetBlobStatusOutputItem = class(TComponent, IJVCSGetBlobStatusOutputItem)
  private
    FPtr: PGetBlobStatusOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetBlobStatusOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionOriginalTime: TDateTime; safecall;
    function Get_RevisionOriginalSize: Integer; safecall;
    function Get_RevisionOriginalCRC: Integer; safecall;
    function Get_RevisionCompressedSize: Integer; safecall;
    function Get_RevisionExtension: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetBlobStatus = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetBlobStatus {$ENDIF})
  private
    // input
    FModuleID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetBlobStatusOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetBlobStatusOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetBlobStatusOutputItem read GetOutputItems;
  end;

  // GET_MODULE_HISTORY

  PGetModuleHistoryOutputItem = ^TGetModuleHistoryOutputItem;
  TGetModuleHistoryOutputItem = record
    CheckedOut: Boolean;
    Version: Integer;
    Revision: Integer;
    UserName: JVCSString50;
    Timestamp: TDateTime;
    Size: Integer;
    Extension: JVCSString20;
    CheckinComment: string;
    CheckoutComment: string;
    RevisionID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetModuleHistory = class;

  TJVCSGetModuleHistoryOutputItem = class(TComponent, IJVCSGetModuleHistoryOutputItem)
  private
    FPtr: PGetModuleHistoryOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetModuleHistoryOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_CheckedOut: WordBool; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_UserName: WideString; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_Size: Integer; safecall;
    function Get_Extension: WideString; safecall;
    function Get_CheckinComment: WideString; safecall;
    function Get_CheckoutComment: WideString; safecall;
    function Get_RevisionID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetModuleHistory = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetModuleHistory {$ENDIF})
  private
    // input
    FModuleID: Integer;
    // output
    FModuleDescription: string;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetModuleHistoryOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_ModuleDescription: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetModuleHistoryOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property ModuleDescription: string read FModuleDescription;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetModuleHistoryOutputItem read GetOutputItems;
  end;

  // IS_MEMBER_OF_PROJECT

  TJVCSIsMemberOfProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSIsMemberOfProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FModuleFullName: string;
    // output
    FIsMemberOf: Boolean;
    FModuleID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ModuleFullName: WideString; safecall;
    procedure Set_ModuleFullName(const Value: WideString); safecall;
    function Get_IsMemberOf: WordBool; safecall;
    function Get_ModuleID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ModuleFullName: string read FModuleFullName write FModuleFullName;
    // output
    property IsMemberOf: Boolean read FIsMemberOf;
    property ModuleID: Integer read FModuleID;
  end;

  // GET_SINGLE_BLOB

  TJVCSGetSingleBlob = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetSingleBlob {$ENDIF})
  private
    // input
    FRevisionID: Integer;
    FExtension: JVCSString20;
    // output
    FModuleOriginalTime: TDateTime;
    FModuleOriginalSize: Integer;
    FModuleOriginalCRC: Integer;
    FModuleCompressedSize: Integer;
    FModuleExtension: JVCSString20;
    FModuleBinary: TMemoryStream;
    {$IFDEF COMVERSION}
    FModuleBinaryStreamAdapter: TJVCSStreamAdapter;
    {$ENDIF COMVERSION}
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_Extension: WideString; safecall;
    procedure Set_Extension(const Value: WideString); safecall;
    function Get_ModuleOriginalTime: TDateTime; safecall;
    function Get_ModuleOriginalSize: Integer; safecall;
    function Get_ModuleOriginalCRC: Integer; safecall;
    function Get_ModuleCompressedSize: Integer; safecall;
    function Get_ModuleExtension: WideString; safecall;
    function Get_ModuleBinary: IJVCSReadonlyStream; safecall;
    {$ENDIF COMVERSION}
    // input
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property Extension: JVCSString20 read FExtension write FExtension;
    // output
    property ModuleOriginalTime: TDateTime read FModuleOriginalTime;
    property ModuleOriginalSize: Integer read FModuleOriginalSize;
    property ModuleOriginalCRC: Integer read FModuleOriginalCRC;
    property ModuleCompressedSize: Integer read FModuleCompressedSize;
    property ModuleExtension: JVCSString20 read FModuleExtension;
    property ModuleBinary: TMemoryStream read FModuleBinary;
  end;

  // GET_SHARED_MODULES

  PGetSharedModulesOutputItem = ^TGetSharedModulesOutputItem;
  TGetSharedModulesOutputItem = record
    ModuleID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetSharedModules = class;

  TJVCSGetSharedModulesOutputItem = class(TComponent, IJVCSGetSharedModulesOutputItem)
  private
    FPtr: PGetSharedModulesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetSharedModulesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetSharedModules = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetSharedModules {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetSharedModulesOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetSharedModulesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetSharedModulesOutputItem read GetOutputItems;
  end;

  // ADD_NEW_MODULE

  PAddNewModuleOutputItem = ^TAddNewModuleOutputItem;
  TAddNewModuleOutputItem = record
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSAddNewModule = class;

  TJVCSAddNewModuleOutputItem = class(TComponent, IJVCSAddNewModuleOutputItem)
  private
    FPtr: PAddNewModuleOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PAddNewModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSAddNewModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddNewModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleFullName: string;
    FFlags: Integer;
    FDescription: string;
    // output
    FIsNewModule: Boolean;
    FModuleID: Integer;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TAddNewModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleFullName: WideString; safecall;
    procedure Set_ModuleFullName(const Value: WideString); safecall;
    function Get_Flags: Integer; safecall;
    procedure Set_Flags(Value: Integer); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    function Get_IsNewModule: WordBool; safecall;
    function Get_ModuleID: Integer; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSAddNewModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleFullName: string read FModuleFullName write FModuleFullName;
    property Flags: Integer read FFlags write FFlags;
    property Description: string read FDescription write FDescription;
    // output
    property IsNewModule: Boolean read FIsNewModule;
    property ModuleID: Integer read FModuleID;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TAddNewModuleOutputItem read GetOutputItems;
  end;

  // REMOVE_MODULE

  PRemoveModuleOutputItem = ^TRemoveModuleOutputItem;
  TRemoveModuleOutputItem = record
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSRemoveModule = class;

  TJVCSRemoveModuleOutputItem = class(TComponent, IJVCSRemoveModuleOutputItem)
  private
    FPtr: PRemoveModuleOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRemoveModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRemoveModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FRemoveFromArchive: Boolean;
    FModuleName: JVCSString255;
    // output
    FModuleRemoved: Boolean;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TRemoveModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_RemoveFromArchive: WordBool; safecall;
    procedure Set_RemoveFromArchive(Value: WordBool); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_ModuleRemoved: WordBool; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSRemoveModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property RemoveFromArchive: Boolean read FRemoveFromArchive write FRemoveFromArchive;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property ModuleRemoved: Boolean read FModuleRemoved;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TRemoveModuleOutputItem read GetOutputItems;
  end;

  // REMOVE_REVISION

  PRemoveRevisionOutputItem = ^TRemoveRevisionOutputItem;
  TRemoveRevisionOutputItem = record
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSRemoveRevision = class;

  TJVCSRemoveRevisionOutputItem = class(TComponent, IJVCSRemoveRevisionOutputItem)
  private
    FPtr: PRemoveRevisionOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRemoveRevisionOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRemoveRevision = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveRevision {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FRevisionID: Integer;
    FModuleName: JVCSString255;
    // output
    FRevisionRemoved: Boolean;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TRemoveRevisionOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_RevisionRemoved: WordBool; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSRemoveRevisionOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property RevisionRemoved: Boolean read FRevisionRemoved;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TRemoveRevisionOutputItem read GetOutputItems;
  end;

  // REMOVE_VERSION

  PRemoveVersionOutputItem = ^TRemoveVersionOutputItem;
  TRemoveVersionOutputItem = record
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSRemoveVersion = class;

  TJVCSRemoveVersionOutputItem = class(TComponent, IJVCSRemoveVersionOutputItem)
  private
    FPtr: PRemoveVersionOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRemoveVersionOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRemoveVersion = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveVersion {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FVersion: Integer;
    FModuleName: JVCSString255;
    // output
    FVersionRemoved: Boolean;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TRemoveVersionOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_Version: Integer; safecall;
    procedure Set_Version(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_VersionRemoved: WordBool; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSRemoveVersionOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property Version: Integer read FVersion write FVersion;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property VersionRemoved: Boolean read FVersionRemoved;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TRemoveVersionOutputItem read GetOutputItems;
  end;

  // MOVE_MODULE

  PMoveModuleOutputItem = ^TMoveModuleOutputItem;
  TMoveModuleOutputItem = record
    ProjectID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSMoveModule = class;

  TJVCSMoveModuleOutputItem = class(TComponent, IJVCSMoveModuleOutputItem)
  private
    FPtr: PMoveModuleOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PMoveModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSMoveModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSMoveModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FNewModulePath: JVCSString255;
    FModuleName: JVCSString255;
    // output
    FModuleMoved: Boolean;
    FErrorMessage: string;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TMoveModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_NewModulePath: WideString; safecall;
    procedure Set_NewModulePath(const Value: WideString); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_ModuleMoved: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSMoveModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property NewModulePath: JVCSString255 read FNewModulePath write FNewModulePath;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property ModuleMoved: Boolean read FModuleMoved;
    property ErrorMessage: string read FErrorMessage;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TMoveModuleOutputItem read GetOutputItems;
  end;

  // GET_CHECKOUT_MODULE

  PGetCheckoutModuleOutputItem = ^TGetCheckoutModuleOutputItem;
  TGetCheckoutModuleOutputItem = record
    ModuleOriginalTime: TDateTime;
    ModuleOriginalSize: Integer;
    ModuleOriginalCRC: Integer;
    ModuleCompressedSize: Integer;
    ModuleExtension: JVCSString20;
    ModuleBinary: TMemoryStream;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetCheckoutModule = class;

  TJVCSGetCheckoutModuleOutputItem = class(TComponent, IJVCSGetCheckoutModuleOutputItem)
  private
    FPtr: PGetCheckoutModuleOutputItem;
    FModuleBinaryStreamAdapter: TJVCSStreamAdapter;
  public
    constructor Create(AOwner: TComponent; APtr: PGetCheckoutModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleOriginalTime: TDateTime; safecall;
    function Get_ModuleOriginalSize: Integer; safecall;
    function Get_ModuleOriginalCRC: Integer; safecall;
    function Get_ModuleCompressedSize: Integer; safecall;
    function Get_ModuleExtension: WideString; safecall;
    function Get_ModuleBinary: IJVCSReadonlyStream; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetCheckoutModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetCheckoutModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FRevisionID: Integer;
    FCheckOut: Boolean;
    FModuleName: JVCSString255;
    // output
    FCheckoutAllowed: Boolean;
    FOwner: JVCSString50;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetCheckoutModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_CheckOut: WordBool; safecall;
    procedure Set_CheckOut(Value: WordBool); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_CheckoutAllowed: WordBool; safecall;
    function Get_Owner: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetCheckoutModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property CheckOut: Boolean read FCheckOut write FCheckOut;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property CheckoutAllowed: Boolean read FCheckoutAllowed;
    property Owner: JVCSString50 read FOwner;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetCheckoutModuleOutputItem read GetOutputItems;
  end;

  // CHECKOUT_ONLY_MODULE

  PCheckoutOnlyModuleOutputItem = ^TCheckoutOnlyModuleOutputItem;
  TCheckoutOnlyModuleOutputItem = record
    ModuleExtension: JVCSString20;
  end;
  {$IFDEF COMVERSION}
  TJVCSCheckoutOnlyModule = class;

  TJVCSCheckoutOnlyModuleOutputItem = class(TComponent, IJVCSCheckoutOnlyModuleOutputItem)
  private
    FPtr: PCheckoutOnlyModuleOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PCheckoutOnlyModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleExtension: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSCheckoutOnlyModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSCheckoutOnlyModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FRevisionID: Integer;
    FModuleName: JVCSString255;
    // output
    FCheckoutAllowed: Boolean;
    FOwner: JVCSString50;
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TCheckoutOnlyModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_CheckoutAllowed: WordBool; safecall;
    function Get_Owner: WideString; safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSCheckoutOnlyModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property CheckoutAllowed: Boolean read FCheckoutAllowed;
    property Owner: JVCSString50 read FOwner;
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TCheckoutOnlyModuleOutputItem read GetOutputItems;
  end;

  // UNDO_CHECKOUT_MODULE

  TJVCSUndoCheckoutModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSUndoCheckoutModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FModuleName: JVCSString255;
    // output
    FUndoCheckoutAllowed: Boolean;
    FOwner: JVCSString50;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_UndoCheckoutAllowed: WordBool; safecall;
    function Get_Owner: WideString; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    // output
    property UndoCheckoutAllowed: Boolean read FUndoCheckoutAllowed;
    property Owner: JVCSString50 read FOwner;
    property ErrorMessage: string read FErrorMessage;
  end;

  // CHECKIN_MODULE

  PCheckinModuleInputItem = ^TCheckinModuleInputItem;
  TCheckinModuleInputItem = record
    ProjectID: Integer;
    UserID: Integer;
    ModuleID: Integer;
    LabelID: Integer;
    OldRevisionID: Integer;
    ModuleVersion: Integer;
    ModuleRevision: Integer;
    ModuleOriginalTime: TDateTime;
    ModuleOriginalSize: Integer;
    ModuleOriginalCRC: Integer;
    ModuleCompressedSize: Integer;
    ModuleExtension: JVCSString20;
    ModuleBinary: TMemoryStream;
    CheckinComment: string;
    IDEVersion: Integer;
    ModuleName: JVCSString255;
    FamilyID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSCheckinModule = class;

  TJVCSCheckinModuleInputItem = class(TComponent, IJVCSCheckinModuleInputItem)
  private
    FPtr: PCheckinModuleInputItem;
    FModuleBinaryStreamAdapter: TJVCSStreamAdapter;
  public
    constructor Create(AOwner: TComponent; APtr: PCheckinModuleInputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_UserID: Integer; safecall;
    function Get_ModuleID: Integer; safecall;
    function Get_LabelID: Integer; safecall;
    function Get_OldRevisionID: Integer; safecall;
    function Get_ModuleVersion: Integer; safecall;
    function Get_ModuleRevision: Integer; safecall;
    function Get_ModuleOriginalTime: TDateTime; safecall;
    function Get_ModuleOriginalSize: Integer; safecall;
    function Get_ModuleOriginalCRC: Integer; safecall;
    function Get_ModuleCompressedSize: Integer; safecall;
    function Get_ModuleExtension: WideString; safecall;
    function Get_ModuleBinary: IJVCSReadonlyStream; safecall;
    function Get_CheckinComment: WideString; safecall;
    function Get_IDEVersion: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_FamilyID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSCheckinModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSCheckinModule {$ENDIF})
  private
    // input
    FPutOnly: Boolean;
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    // output
    FCheckinAllowed: Boolean;
    FErrorMessage: string;
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TCheckinModuleInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(AProjectID: Integer; AUserID: Integer; AModuleID: Integer; ALabelID: Integer; AOldRevisionID: Integer; AModuleVersion: Integer; AModuleRevision: Integer; AModuleOriginalTime: TDateTime; AModuleOriginalSize: Integer; AModuleOriginalCRC: Integer; AModuleCompressedSize: Integer; const AModuleExtension: string; AModuleBinary: TStream; const ACheckinComment: string; AIDEVersion: Integer; const AModuleName: string; AFamilyID: Integer): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_PutOnly: WordBool; safecall;
    procedure Set_PutOnly(Value: WordBool); safecall;
    function IJVCSCheckinModule.AddInputItem = COMAddInputItem;
    function COMAddInputItem(AProjectID: Integer; AUserID: Integer; AModuleID: Integer; ALabelID: Integer; AOldRevisionID: Integer; AModuleVersion: Integer; AModuleRevision: Integer; AModuleOriginalTime: TDateTime; AModuleOriginalSize: Integer; AModuleOriginalCRC: Integer; AModuleCompressedSize: Integer; const AModuleExtension: WideString; const AModuleBinary: IJVCSReadonlyStream; const ACheckinComment: WideString; AIDEVersion: Integer; const AModuleName: WideString; AFamilyID: Integer): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSCheckinModuleInputItem; safecall;
    function Get_CheckinAllowed: WordBool; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property PutOnly: Boolean read FPutOnly write FPutOnly;
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TCheckinModuleInputItem read GetInputItems;
    // output
    property CheckinAllowed: Boolean read FCheckinAllowed;
    property ErrorMessage: string read FErrorMessage;
  end;

  // HIDE_UNHIDE_MODULE

  TJVCSHideUnhideModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSHideUnhideModule {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FModuleID: Integer;
    FUserID: Integer;
    FHide: Boolean;
    // output
    FSuccess: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_Hide: WordBool; safecall;
    procedure Set_Hide(Value: WordBool); safecall;
    function Get_Success: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property UserID: Integer read FUserID write FUserID;
    property Hide: Boolean read FHide write FHide;
    // output
    property Success: Boolean read FSuccess;
  end;

  // COPY_REVISION

  TJVCSCopyRevision = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSCopyRevision {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FSourceRevisionID: Integer;
    FTargetVersion: Integer;
    FTargetRevision: Integer;
    FModuleName: JVCSString255;
    FIDEVersion: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_SourceRevisionID: Integer; safecall;
    procedure Set_SourceRevisionID(Value: Integer); safecall;
    function Get_TargetVersion: Integer; safecall;
    procedure Set_TargetVersion(Value: Integer); safecall;
    function Get_TargetRevision: Integer; safecall;
    procedure Set_TargetRevision(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_IDEVersion: Integer; safecall;
    procedure Set_IDEVersion(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property SourceRevisionID: Integer read FSourceRevisionID write FSourceRevisionID;
    property TargetVersion: Integer read FTargetVersion write FTargetVersion;
    property TargetRevision: Integer read FTargetRevision write FTargetRevision;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    property IDEVersion: Integer read FIDEVersion write FIDEVersion;
  end;

  // MERGE_VER_REV_NR

  TJVCSMergeVerRevNr = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSMergeVerRevNr {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FUserID: Integer;
    FModuleID: Integer;
    FSourceRevisionID: Integer;
    FTargetVersion: Integer;
    FTargetRevision: Integer;
    FModuleName: JVCSString255;
    FIDEVersion: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_SourceRevisionID: Integer; safecall;
    procedure Set_SourceRevisionID(Value: Integer); safecall;
    function Get_TargetVersion: Integer; safecall;
    procedure Set_TargetVersion(Value: Integer); safecall;
    function Get_TargetRevision: Integer; safecall;
    procedure Set_TargetRevision(Value: Integer); safecall;
    function Get_ModuleName: WideString; safecall;
    procedure Set_ModuleName(const Value: WideString); safecall;
    function Get_IDEVersion: Integer; safecall;
    procedure Set_IDEVersion(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property UserID: Integer read FUserID write FUserID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property SourceRevisionID: Integer read FSourceRevisionID write FSourceRevisionID;
    property TargetVersion: Integer read FTargetVersion write FTargetVersion;
    property TargetRevision: Integer read FTargetRevision write FTargetRevision;
    property ModuleName: JVCSString255 read FModuleName write FModuleName;
    property IDEVersion: Integer read FIDEVersion write FIDEVersion;
  end;

  // REPORT_PROJECT_STATE

  PReportProjectStateOutputItem = ^TReportProjectStateOutputItem;
  TReportProjectStateOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString250;
    ModulePath: JVCSString250;
    RevisionID: Integer;
    Version: Integer;
    Revision: Integer;
    RevisionTimestamp: TDateTime;
    RevisionExtension: JVCSString20;
    LabelID: Integer;
    ReadOnly: Boolean;
    Owner: JVCSString50;
    RevisionFileSize: Integer;
    RevisionCompressedSize: Integer;
    RevisionCRC: Integer;
    Hidden: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSReportProjectState = class;

  TJVCSReportProjectStateOutputItem = class(TComponent, IJVCSReportProjectStateOutputItem)
  private
    FPtr: PReportProjectStateOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReportProjectStateOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_ModulePath: WideString; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    function Get_RevisionTimestamp: TDateTime; safecall;
    function Get_RevisionExtension: WideString; safecall;
    function Get_LabelID: Integer; safecall;
    function Get_ReadOnly: WordBool; safecall;
    function Get_Owner: WideString; safecall;
    function Get_RevisionFileSize: Integer; safecall;
    function Get_RevisionCompressedSize: Integer; safecall;
    function Get_RevisionCRC: Integer; safecall;
    function Get_Hidden: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSReportProjectState = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSReportProjectState {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FCheckedOut: Boolean;
    FHidden: Boolean;
    FUserID: Integer;
    FLabelID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TReportProjectStateOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_CheckedOut: WordBool; safecall;
    procedure Set_CheckedOut(Value: WordBool); safecall;
    function Get_Hidden: WordBool; safecall;
    procedure Set_Hidden(Value: WordBool); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSReportProjectStateOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property CheckedOut: Boolean read FCheckedOut write FCheckedOut;
    property Hidden: Boolean read FHidden write FHidden;
    property UserID: Integer read FUserID write FUserID;
    property LabelID: Integer read FLabelID write FLabelID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TReportProjectStateOutputItem read GetOutputItems;
  end;

  // REPORT_ALL_PROJECTS

  PReportAllProjectsOutputItem = ^TReportAllProjectsOutputItem;
  TReportAllProjectsOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString50;
    CreatedTime: TDateTime;
    CreatedBy: JVCSString50;
    LastAccessedTime: TDateTime;
    LastAccessedBy: JVCSString50;
    AssignedFileCount: Integer;
    FileSizeTotal: Integer;
    CompressedSizeTotal: Integer;
    ProjectDeleted: Boolean;
    Description: string;
    AssignedModuleCount: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSReportAllProjects = class;

  TJVCSReportAllProjectsOutputItem = class(TComponent, IJVCSReportAllProjectsOutputItem)
  private
    FPtr: PReportAllProjectsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReportAllProjectsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
    function Get_CreatedTime: TDateTime; safecall;
    function Get_CreatedBy: WideString; safecall;
    function Get_LastAccessedTime: TDateTime; safecall;
    function Get_LastAccessedBy: WideString; safecall;
    function Get_AssignedFileCount: Integer; safecall;
    function Get_FileSizeTotal: Integer; safecall;
    function Get_CompressedSizeTotal: Integer; safecall;
    function Get_ProjectDeleted: WordBool; safecall;
    function Get_Description: WideString; safecall;
    function Get_AssignedModuleCount: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSReportAllProjects = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSReportAllProjects {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TReportAllProjectsOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSReportAllProjectsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TReportAllProjectsOutputItem read GetOutputItems;
  end;

  // REPORT_PROJECT_BUGS

  PReportProjectBugsOutputItem = ^TReportProjectBugsOutputItem;
  TReportProjectBugsOutputItem = record
    ItemType: JVCSString1;
    ItemID: Integer;
    ItemName: JVCSString250;
    ItemPath: JVCSString250;
    BugName: JVCSString250;
    Severity: Integer;
    Status: Integer;
    BugDescription: string;
    ReportedBy: string;
    Workaround: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSReportProjectBugs = class;

  TJVCSReportProjectBugsOutputItem = class(TComponent, IJVCSReportProjectBugsOutputItem)
  private
    FPtr: PReportProjectBugsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReportProjectBugsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ItemType: WideString; safecall;
    function Get_ItemID: Integer; safecall;
    function Get_ItemName: WideString; safecall;
    function Get_ItemPath: WideString; safecall;
    function Get_BugName: WideString; safecall;
    function Get_Severity: Integer; safecall;
    function Get_Status: Integer; safecall;
    function Get_BugDescription: WideString; safecall;
    function Get_ReportedBy: WideString; safecall;
    function Get_Workaround: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSReportProjectBugs = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSReportProjectBugs {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FBugID: Integer;
    FSeverity: Integer;
    FStatus: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TReportProjectBugsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_Severity: Integer; safecall;
    procedure Set_Severity(Value: Integer); safecall;
    function Get_Status: Integer; safecall;
    procedure Set_Status(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSReportProjectBugsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property BugID: Integer read FBugID write FBugID;
    property Severity: Integer read FSeverity write FSeverity;
    property Status: Integer read FStatus write FStatus;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TReportProjectBugsOutputItem read GetOutputItems;
  end;

  // REPORT_MILESTONES

  PReportMilestonesOutputItem = ^TReportMilestonesOutputItem;
  TReportMilestonesOutputItem = record
    ProjectID: Integer;
    ProjectName: JVCSString250;
    MilestoneLevel: Integer;
    MilestoneName: JVCSString50;
    ReachedTime: TDateTime;
    ConfirmedBy: JVCSString50;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSReportMilestones = class;

  TJVCSReportMilestonesOutputItem = class(TComponent, IJVCSReportMilestonesOutputItem)
  private
    FPtr: PReportMilestonesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PReportMilestonesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ProjectName: WideString; safecall;
    function Get_MilestoneLevel: Integer; safecall;
    function Get_MilestoneName: WideString; safecall;
    function Get_ReachedTime: TDateTime; safecall;
    function Get_ConfirmedBy: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSReportMilestones = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSReportMilestones {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TReportMilestonesOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSReportMilestonesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TReportMilestonesOutputItem read GetOutputItems;
  end;

  // GET_BUGS

  PGetBugsOutputItem = ^TGetBugsOutputItem;
  TGetBugsOutputItem = record
    BugID: Integer;
    BugName: JVCSString250;
    Keywords: JVCSString250;
    Severity: Integer;
    CreatedTime: TDateTime;
    CreatedBy: JVCSString50;
    Flags: Integer;
    Status: Integer;
    Description: string;
    ReportedBy: string;
    Workaround: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetBugs = class;

  TJVCSGetBugsOutputItem = class(TComponent, IJVCSGetBugsOutputItem)
  private
    FPtr: PGetBugsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetBugsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_BugID: Integer; safecall;
    function Get_BugName: WideString; safecall;
    function Get_Keywords: WideString; safecall;
    function Get_Severity: Integer; safecall;
    function Get_CreatedTime: TDateTime; safecall;
    function Get_CreatedBy: WideString; safecall;
    function Get_Flags: Integer; safecall;
    function Get_Status: Integer; safecall;
    function Get_Description: WideString; safecall;
    function Get_ReportedBy: WideString; safecall;
    function Get_Workaround: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetBugs = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetBugs {$ENDIF})
  private
    // input
    FIncludeDescription: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetBugsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_IncludeDescription: WordBool; safecall;
    procedure Set_IncludeDescription(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetBugsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property IncludeDescription: Boolean read FIncludeDescription write FIncludeDescription;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetBugsOutputItem read GetOutputItems;
  end;

  // GET_BUGS_BY_PROJECT

  PGetBugsByProjectOutputItem = ^TGetBugsByProjectOutputItem;
  TGetBugsByProjectOutputItem = record
    BugID: Integer;
    BugName: JVCSString250;
    Description: string;
    Severity: Integer;
    Done: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetBugsByProject = class;

  TJVCSGetBugsByProjectOutputItem = class(TComponent, IJVCSGetBugsByProjectOutputItem)
  private
    FPtr: PGetBugsByProjectOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetBugsByProjectOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_BugID: Integer; safecall;
    function Get_BugName: WideString; safecall;
    function Get_Description: WideString; safecall;
    function Get_Severity: Integer; safecall;
    function Get_Done: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetBugsByProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetBugsByProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetBugsByProjectOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetBugsByProjectOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetBugsByProjectOutputItem read GetOutputItems;
  end;

  // GET_BUGS_BY_MODULE

  PGetBugsByModuleOutputItem = ^TGetBugsByModuleOutputItem;
  TGetBugsByModuleOutputItem = record
    BugID: Integer;
    BugName: JVCSString250;
    Description: string;
    Severity: Integer;
    Done: Boolean;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetBugsByModule = class;

  TJVCSGetBugsByModuleOutputItem = class(TComponent, IJVCSGetBugsByModuleOutputItem)
  private
    FPtr: PGetBugsByModuleOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetBugsByModuleOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_BugID: Integer; safecall;
    function Get_BugName: WideString; safecall;
    function Get_Description: WideString; safecall;
    function Get_Severity: Integer; safecall;
    function Get_Done: WordBool; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetBugsByModule = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetBugsByModule {$ENDIF})
  private
    // input
    FModuleID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetBugsByModuleOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetBugsByModuleOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetBugsByModuleOutputItem read GetOutputItems;
  end;

  // GET_MOST_SEVERE_BUGS

  PGetMostSevereBugsOutputItem = ^TGetMostSevereBugsOutputItem;
  TGetMostSevereBugsOutputItem = record
    ItemID: Integer;
    BugID: Integer;
    Severity: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetMostSevereBugs = class;

  TJVCSGetMostSevereBugsOutputItem = class(TComponent, IJVCSGetMostSevereBugsOutputItem)
  private
    FPtr: PGetMostSevereBugsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetMostSevereBugsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ItemID: Integer; safecall;
    function Get_BugID: Integer; safecall;
    function Get_Severity: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetMostSevereBugs = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetMostSevereBugs {$ENDIF})
  private
    // input
    FModuleBased: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetMostSevereBugsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleBased: WordBool; safecall;
    procedure Set_ModuleBased(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetMostSevereBugsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleBased: Boolean read FModuleBased write FModuleBased;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetMostSevereBugsOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_BUG

  TJVCSAddUpdateBug = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateBug {$ENDIF})
  private
    // input
    FBugID: Integer;
    FBugName: JVCSString250;
    FSeverity: Integer;
    FFlags: Integer;
    FDescription: string;
    FKeywords: JVCSString250;
    FReportedBy: string;
    FWorkaround: string;
    FStatus: Integer;
    // output
    FNewBug: Boolean;
    FNewBugID: Integer;
    FErrorMessage: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_BugName: WideString; safecall;
    procedure Set_BugName(const Value: WideString); safecall;
    function Get_Severity: Integer; safecall;
    procedure Set_Severity(Value: Integer); safecall;
    function Get_Flags: Integer; safecall;
    procedure Set_Flags(Value: Integer); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    function Get_Keywords: WideString; safecall;
    procedure Set_Keywords(const Value: WideString); safecall;
    function Get_ReportedBy: WideString; safecall;
    procedure Set_ReportedBy(const Value: WideString); safecall;
    function Get_Workaround: WideString; safecall;
    procedure Set_Workaround(const Value: WideString); safecall;
    function Get_Status: Integer; safecall;
    procedure Set_Status(Value: Integer); safecall;
    function Get_NewBug: WordBool; safecall;
    function Get_NewBugID: Integer; safecall;
    function Get_ErrorMessage: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property BugID: Integer read FBugID write FBugID;
    property BugName: JVCSString250 read FBugName write FBugName;
    property Severity: Integer read FSeverity write FSeverity;
    property Flags: Integer read FFlags write FFlags;
    property Description: string read FDescription write FDescription;
    property Keywords: JVCSString250 read FKeywords write FKeywords;
    property ReportedBy: string read FReportedBy write FReportedBy;
    property Workaround: string read FWorkaround write FWorkaround;
    property Status: Integer read FStatus write FStatus;
    // output
    property NewBug: Boolean read FNewBug;
    property NewBugID: Integer read FNewBugID;
    property ErrorMessage: string read FErrorMessage;
  end;

  // REMOVE_BUG

  TJVCSRemoveBug = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveBug {$ENDIF})
  private
    // input
    FBugID: Integer;
    // output
    FBugRemoved: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_BugRemoved: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property BugID: Integer read FBugID write FBugID;
    // output
    property BugRemoved: Boolean read FBugRemoved;
  end;

  // ASSIGN_REMOVE_BUG

  TJVCSAssignRemoveBug = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAssignRemoveBug {$ENDIF})
  private
    // input
    FItemID: Integer;
    FBugID: Integer;
    FProjectRelated: Boolean;
    FAddBug: Boolean;
    // output
    FBugAdded: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ItemID: Integer; safecall;
    procedure Set_ItemID(Value: Integer); safecall;
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_ProjectRelated: WordBool; safecall;
    procedure Set_ProjectRelated(Value: WordBool); safecall;
    function Get_AddBug: WordBool; safecall;
    procedure Set_AddBug(Value: WordBool); safecall;
    function Get_BugAdded: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property ItemID: Integer read FItemID write FItemID;
    property BugID: Integer read FBugID write FBugID;
    property ProjectRelated: Boolean read FProjectRelated write FProjectRelated;
    property AddBug: Boolean read FAddBug write FAddBug;
    // output
    property BugAdded: Boolean read FBugAdded;
  end;

  // ENABLE_MODULE_PROJECT_BUG

  TJVCSEnableModuleProjectBug = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSEnableModuleProjectBug {$ENDIF})
  private
    // input
    FItemID: Integer;
    FBugID: Integer;
    FProjectRelated: Boolean;
    FDone: Boolean;
    // output
    FBugAdded: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ItemID: Integer; safecall;
    procedure Set_ItemID(Value: Integer); safecall;
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_ProjectRelated: WordBool; safecall;
    procedure Set_ProjectRelated(Value: WordBool); safecall;
    function Get_Done: WordBool; safecall;
    procedure Set_Done(Value: WordBool); safecall;
    function Get_BugAdded: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property ItemID: Integer read FItemID write FItemID;
    property BugID: Integer read FBugID write FBugID;
    property ProjectRelated: Boolean read FProjectRelated write FProjectRelated;
    property Done: Boolean read FDone write FDone;
    // output
    property BugAdded: Boolean read FBugAdded;
  end;

  // BUGS_USED_BY

  PBugsUsedByOutputItem = ^TBugsUsedByOutputItem;
  TBugsUsedByOutputItem = record
    ItemType: JVCSString1;
    ItemID: Integer;
    ItemName: JVCSString250;
  end;
  {$IFDEF COMVERSION}
  TJVCSBugsUsedBy = class;

  TJVCSBugsUsedByOutputItem = class(TComponent, IJVCSBugsUsedByOutputItem)
  private
    FPtr: PBugsUsedByOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PBugsUsedByOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ItemType: WideString; safecall;
    function Get_ItemID: Integer; safecall;
    function Get_ItemName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSBugsUsedBy = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSBugsUsedBy {$ENDIF})
  private
    // input
    FBugID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TBugsUsedByOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_BugID: Integer; safecall;
    procedure Set_BugID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSBugsUsedByOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property BugID: Integer read FBugID write FBugID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TBugsUsedByOutputItem read GetOutputItems;
  end;

  // GET_LABELS

  PGetLabelsOutputItem = ^TGetLabelsOutputItem;
  TGetLabelsOutputItem = record
    LabelID: Integer;
    LabelName: JVCSString255;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLabels = class;

  TJVCSGetLabelsOutputItem = class(TComponent, IJVCSGetLabelsOutputItem)
  private
    FPtr: PGetLabelsOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLabelsOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_LabelID: Integer; safecall;
    function Get_LabelName: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLabels = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLabels {$ENDIF})
  private
    // input
    FIncludeDescription: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLabelsOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_IncludeDescription: WordBool; safecall;
    procedure Set_IncludeDescription(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLabelsOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property IncludeDescription: Boolean read FIncludeDescription write FIncludeDescription;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLabelsOutputItem read GetOutputItems;
  end;

  // GET_LABELS_BY_PROJECT

  PGetLabelsByProjectOutputItem = ^TGetLabelsByProjectOutputItem;
  TGetLabelsByProjectOutputItem = record
    ModuleID: Integer;
    RevisionID: Integer;
    LabelID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLabelsByProject = class;

  TJVCSGetLabelsByProjectOutputItem = class(TComponent, IJVCSGetLabelsByProjectOutputItem)
  private
    FPtr: PGetLabelsByProjectOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLabelsByProjectOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_RevisionID: Integer; safecall;
    function Get_LabelID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLabelsByProject = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLabelsByProject {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLabelsByProjectOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLabelsByProjectOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLabelsByProjectOutputItem read GetOutputItems;
  end;

  // GET_LABELS_BY_REVISION

  PGetLabelsByRevisionOutputItem = ^TGetLabelsByRevisionOutputItem;
  TGetLabelsByRevisionOutputItem = record
    LabelID: Integer;
    LabelName: JVCSString50;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLabelsByRevision = class;

  TJVCSGetLabelsByRevisionOutputItem = class(TComponent, IJVCSGetLabelsByRevisionOutputItem)
  private
    FPtr: PGetLabelsByRevisionOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLabelsByRevisionOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_LabelID: Integer; safecall;
    function Get_LabelName: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLabelsByRevision = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLabelsByRevision {$ENDIF})
  private
    // input
    FRevisionID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLabelsByRevisionOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLabelsByRevisionOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property RevisionID: Integer read FRevisionID write FRevisionID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLabelsByRevisionOutputItem read GetOutputItems;
  end;

  // GET_FILE_FAMILIES

  PGetFileFamiliesOutputItem = ^TGetFileFamiliesOutputItem;
  TGetFileFamiliesOutputItem = record
    FamilyID: Integer;
    Name: JVCSString50;
    Parent: JVCSString10;
    Children: JVCSString255;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetFileFamilies = class;

  TJVCSGetFileFamiliesOutputItem = class(TComponent, IJVCSGetFileFamiliesOutputItem)
  private
    FPtr: PGetFileFamiliesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetFileFamiliesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_FamilyID: Integer; safecall;
    function Get_Name: WideString; safecall;
    function Get_Parent: WideString; safecall;
    function Get_Children: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetFileFamilies = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetFileFamilies {$ENDIF})
  private
    // input
    FIncludeDescription: Boolean;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetFileFamiliesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_IncludeDescription: WordBool; safecall;
    procedure Set_IncludeDescription(Value: WordBool); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetFileFamiliesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property IncludeDescription: Boolean read FIncludeDescription write FIncludeDescription;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetFileFamiliesOutputItem read GetOutputItems;
  end;

  // GET_FAMILY_EXTENSIONS

  TJVCSGetFamilyExtensions = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetFamilyExtensions {$ENDIF})
  private
    // input
    FParentExtension: JVCSString10;
    // output
    FFamilyExtensions: JVCSString255;
    FFamilyID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ParentExtension: WideString; safecall;
    procedure Set_ParentExtension(const Value: WideString); safecall;
    function Get_FamilyExtensions: WideString; safecall;
    function Get_FamilyID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ParentExtension: JVCSString10 read FParentExtension write FParentExtension;
    // output
    property FamilyExtensions: JVCSString255 read FFamilyExtensions;
    property FamilyID: Integer read FFamilyID;
  end;

  // GET_MILESTONES

  PGetMilestonesOutputItem = ^TGetMilestonesOutputItem;
  TGetMilestonesOutputItem = record
    MilestoneID: Integer;
    Milestone: Integer;
    MilestoneName: JVCSString50;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetMilestones = class;

  TJVCSGetMilestonesOutputItem = class(TComponent, IJVCSGetMilestonesOutputItem)
  private
    FPtr: PGetMilestonesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetMilestonesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_MilestoneID: Integer; safecall;
    function Get_Milestone: Integer; safecall;
    function Get_MilestoneName: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetMilestones = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetMilestones {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetMilestonesOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetMilestonesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetMilestonesOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_MILESTONES

  TJVCSAddUpdateMilestones = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateMilestones {$ENDIF})
  private
    // input
    FMilestoneID: Integer;
    FMilestone: Integer;
    FMilestoneName: JVCSString50;
    FDescription: string;
    // output
    FNewMilestone: Boolean;
    FNewMilestoneID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_MilestoneID: Integer; safecall;
    procedure Set_MilestoneID(Value: Integer); safecall;
    function Get_Milestone: Integer; safecall;
    procedure Set_Milestone(Value: Integer); safecall;
    function Get_MilestoneName: WideString; safecall;
    procedure Set_MilestoneName(const Value: WideString); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    function Get_NewMilestone: WordBool; safecall;
    function Get_NewMilestoneID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property MilestoneID: Integer read FMilestoneID write FMilestoneID;
    property Milestone: Integer read FMilestone write FMilestone;
    property MilestoneName: JVCSString50 read FMilestoneName write FMilestoneName;
    property Description: string read FDescription write FDescription;
    // output
    property NewMilestone: Boolean read FNewMilestone;
    property NewMilestoneID: Integer read FNewMilestoneID;
  end;

  // REMOVE_MILESTONE

  TJVCSRemoveMilestone = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveMilestone {$ENDIF})
  private
    // input
    FMilestoneID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_MilestoneID: Integer; safecall;
    procedure Set_MilestoneID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property MilestoneID: Integer read FMilestoneID write FMilestoneID;
  end;

  // GET_PROJECT_MILESTONES

  PGetProjectMilestonesOutputItem = ^TGetProjectMilestonesOutputItem;
  TGetProjectMilestonesOutputItem = record
    ProjectID: Integer;
    MilestoneID: Integer;
    ConfirmedBy: JVCSString50;
    ReachedTime: TDateTime;
    Description: string;
    Milestone: Integer;
    MilestoneName: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetProjectMilestones = class;

  TJVCSGetProjectMilestonesOutputItem = class(TComponent, IJVCSGetProjectMilestonesOutputItem)
  private
    FPtr: PGetProjectMilestonesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetProjectMilestonesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_MilestoneID: Integer; safecall;
    function Get_ConfirmedBy: WideString; safecall;
    function Get_ReachedTime: TDateTime; safecall;
    function Get_Description: WideString; safecall;
    function Get_Milestone: Integer; safecall;
    function Get_MilestoneName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetProjectMilestones = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetProjectMilestones {$ENDIF})
  private
    // input
    FProjectID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetProjectMilestonesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetProjectMilestonesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetProjectMilestonesOutputItem read GetOutputItems;
  end;

  // ASSIGN_PROJECT_MILESTONE

  TJVCSAssignProjectMilestone = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAssignProjectMilestone {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FMilestoneID: Integer;
    FConfirm: JVCSString50;
    FDescription: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_MilestoneID: Integer; safecall;
    procedure Set_MilestoneID(Value: Integer); safecall;
    function Get_Confirm: WideString; safecall;
    procedure Set_Confirm(const Value: WideString); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property MilestoneID: Integer read FMilestoneID write FMilestoneID;
    property Confirm: JVCSString50 read FConfirm write FConfirm;
    property Description: string read FDescription write FDescription;
  end;

  // REMOVE_PROJECT_MILESTONE

  TJVCSRemoveProjectMilestone = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveProjectMilestone {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FMilestoneID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_MilestoneID: Integer; safecall;
    procedure Set_MilestoneID(Value: Integer); safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property MilestoneID: Integer read FMilestoneID write FMilestoneID;
  end;

  // FAMILY_USED_BY

  PFamilyUsedByOutputItem = ^TFamilyUsedByOutputItem;
  TFamilyUsedByOutputItem = record
    ModuleID: Integer;
    ModuleName: JVCSString255;
  end;
  {$IFDEF COMVERSION}
  TJVCSFamilyUsedBy = class;

  TJVCSFamilyUsedByOutputItem = class(TComponent, IJVCSFamilyUsedByOutputItem)
  private
    FPtr: PFamilyUsedByOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PFamilyUsedByOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleID: Integer; safecall;
    function Get_ModuleName: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSFamilyUsedBy = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSFamilyUsedBy {$ENDIF})
  private
    // input
    FFamilyID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TFamilyUsedByOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_FamilyID: Integer; safecall;
    procedure Set_FamilyID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSFamilyUsedByOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property FamilyID: Integer read FFamilyID write FFamilyID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TFamilyUsedByOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_LABEL

  TJVCSAddUpdateLabel = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateLabel {$ENDIF})
  private
    // input
    FLabelID: Integer;
    FLabelName: JVCSString255;
    FDescription: string;
    // output
    FNewLabel: Boolean;
    FNewLabelID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_LabelName: WideString; safecall;
    procedure Set_LabelName(const Value: WideString); safecall;
    function Get_Description: WideString; safecall;
    procedure Set_Description(const Value: WideString); safecall;
    function Get_NewLabel: WordBool; safecall;
    function Get_NewLabelID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property LabelID: Integer read FLabelID write FLabelID;
    property LabelName: JVCSString255 read FLabelName write FLabelName;
    property Description: string read FDescription write FDescription;
    // output
    property NewLabel: Boolean read FNewLabel;
    property NewLabelID: Integer read FNewLabelID;
  end;

  // ADD_UPDATE_FILE_FAMILIES

  TJVCSAddUpdateFileFamilies = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateFileFamilies {$ENDIF})
  private
    // input
    FFamilyID: Integer;
    FFamilyName: JVCSString50;
    FParentExtension: JVCSString10;
    FChildExtensions: JVCSString255;
    FFamilyDescription: string;
    // output
    FNewFamily: Boolean;
    FNewFamilyID: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_FamilyID: Integer; safecall;
    procedure Set_FamilyID(Value: Integer); safecall;
    function Get_FamilyName: WideString; safecall;
    procedure Set_FamilyName(const Value: WideString); safecall;
    function Get_ParentExtension: WideString; safecall;
    procedure Set_ParentExtension(const Value: WideString); safecall;
    function Get_ChildExtensions: WideString; safecall;
    procedure Set_ChildExtensions(const Value: WideString); safecall;
    function Get_FamilyDescription: WideString; safecall;
    procedure Set_FamilyDescription(const Value: WideString); safecall;
    function Get_NewFamily: WordBool; safecall;
    function Get_NewFamilyID: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property FamilyID: Integer read FFamilyID write FFamilyID;
    property FamilyName: JVCSString50 read FFamilyName write FFamilyName;
    property ParentExtension: JVCSString10 read FParentExtension write FParentExtension;
    property ChildExtensions: JVCSString255 read FChildExtensions write FChildExtensions;
    property FamilyDescription: string read FFamilyDescription write FFamilyDescription;
    // output
    property NewFamily: Boolean read FNewFamily;
    property NewFamilyID: Integer read FNewFamilyID;
  end;

  // REMOVE_FILE_FAMILIES

  TJVCSRemoveFileFamilies = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveFileFamilies {$ENDIF})
  private
    // input
    FFamilyID: Integer;
    // output
    FFamilyDeleted: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_FamilyID: Integer; safecall;
    procedure Set_FamilyID(Value: Integer); safecall;
    function Get_FamilyDeleted: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property FamilyID: Integer read FFamilyID write FFamilyID;
    // output
    property FamilyDeleted: Boolean read FFamilyDeleted;
  end;

  // REMOVE_LABEL

  TJVCSRemoveLabel = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveLabel {$ENDIF})
  private
    // input
    FLabelID: Integer;
    // output
    FLabelRemoved: Boolean;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_LabelRemoved: WordBool; safecall;
    {$ENDIF COMVERSION}
    // input
    property LabelID: Integer read FLabelID write FLabelID;
    // output
    property LabelRemoved: Boolean read FLabelRemoved;
  end;

  // ADD_REMOVE_REVISION_LABEL

  TJVCSAddRemoveRevisionLabel = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddRemoveRevisionLabel {$ENDIF})
  private
    // input
    FModuleID: Integer;
    FRevisionID: Integer;
    FLabelID: Integer;
    FAddLabel: Boolean;
    FCheckOnly: Boolean;
    // output
    FLabelAdded: Boolean;
    FAddedRevisionID: Integer;
    FVersion: Integer;
    FRevision: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_RevisionID: Integer; safecall;
    procedure Set_RevisionID(Value: Integer); safecall;
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_AddLabel: WordBool; safecall;
    procedure Set_AddLabel(Value: WordBool); safecall;
    function Get_CheckOnly: WordBool; safecall;
    procedure Set_CheckOnly(Value: WordBool); safecall;
    function Get_LabelAdded: WordBool; safecall;
    function Get_AddedRevisionID: Integer; safecall;
    function Get_Version: Integer; safecall;
    function Get_Revision: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ModuleID: Integer read FModuleID write FModuleID;
    property RevisionID: Integer read FRevisionID write FRevisionID;
    property LabelID: Integer read FLabelID write FLabelID;
    property AddLabel: Boolean read FAddLabel write FAddLabel;
    property CheckOnly: Boolean read FCheckOnly write FCheckOnly;
    // output
    property LabelAdded: Boolean read FLabelAdded;
    property AddedRevisionID: Integer read FAddedRevisionID;
    property Version: Integer read FVersion;
    property Revision: Integer read FRevision;
  end;

  // LABEL_USED_BY

  PLabelUsedByOutputItem = ^TLabelUsedByOutputItem;
  TLabelUsedByOutputItem = record
    ModuleName: JVCSString255;
    ModuleVersion: Integer;
    ModuleRevision: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSLabelUsedBy = class;

  TJVCSLabelUsedByOutputItem = class(TComponent, IJVCSLabelUsedByOutputItem)
  private
    FPtr: PLabelUsedByOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PLabelUsedByOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ModuleName: WideString; safecall;
    function Get_ModuleVersion: Integer; safecall;
    function Get_ModuleRevision: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSLabelUsedBy = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSLabelUsedBy {$ENDIF})
  private
    // input
    FLabelID: Integer;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TLabelUsedByOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_LabelID: Integer; safecall;
    procedure Set_LabelID(Value: Integer); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSLabelUsedByOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property LabelID: Integer read FLabelID write FLabelID;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TLabelUsedByOutputItem read GetOutputItems;
  end;

  // GET_UPDATE_DESCRIPTION

  TJVCSGetUpdateDescription = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetUpdateDescription {$ENDIF})
  private
    // input
    FItemType: Integer;
    FItemID: Integer;
    FUpdate: Boolean;
    FUpdateDescription: string;
    // output
    FDescription: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ItemType: Integer; safecall;
    procedure Set_ItemType(Value: Integer); safecall;
    function Get_ItemID: Integer; safecall;
    procedure Set_ItemID(Value: Integer); safecall;
    function Get_Update: WordBool; safecall;
    procedure Set_Update(Value: WordBool); safecall;
    function Get_UpdateDescription: WideString; safecall;
    procedure Set_UpdateDescription(const Value: WideString); safecall;
    function Get_Description: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property ItemType: Integer read FItemType write FItemType;
    property ItemID: Integer read FItemID write FItemID;
    property Update: Boolean read FUpdate write FUpdate;
    property UpdateDescription: string read FUpdateDescription write FUpdateDescription;
    // output
    property Description: string read FDescription;
  end;

  // GET_TODO_FILTER

  PGetTodoFilterOutputItem = ^TGetTodoFilterOutputItem;
  TGetTodoFilterOutputItem = record
    FilterType: JVCSString1;
    ID: Integer;
    Name: JVCSString50;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetTodoFilter = class;

  TJVCSGetTodoFilterOutputItem = class(TComponent, IJVCSGetTodoFilterOutputItem)
  private
    FPtr: PGetTodoFilterOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetTodoFilterOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_FilterType: WideString; safecall;
    function Get_ID: Integer; safecall;
    function Get_Name: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetTodoFilter = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetTodoFilter {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetTodoFilterOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetTodoFilterOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetTodoFilterOutputItem read GetOutputItems;
  end;

  // ADD_UPDATE_TODO_ENTRIES

  PAddUpdateTodoEntriesInputItem = ^TAddUpdateTodoEntriesInputItem;
  TAddUpdateTodoEntriesInputItem = record
    TodoID: Integer;
    UserID: Integer;
    ProjectID: Integer;
    Responsible: Integer;
    Priority: Integer;
    State: JVCSString1;
    Category: JVCSString50;
    Description: string;
    TargetDate: TDateTime;
    DoneDate: TDateTime;
  end;
  {$IFDEF COMVERSION}
  TJVCSAddUpdateTodoEntries = class;

  TJVCSAddUpdateTodoEntriesInputItem = class(TComponent, IJVCSAddUpdateTodoEntriesInputItem)
  private
    FPtr: PAddUpdateTodoEntriesInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PAddUpdateTodoEntriesInputItem); reintroduce;
    destructor Destroy; override;
    function Get_TodoID: Integer; safecall;
    function Get_UserID: Integer; safecall;
    function Get_ProjectID: Integer; safecall;
    function Get_Responsible: Integer; safecall;
    function Get_Priority: Integer; safecall;
    function Get_State: WideString; safecall;
    function Get_Category: WideString; safecall;
    function Get_Description: WideString; safecall;
    function Get_TargetDate: TDateTime; safecall;
    function Get_DoneDate: TDateTime; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSAddUpdateTodoEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddUpdateTodoEntries {$ENDIF})
  private
    // input
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TAddUpdateTodoEntriesInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(ATodoID: Integer; AUserID: Integer; AProjectID: Integer; AResponsible: Integer; APriority: Integer; const AState: string; const ACategory: string; const ADescription: string; ATargetDate: TDateTime; ADoneDate: TDateTime): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function IJVCSAddUpdateTodoEntries.AddInputItem = COMAddInputItem;
    function COMAddInputItem(ATodoID: Integer; AUserID: Integer; AProjectID: Integer; AResponsible: Integer; APriority: Integer; const AState: WideString; const ACategory: WideString; const ADescription: WideString; ATargetDate: TDateTime; ADoneDate: TDateTime): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSAddUpdateTodoEntriesInputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TAddUpdateTodoEntriesInputItem read GetInputItems;
  end;

  // REMOVE_TODO_ENTRIES

  PRemoveTodoEntriesInputItem = ^TRemoveTodoEntriesInputItem;
  TRemoveTodoEntriesInputItem = record
    TodoID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSRemoveTodoEntries = class;

  TJVCSRemoveTodoEntriesInputItem = class(TComponent, IJVCSRemoveTodoEntriesInputItem)
  private
    FPtr: PRemoveTodoEntriesInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PRemoveTodoEntriesInputItem); reintroduce;
    destructor Destroy; override;
    function Get_TodoID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSRemoveTodoEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveTodoEntries {$ENDIF})
  private
    // input
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TRemoveTodoEntriesInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(ATodoID: Integer): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function IJVCSRemoveTodoEntries.AddInputItem = COMAddInputItem;
    function COMAddInputItem(ATodoID: Integer): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSRemoveTodoEntriesInputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TRemoveTodoEntriesInputItem read GetInputItems;
  end;

  // GET_TODO_ENTRIES

  PGetTodoEntriesOutputItem = ^TGetTodoEntriesOutputItem;
  TGetTodoEntriesOutputItem = record
    TodoID: Integer;
    Timestamp: TDateTime;
    UserName: JVCSString50;
    ProjectName: JVCSString50;
    Priority: Integer;
    State: JVCSString1;
    Category: JVCSString50;
    TargetDate: TDateTime;
    DoneDate: TDateTime;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetTodoEntries = class;

  TJVCSGetTodoEntriesOutputItem = class(TComponent, IJVCSGetTodoEntriesOutputItem)
  private
    FPtr: PGetTodoEntriesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetTodoEntriesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_TodoID: Integer; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_UserName: WideString; safecall;
    function Get_ProjectName: WideString; safecall;
    function Get_Priority: Integer; safecall;
    function Get_State: WideString; safecall;
    function Get_Category: WideString; safecall;
    function Get_TargetDate: TDateTime; safecall;
    function Get_DoneDate: TDateTime; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetTodoEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetTodoEntries {$ENDIF})
  private
    // input
    FUserID: Integer;
    FProjectID: Integer;
    FCategory: JVCSString50;
    FPriority: Integer;
    FNotDoneOnly: Boolean;
    FTargetDate: TDateTime;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetTodoEntriesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_Category: WideString; safecall;
    procedure Set_Category(const Value: WideString); safecall;
    function Get_Priority: Integer; safecall;
    procedure Set_Priority(Value: Integer); safecall;
    function Get_NotDoneOnly: WordBool; safecall;
    procedure Set_NotDoneOnly(Value: WordBool); safecall;
    function Get_TargetDate: TDateTime; safecall;
    procedure Set_TargetDate(Value: TDateTime); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetTodoEntriesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property UserID: Integer read FUserID write FUserID;
    property ProjectID: Integer read FProjectID write FProjectID;
    property Category: JVCSString50 read FCategory write FCategory;
    property Priority: Integer read FPriority write FPriority;
    property NotDoneOnly: Boolean read FNotDoneOnly write FNotDoneOnly;
    property TargetDate: TDateTime read FTargetDate write FTargetDate;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetTodoEntriesOutputItem read GetOutputItems;
  end;

  // GET_LOG_FILTER

  PGetLogFilterOutputItem = ^TGetLogFilterOutputItem;
  TGetLogFilterOutputItem = record
    FilterType: JVCSString1;
    ID: Integer;
    Name: JVCSString255;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLogFilter = class;

  TJVCSGetLogFilterOutputItem = class(TComponent, IJVCSGetLogFilterOutputItem)
  private
    FPtr: PGetLogFilterOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLogFilterOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_FilterType: WideString; safecall;
    function Get_ID: Integer; safecall;
    function Get_Name: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLogFilter = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLogFilter {$ENDIF})
  private
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLogFilterOutputItem;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLogFilterOutputItem; safecall;
    {$ENDIF COMVERSION}
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLogFilterOutputItem read GetOutputItems;
  end;

  // GET_LOG_ENTRIES

  PGetLogEntriesOutputItem = ^TGetLogEntriesOutputItem;
  TGetLogEntriesOutputItem = record
    ProjectName: JVCSString50;
    ModuleName: JVCSString50;
    UserName: JVCSString50;
    Timestamp: TDateTime;
    EntryType: JVCSString1;
    Description: string;
    ProjectID: Integer;
    ModuleID: Integer;
    LogID: Integer;
  end;
  {$IFDEF COMVERSION}
  TJVCSGetLogEntries = class;

  TJVCSGetLogEntriesOutputItem = class(TComponent, IJVCSGetLogEntriesOutputItem)
  private
    FPtr: PGetLogEntriesOutputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PGetLogEntriesOutputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectName: WideString; safecall;
    function Get_ModuleName: WideString; safecall;
    function Get_UserName: WideString; safecall;
    function Get_Timestamp: TDateTime; safecall;
    function Get_EntryType: WideString; safecall;
    function Get_Description: WideString; safecall;
    function Get_ProjectID: Integer; safecall;
    function Get_ModuleID: Integer; safecall;
    function Get_LogID: Integer; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSGetLogEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLogEntries {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FModuleID: Integer;
    FUserID: Integer;
    FStartDate: TDateTime;
    FEndDate: TDateTime;
    FEntryType: string;
    // output
    FOutputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceOutputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearOutputItems;
    function GetOutputItemCount: Integer;
    function GetOutputItems(Index: Integer): TGetLogEntriesOutputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_StartDate: TDateTime; safecall;
    procedure Set_StartDate(Value: TDateTime); safecall;
    function Get_EndDate: TDateTime; safecall;
    procedure Set_EndDate(Value: TDateTime); safecall;
    function Get_EntryType: WideString; safecall;
    procedure Set_EntryType(const Value: WideString); safecall;
    function Get_OutputItemCount: Integer; safecall;
    function Get_OutputItems(Index: Integer): IJVCSGetLogEntriesOutputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property UserID: Integer read FUserID write FUserID;
    property StartDate: TDateTime read FStartDate write FStartDate;
    property EndDate: TDateTime read FEndDate write FEndDate;
    property EntryType: string read FEntryType write FEntryType;
    // output
    property OutputItemCount: Integer read GetOutputItemCount;
    property OutputItems[Index: Integer]: TGetLogEntriesOutputItem read GetOutputItems;
  end;

  // GET_LOG_COMMENT

  TJVCSGetLogComment = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSGetLogComment {$ENDIF})
  private
    // input
    FLogID: Integer;
    // output
    FCheckinComment: string;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_LogID: Integer; safecall;
    procedure Set_LogID(Value: Integer); safecall;
    function Get_CheckinComment: WideString; safecall;
    {$ENDIF COMVERSION}
    // input
    property LogID: Integer read FLogID write FLogID;
    // output
    property CheckinComment: string read FCheckinComment;
  end;

  // REMOVE_LOG_ENTRIES

  TJVCSRemoveLogEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSRemoveLogEntries {$ENDIF})
  private
    // input
    FProjectID: Integer;
    FModuleID: Integer;
    FUserID: Integer;
    FOlderThan: TDateTime;
    // output
    FAffectedEntries: Integer;
  protected
    procedure DoExecute; override;
  public
    procedure CopyFromReference(Reference: TClientObject); override;
    procedure Initialize; override;
    procedure SetResponseFields(ResponseBuffer: TMWBuffer); override;
    {$IFDEF COMVERSION}
    function Get_ProjectID: Integer; safecall;
    procedure Set_ProjectID(Value: Integer); safecall;
    function Get_ModuleID: Integer; safecall;
    procedure Set_ModuleID(Value: Integer); safecall;
    function Get_UserID: Integer; safecall;
    procedure Set_UserID(Value: Integer); safecall;
    function Get_OlderThan: TDateTime; safecall;
    procedure Set_OlderThan(Value: TDateTime); safecall;
    function Get_AffectedEntries: Integer; safecall;
    {$ENDIF COMVERSION}
    // input
    property ProjectID: Integer read FProjectID write FProjectID;
    property ModuleID: Integer read FModuleID write FModuleID;
    property UserID: Integer read FUserID write FUserID;
    property OlderThan: TDateTime read FOlderThan write FOlderThan;
    // output
    property AffectedEntries: Integer read FAffectedEntries;
  end;

  // ADD_LOG_ENTRIES

  PAddLogEntriesInputItem = ^TAddLogEntriesInputItem;
  TAddLogEntriesInputItem = record
    ProjectID: Integer;
    ModuleID: Integer;
    UserID: Integer;
    EntryType: JVCSString1;
    Description: string;
  end;
  {$IFDEF COMVERSION}
  TJVCSAddLogEntries = class;

  TJVCSAddLogEntriesInputItem = class(TComponent, IJVCSAddLogEntriesInputItem)
  private
    FPtr: PAddLogEntriesInputItem;
  public
    constructor Create(AOwner: TComponent; APtr: PAddLogEntriesInputItem); reintroduce;
    destructor Destroy; override;
    function Get_ProjectID: Integer; safecall;
    function Get_ModuleID: Integer; safecall;
    function Get_UserID: Integer; safecall;
    function Get_EntryType: WideString; safecall;
    function Get_Description: WideString; safecall;
  end;

  {$ENDIF COMVERSION}
  TJVCSAddLogEntries = class(TJVCSCOMClientObject {$IFDEF COMVERSION}, IJVCSAddLogEntries {$ENDIF})
  private
    // input
    FInputItems: TList;
    {$IFDEF COMVERSION}
    FInterfaceInputItems: TObjectList;
    {$ENDIF COMVERSION}
    procedure ClearInputItems;
    function GetInputItemCount: Integer;
    function GetInputItems(Index: Integer): TAddLogEntriesInputItem;
  protected
    procedure DoExecute; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function AddInputItem(AProjectID: Integer; AModuleID: Integer; AUserID: Integer; const AEntryType: string; const ADescription: string): Integer;
    procedure CopyFromReference(Reference: TClientObject); override;
    {$IFDEF COMVERSION}
    function IJVCSAddLogEntries.AddInputItem = COMAddInputItem;
    function COMAddInputItem(AProjectID: Integer; AModuleID: Integer; AUserID: Integer; const AEntryType: WideString; const ADescription: WideString): Integer; safecall;
    function Get_InputItemCount: Integer; safecall;
    function Get_InputItems(Index: Integer): IJVCSAddLogEntriesInputItem; safecall;
    {$ENDIF COMVERSION}
    // input
    property InputItemCount: Integer read GetInputItemCount;
    property InputItems[Index: Integer]: TAddLogEntriesInputItem read GetInputItems;
  end;

{$IFDEF COMVERSION}
procedure GetClientObjectImplementorClasses(AClasslist: TStrings);
{$ENDIF COMVERSION}

implementation

uses
  {$IFDEF COMVERSION}
  {$IFDEF DELPHI5}
  ComObj,
  {$ENDIF DELPHI5}
  {$ENDIF COMVERSION}
  JVCSClientFunctions;

const
  BoolStrings: array[Boolean] of string = ('False', 'True');

{$IFDEF COMVERSION}
procedure GetClientObjectImplementorClasses(AClasslist: TStrings);
begin
  AClasslist.AddObject(GUIDToString(IID_IJVCSLogin), TObject(TJVCSLogin));
  AClasslist.AddObject(GUIDToString(IID_IJVCSLogout), TObject(TJVCSLogout));
  AClasslist.AddObject(GUIDToString(IID_IJVCSWhoami), TObject(TJVCSWhoami));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetServerOptions), TObject(TJVCSGetServerOptions));
  AClasslist.AddObject(GUIDToString(IID_IJVCSSetServerOptions), TObject(TJVCSSetServerOptions));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectRights), TObject(TJVCSGetProjectRights));
  AClasslist.AddObject(GUIDToString(IID_IJVCSSetProjectRights), TObject(TJVCSSetProjectRights));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetUserlist), TObject(TJVCSGetUserlist));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetUsers), TObject(TJVCSGetUsers));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateUser), TObject(TJVCSAddUpdateUser));
  AClasslist.AddObject(GUIDToString(IID_IJVCSChangePassword), TObject(TJVCSChangePassword));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveUser), TObject(TJVCSRemoveUser));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetServerTime), TObject(TJVCSGetServerTime));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetServerLog), TObject(TJVCSGetServerLog));
  AClasslist.AddObject(GUIDToString(IID_IJVCSClearServerLog), TObject(TJVCSClearServerLog));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetArchiveTstamp), TObject(TJVCSGetArchiveTstamp));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectId), TObject(TJVCSGetProjectId));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectRight), TObject(TJVCSGetProjectRight));
  AClasslist.AddObject(GUIDToString(IID_IJVCSSearchModules), TObject(TJVCSSearchModules));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetDesertedModules), TObject(TJVCSGetDesertedModules));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetSpaceByProjects), TObject(TJVCSGetSpaceByProjects));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetSpaceByModules), TObject(TJVCSGetSpaceByModules));
  AClasslist.AddObject(GUIDToString(IID_IJVCSLiveBackup), TObject(TJVCSLiveBackup));
  AClasslist.AddObject(GUIDToString(IID_IJVCSPurgeProject), TObject(TJVCSPurgeProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSReadConfigData), TObject(TJVCSReadConfigData));
  AClasslist.AddObject(GUIDToString(IID_IJVCSWriteConfigData), TObject(TJVCSWriteConfigData));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectModuleList), TObject(TJVCSGetProjectModuleList));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetBlankModuleList), TObject(TJVCSGetBlankModuleList));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetSharedBy), TObject(TJVCSGetSharedBy));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddNewProject), TObject(TJVCSAddNewProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveProject), TObject(TJVCSRemoveProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRestoreProject), TObject(TJVCSRestoreProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectReferences), TObject(TJVCSGetProjectReferences));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateProjectReferences), TObject(TJVCSAddUpdateProjectReferences));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveProjectReferences), TObject(TJVCSRemoveProjectReferences));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectInformation), TObject(TJVCSGetProjectInformation));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectList), TObject(TJVCSGetProjectList));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetVersionList), TObject(TJVCSGetVersionList));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionList), TObject(TJVCSGetRevisionList));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLatestRevisions), TObject(TJVCSGetLatestRevisions));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetVersionRevision), TObject(TJVCSGetVersionRevision));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRollbackRevisions), TObject(TJVCSGetRollbackRevisions));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLockedModules), TObject(TJVCSGetLockedModules));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRenameProject), TObject(TJVCSRenameProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateProjectGroup), TObject(TJVCSAddUpdateProjectGroup));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveProjectGroup), TObject(TJVCSRemoveProjectGroup));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectGroupInformation), TObject(TJVCSGetProjectGroupInformation));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddRemoveProjectToGroup), TObject(TJVCSAddRemoveProjectToGroup));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetModuleId), TObject(TJVCSGetModuleId));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetModuleName), TObject(TJVCSGetModuleName));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRenameModule), TObject(TJVCSRenameModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetModulesLike), TObject(TJVCSGetModulesLike));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionListByName), TObject(TJVCSGetRevisionListByName));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionListById), TObject(TJVCSGetRevisionListById));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionListByVersion), TObject(TJVCSGetRevisionListByVersion));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionStatus), TObject(TJVCSGetRevisionStatus));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetRevisionComment), TObject(TJVCSGetRevisionComment));
  AClasslist.AddObject(GUIDToString(IID_IJVCSChangeRevisionComment), TObject(TJVCSChangeRevisionComment));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetBlobStatus), TObject(TJVCSGetBlobStatus));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetModuleHistory), TObject(TJVCSGetModuleHistory));
  AClasslist.AddObject(GUIDToString(IID_IJVCSIsMemberOfProject), TObject(TJVCSIsMemberOfProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetSingleBlob), TObject(TJVCSGetSingleBlob));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetSharedModules), TObject(TJVCSGetSharedModules));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddNewModule), TObject(TJVCSAddNewModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveModule), TObject(TJVCSRemoveModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveRevision), TObject(TJVCSRemoveRevision));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveVersion), TObject(TJVCSRemoveVersion));
  AClasslist.AddObject(GUIDToString(IID_IJVCSMoveModule), TObject(TJVCSMoveModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetCheckoutModule), TObject(TJVCSGetCheckoutModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSCheckoutOnlyModule), TObject(TJVCSCheckoutOnlyModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSUndoCheckoutModule), TObject(TJVCSUndoCheckoutModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSCheckinModule), TObject(TJVCSCheckinModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSHideUnhideModule), TObject(TJVCSHideUnhideModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSCopyRevision), TObject(TJVCSCopyRevision));
  AClasslist.AddObject(GUIDToString(IID_IJVCSMergeVerRevNr), TObject(TJVCSMergeVerRevNr));
  AClasslist.AddObject(GUIDToString(IID_IJVCSReportProjectState), TObject(TJVCSReportProjectState));
  AClasslist.AddObject(GUIDToString(IID_IJVCSReportAllProjects), TObject(TJVCSReportAllProjects));
  AClasslist.AddObject(GUIDToString(IID_IJVCSReportProjectBugs), TObject(TJVCSReportProjectBugs));
  AClasslist.AddObject(GUIDToString(IID_IJVCSReportMilestones), TObject(TJVCSReportMilestones));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetBugs), TObject(TJVCSGetBugs));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetBugsByProject), TObject(TJVCSGetBugsByProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetBugsByModule), TObject(TJVCSGetBugsByModule));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetMostSevereBugs), TObject(TJVCSGetMostSevereBugs));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateBug), TObject(TJVCSAddUpdateBug));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveBug), TObject(TJVCSRemoveBug));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAssignRemoveBug), TObject(TJVCSAssignRemoveBug));
  AClasslist.AddObject(GUIDToString(IID_IJVCSEnableModuleProjectBug), TObject(TJVCSEnableModuleProjectBug));
  AClasslist.AddObject(GUIDToString(IID_IJVCSBugsUsedBy), TObject(TJVCSBugsUsedBy));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLabels), TObject(TJVCSGetLabels));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLabelsByProject), TObject(TJVCSGetLabelsByProject));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLabelsByRevision), TObject(TJVCSGetLabelsByRevision));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetFileFamilies), TObject(TJVCSGetFileFamilies));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetFamilyExtensions), TObject(TJVCSGetFamilyExtensions));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetMilestones), TObject(TJVCSGetMilestones));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateMilestones), TObject(TJVCSAddUpdateMilestones));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveMilestone), TObject(TJVCSRemoveMilestone));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetProjectMilestones), TObject(TJVCSGetProjectMilestones));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAssignProjectMilestone), TObject(TJVCSAssignProjectMilestone));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveProjectMilestone), TObject(TJVCSRemoveProjectMilestone));
  AClasslist.AddObject(GUIDToString(IID_IJVCSFamilyUsedBy), TObject(TJVCSFamilyUsedBy));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateLabel), TObject(TJVCSAddUpdateLabel));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateFileFamilies), TObject(TJVCSAddUpdateFileFamilies));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveFileFamilies), TObject(TJVCSRemoveFileFamilies));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveLabel), TObject(TJVCSRemoveLabel));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddRemoveRevisionLabel), TObject(TJVCSAddRemoveRevisionLabel));
  AClasslist.AddObject(GUIDToString(IID_IJVCSLabelUsedBy), TObject(TJVCSLabelUsedBy));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetUpdateDescription), TObject(TJVCSGetUpdateDescription));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetTodoFilter), TObject(TJVCSGetTodoFilter));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddUpdateTodoEntries), TObject(TJVCSAddUpdateTodoEntries));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveTodoEntries), TObject(TJVCSRemoveTodoEntries));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetTodoEntries), TObject(TJVCSGetTodoEntries));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLogFilter), TObject(TJVCSGetLogFilter));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLogEntries), TObject(TJVCSGetLogEntries));
  AClasslist.AddObject(GUIDToString(IID_IJVCSGetLogComment), TObject(TJVCSGetLogComment));
  AClasslist.AddObject(GUIDToString(IID_IJVCSRemoveLogEntries), TObject(TJVCSRemoveLogEntries));
  AClasslist.AddObject(GUIDToString(IID_IJVCSAddLogEntries), TObject(TJVCSAddLogEntries));
end;

function TJVCSCOMClientObject.GetClientObject: TJVCSClientObject;
begin
  Result := Self;
end;
{$ENDIF COMVERSION}

{ TJVCSLogin protected }

procedure TJVCSLogin.DoExecute;
var
  S: string;
begin
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient do
    begin
      // use local server time retrieved by GET_SERVER_TIME...
      S := fvcsCliEnCrypt2(FUserPassword, FServerTimestamp);
      // ...and GMT converted local clienttime
      //THu 17.02.2003 Request.WriteFields(True, [FUserName, S, FClientVersion, FClientTimestamp]);
      Request.WriteFields(True, [FUserName, S, FClientVersion, GetNowUTC]);
    end;
end;

{ TJVCSLogin public }

procedure TJVCSLogin.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSLogin) then
    begin
      FUserName := TJVCSLogin(Reference).FUserName;
      FUserPassword := TJVCSLogin(Reference).FUserPassword;
      FClientVersion := TJVCSLogin(Reference).FClientVersion;
      FServerTimestamp := TJVCSLogin(Reference).FServerTimestamp;
      FAccepted := TJVCSLogin(Reference).FAccepted;
      FUserID := TJVCSLogin(Reference).FUserID;
      FTransactionID := TJVCSLogin(Reference).FTransactionID;
      FLoginMessage := TJVCSLogin(Reference).FLoginMessage;
      FServerVersion := TJVCSLogin(Reference).FServerVersion;
      FServerType := TJVCSLogin(Reference).FServerType;
    end;
end;

procedure TJVCSLogin.Initialize; 
begin
  inherited Initialize;
  FAccepted := False;
  FUserID := -1;
  FTransactionID := -1;
  FLoginMessage := '';
  FServerVersion := -1;
  FServerType := '';
end;

procedure TJVCSLogin.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAccepted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FUserID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FTransactionID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FLoginMessage := ResponseBuffer.Fields[3];
      if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
        FServerVersion := StrToInt64Def(ResponseBuffer.Fields[4], -1);
      if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
        FServerType := ResponseBuffer.Fields[5];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSLogin.Get_UserName: WideString; safecall;
begin
  Result := UserName;
end;

procedure TJVCSLogin.Set_UserName(const Value: WideString); safecall;
begin
  UserName := Value;
end;

function TJVCSLogin.Get_UserPassword: WideString; safecall;
begin
  Result := UserPassword;
end;

procedure TJVCSLogin.Set_UserPassword(const Value: WideString); safecall;
begin
  UserPassword := Value;
end;

function TJVCSLogin.Get_ClientVersion: Integer; safecall;
begin
  Result := ClientVersion;
end;

procedure TJVCSLogin.Set_ClientVersion(Value: Integer); safecall;
begin
  ClientVersion := Value;
end;

function TJVCSLogin.Get_ServerTimestamp: TDateTime; safecall;
begin
  Result := ServerTimestamp;
end;

procedure TJVCSLogin.Set_ServerTimestamp(Value: TDateTime); safecall;
begin
  ServerTimestamp := Value;
end;

function TJVCSLogin.Get_Accepted: WordBool; safecall;
begin
  Result := Accepted;
end;

function TJVCSLogin.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

function TJVCSLogin.Get_TransactionID: Integer; safecall;
begin
  Result := TransactionID;
end;

function TJVCSLogin.Get_LoginMessage: WideString; safecall;
begin
  Result := LoginMessage;
end;

function TJVCSLogin.Get_ServerVersion: Integer; safecall;
begin
  Result := ServerVersion;
end;

function TJVCSLogin.Get_ServerType: WideString; safecall;
begin
  Result := ServerType;
end;

{$ENDIF COMVERSION}

{ TJVCSLogout protected }

procedure TJVCSLogout.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
    end;
end;

{ TJVCSLogout public }

procedure TJVCSLogout.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSLogout) then
    begin
      FUserID := TJVCSLogout(Reference).FUserID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSLogout.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSLogout.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSWhoami public }

procedure TJVCSWhoami.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSWhoami) then
    begin
      FUserID := TJVCSWhoami(Reference).FUserID;
      FUserName := TJVCSWhoami(Reference).FUserName;
      FAccessLevel := TJVCSWhoami(Reference).FAccessLevel;
      FAccessLabel := TJVCSWhoami(Reference).FAccessLabel;
      FLoginExpires := TJVCSWhoami(Reference).FLoginExpires;
      FLoginTime := TJVCSWhoami(Reference).FLoginTime;
      FLoginTimeout := TJVCSWhoami(Reference).FLoginTimeout;
      FStoredUserIP := TJVCSWhoami(Reference).FStoredUserIP;
      FCurrentUserIP := TJVCSWhoami(Reference).FCurrentUserIP;
      FServerLabel := TJVCSWhoami(Reference).FServerLabel;
      FDBType := TJVCSWhoami(Reference).FDBType;
      FProjectAccessLevel := TJVCSWhoami(Reference).FProjectAccessLevel;
      FProjectAccessLabel := TJVCSWhoami(Reference).FProjectAccessLabel;
      FServerGMTDiff := TJVCSWhoami(Reference).FServerGMTDiff;
    end;
end;

procedure TJVCSWhoami.Initialize; 
begin
  inherited Initialize;
  FUserID := -1;
  FUserName := '';
  FAccessLevel := -1;
  FAccessLabel := '';
  FLoginExpires := False;
  FLoginTime := 0;
  FLoginTimeout := 0;
  FStoredUserIP := '';
  FCurrentUserIP := '';
  FServerLabel := '';
  FDBType := '';
  FProjectAccessLevel := -1;
  FProjectAccessLabel := '';
  FServerGMTDiff := '';
end;

procedure TJVCSWhoami.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FUserID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FUserName := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FAccessLevel := StrToInt64Def(ResponseBuffer.Fields[2], -1);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FAccessLabel := ResponseBuffer.Fields[3];
      if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
        FLoginExpires := (StrToInt64Def(ResponseBuffer.Fields[4], 0) <> 0);
      if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
        FLoginTime := SafeStrToFloat(ResponseBuffer.Fields[5]);
      if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
        FLoginTimeout := SafeStrToFloat(ResponseBuffer.Fields[6]);
      if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
        FStoredUserIP := ResponseBuffer.Fields[7];
      if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
        FCurrentUserIP := ResponseBuffer.Fields[8];
      if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
        FServerLabel := ResponseBuffer.Fields[9];
      if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
        FDBType := ResponseBuffer.Fields[10];
      if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
        FProjectAccessLevel := StrToInt64Def(ResponseBuffer.Fields[11], -1);
      if (ResponseBuffer.FieldCount > 12) and (ResponseBuffer.FieldType[12] = mwString) then
        FProjectAccessLabel := ResponseBuffer.Fields[12];
      if (ResponseBuffer.FieldCount > 13) and (ResponseBuffer.FieldType[13] = mwString) then
        FServerGMTDiff := ResponseBuffer.Fields[13];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSWhoami.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

function TJVCSWhoami.Get_UserName: WideString; safecall;
begin
  Result := UserName;
end;

function TJVCSWhoami.Get_AccessLevel: Integer; safecall;
begin
  Result := AccessLevel;
end;

function TJVCSWhoami.Get_AccessLabel: WideString; safecall;
begin
  Result := AccessLabel;
end;

function TJVCSWhoami.Get_LoginExpires: WordBool; safecall;
begin
  Result := LoginExpires;
end;

function TJVCSWhoami.Get_LoginTime: TDateTime; safecall;
begin
  Result := LoginTime;
end;

function TJVCSWhoami.Get_LoginTimeout: TDateTime; safecall;
begin
  Result := LoginTimeout;
end;

function TJVCSWhoami.Get_StoredUserIP: WideString; safecall;
begin
  Result := StoredUserIP;
end;

function TJVCSWhoami.Get_CurrentUserIP: WideString; safecall;
begin
  Result := CurrentUserIP;
end;

function TJVCSWhoami.Get_ServerLabel: WideString; safecall;
begin
  Result := ServerLabel;
end;

function TJVCSWhoami.Get_DBType: WideString; safecall;
begin
  Result := DBType;
end;

function TJVCSWhoami.Get_ProjectAccessLevel: Integer; safecall;
begin
  Result := ProjectAccessLevel;
end;

function TJVCSWhoami.Get_ProjectAccessLabel: WideString; safecall;
begin
  Result := ProjectAccessLabel;
end;

function TJVCSWhoami.Get_ServerGMTDiff: WideString; safecall;
begin
  Result := ServerGMTDiff;
end;

{$ENDIF COMVERSION}

{ TJVCSGetServerOptions public }

procedure TJVCSGetServerOptions.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetServerOptions) then
    begin
      FConnectionTimeout := TJVCSGetServerOptions(Reference).FConnectionTimeout;
      FLoginTimeout := TJVCSGetServerOptions(Reference).FLoginTimeout;
      FCasualCheckin := TJVCSGetServerOptions(Reference).FCasualCheckin;
      FWriteVCSLog := TJVCSGetServerOptions(Reference).FWriteVCSLog;
      FCheckClientIP := TJVCSGetServerOptions(Reference).FCheckClientIP;
      FLoginExpires := TJVCSGetServerOptions(Reference).FLoginExpires;
      FWriteServerLog := TJVCSGetServerOptions(Reference).FWriteServerLog;
      FServerLogSize := TJVCSGetServerOptions(Reference).FServerLogSize;
      FLiveBackupPath := TJVCSGetServerOptions(Reference).FLiveBackupPath;
      FLastLiveBackup := TJVCSGetServerOptions(Reference).FLastLiveBackup;
      FLocalLoginNoPassword := TJVCSGetServerOptions(Reference).FLocalLoginNoPassword;
      FORBObjectCount := TJVCSGetServerOptions(Reference).FORBObjectCount;
      FAutoLoginAvailable := TJVCSGetServerOptions(Reference).FAutoLoginAvailable;
      FAutoLogin := TJVCSGetServerOptions(Reference).FAutoLogin;
      FLogAccessFaults := TJVCSGetServerOptions(Reference).FLogAccessFaults;
      FUptime := TJVCSGetServerOptions(Reference).FUptime;
      FRequestCount := TJVCSGetServerOptions(Reference).FRequestCount;
      FArchiveDrive := TJVCSGetServerOptions(Reference).FArchiveDrive;
      FArchiveDriveAvailable := TJVCSGetServerOptions(Reference).FArchiveDriveAvailable;
      FArchiveDriveTotal := TJVCSGetServerOptions(Reference).FArchiveDriveTotal;
      FCheckinCount := TJVCSGetServerOptions(Reference).FCheckinCount;
      FCheckoutCount := TJVCSGetServerOptions(Reference).FCheckoutCount;
      FNewFileCount := TJVCSGetServerOptions(Reference).FNewFileCount;
      FUserCount := TJVCSGetServerOptions(Reference).FUserCount;
      FBytesTransmitted := TJVCSGetServerOptions(Reference).FBytesTransmitted;
      FBytesReceived := TJVCSGetServerOptions(Reference).FBytesReceived;
      FGetFilesCount := TJVCSGetServerOptions(Reference).FGetFilesCount;
    end;
end;

procedure TJVCSGetServerOptions.Initialize; 
begin
  inherited Initialize;
  FConnectionTimeout := -1;
  FLoginTimeout := 0;
  FCasualCheckin := False;
  FWriteVCSLog := False;
  FCheckClientIP := False;
  FLoginExpires := False;
  FWriteServerLog := False;
  FServerLogSize := -1;
  FLiveBackupPath := '';
  FLastLiveBackup := 0;
  FLocalLoginNoPassword := False;
  FORBObjectCount := -1;
  FAutoLoginAvailable := False;
  FAutoLogin := False;
  FLogAccessFaults := False;
  FUptime := '';
  FRequestCount := -1;
  FArchiveDrive := '';
  FArchiveDriveAvailable := '';
  FArchiveDriveTotal := '';
  FCheckinCount := -1;
  FCheckoutCount := -1;
  FNewFileCount := -1;
  FUserCount := -1;
  FBytesTransmitted := '';
  FBytesReceived := '';
  FGetFilesCount := -1;
end;

procedure TJVCSGetServerOptions.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FConnectionTimeout := StrToInt64Def(ResponseBuffer.Fields[0], -1);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FLoginTimeout := SafeStrToFloat(ResponseBuffer.Fields[1]);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FCasualCheckin := (StrToInt64Def(ResponseBuffer.Fields[2], 0) <> 0);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FWriteVCSLog := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
      if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
        FCheckClientIP := (StrToInt64Def(ResponseBuffer.Fields[4], 0) <> 0);
      if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
        FLoginExpires := (StrToInt64Def(ResponseBuffer.Fields[5], 0) <> 0);
      if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
        FWriteServerLog := (StrToInt64Def(ResponseBuffer.Fields[6], 0) <> 0);
      if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
        FServerLogSize := StrToInt64Def(ResponseBuffer.Fields[7], -1);
      if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
        FLiveBackupPath := ResponseBuffer.Fields[8];
      if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
        FLastLiveBackup := SafeStrToFloat(ResponseBuffer.Fields[9]);
      if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
        FLocalLoginNoPassword := (StrToInt64Def(ResponseBuffer.Fields[10], 0) <> 0);
      if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
        FORBObjectCount := StrToInt64Def(ResponseBuffer.Fields[11], -1);
      if (ResponseBuffer.FieldCount > 12) and (ResponseBuffer.FieldType[12] = mwString) then
        FAutoLoginAvailable := (StrToInt64Def(ResponseBuffer.Fields[12], 0) <> 0);
      if (ResponseBuffer.FieldCount > 13) and (ResponseBuffer.FieldType[13] = mwString) then
        FAutoLogin := (StrToInt64Def(ResponseBuffer.Fields[13], 0) <> 0);
      if (ResponseBuffer.FieldCount > 14) and (ResponseBuffer.FieldType[14] = mwString) then
        FLogAccessFaults := (StrToInt64Def(ResponseBuffer.Fields[14], 0) <> 0);
      if (ResponseBuffer.FieldCount > 15) and (ResponseBuffer.FieldType[15] = mwString) then
        FUptime := ResponseBuffer.Fields[15];
      if (ResponseBuffer.FieldCount > 16) and (ResponseBuffer.FieldType[16] = mwString) then
        FRequestCount := StrToInt64Def(ResponseBuffer.Fields[16], -1);
      if (ResponseBuffer.FieldCount > 17) and (ResponseBuffer.FieldType[17] = mwString) then
        FArchiveDrive := ResponseBuffer.Fields[17];
      if (ResponseBuffer.FieldCount > 18) and (ResponseBuffer.FieldType[18] = mwString) then
        FArchiveDriveAvailable := ResponseBuffer.Fields[18];
      if (ResponseBuffer.FieldCount > 19) and (ResponseBuffer.FieldType[19] = mwString) then
        FArchiveDriveTotal := ResponseBuffer.Fields[19];
      if (ResponseBuffer.FieldCount > 20) and (ResponseBuffer.FieldType[20] = mwString) then
        FCheckinCount := StrToInt64Def(ResponseBuffer.Fields[20], -1);
      if (ResponseBuffer.FieldCount > 21) and (ResponseBuffer.FieldType[21] = mwString) then
        FCheckoutCount := StrToInt64Def(ResponseBuffer.Fields[21], -1);
      if (ResponseBuffer.FieldCount > 22) and (ResponseBuffer.FieldType[22] = mwString) then
        FNewFileCount := StrToInt64Def(ResponseBuffer.Fields[22], -1);
      if (ResponseBuffer.FieldCount > 23) and (ResponseBuffer.FieldType[23] = mwString) then
        FUserCount := StrToInt64Def(ResponseBuffer.Fields[23], -1);
      if (ResponseBuffer.FieldCount > 24) and (ResponseBuffer.FieldType[24] = mwString) then
        FBytesTransmitted := ResponseBuffer.Fields[24];
      if (ResponseBuffer.FieldCount > 25) and (ResponseBuffer.FieldType[25] = mwString) then
        FBytesReceived := ResponseBuffer.Fields[25];
      if (ResponseBuffer.FieldCount > 26) and (ResponseBuffer.FieldType[26] = mwString) then
        FGetFilesCount := StrToInt64Def(ResponseBuffer.Fields[26], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetServerOptions.Get_ConnectionTimeout: Integer; safecall;
begin
  Result := ConnectionTimeout;
end;

function TJVCSGetServerOptions.Get_LoginTimeout: TDateTime; safecall;
begin
  Result := LoginTimeout;
end;

function TJVCSGetServerOptions.Get_CasualCheckin: WordBool; safecall;
begin
  Result := CasualCheckin;
end;

function TJVCSGetServerOptions.Get_WriteVCSLog: WordBool; safecall;
begin
  Result := WriteVCSLog;
end;

function TJVCSGetServerOptions.Get_CheckClientIP: WordBool; safecall;
begin
  Result := CheckClientIP;
end;

function TJVCSGetServerOptions.Get_LoginExpires: WordBool; safecall;
begin
  Result := LoginExpires;
end;

function TJVCSGetServerOptions.Get_WriteServerLog: WordBool; safecall;
begin
  Result := WriteServerLog;
end;

function TJVCSGetServerOptions.Get_ServerLogSize: Integer; safecall;
begin
  Result := ServerLogSize;
end;

function TJVCSGetServerOptions.Get_LiveBackupPath: WideString; safecall;
begin
  Result := LiveBackupPath;
end;

function TJVCSGetServerOptions.Get_LastLiveBackup: TDateTime; safecall;
begin
  Result := LastLiveBackup;
end;

function TJVCSGetServerOptions.Get_LocalLoginNoPassword: WordBool; safecall;
begin
  Result := LocalLoginNoPassword;
end;

function TJVCSGetServerOptions.Get_ORBObjectCount: Integer; safecall;
begin
  Result := ORBObjectCount;
end;

function TJVCSGetServerOptions.Get_AutoLoginAvailable: WordBool; safecall;
begin
  Result := AutoLoginAvailable;
end;

function TJVCSGetServerOptions.Get_AutoLogin: WordBool; safecall;
begin
  Result := AutoLogin;
end;

function TJVCSGetServerOptions.Get_LogAccessFaults: WordBool; safecall;
begin
  Result := LogAccessFaults;
end;

function TJVCSGetServerOptions.Get_Uptime: WideString; safecall;
begin
  Result := Uptime;
end;

function TJVCSGetServerOptions.Get_RequestCount: Integer; safecall;
begin
  Result := RequestCount;
end;

function TJVCSGetServerOptions.Get_ArchiveDrive: WideString; safecall;
begin
  Result := ArchiveDrive;
end;

function TJVCSGetServerOptions.Get_ArchiveDriveAvailable: WideString; safecall;
begin
  Result := ArchiveDriveAvailable;
end;

function TJVCSGetServerOptions.Get_ArchiveDriveTotal: WideString; safecall;
begin
  Result := ArchiveDriveTotal;
end;

function TJVCSGetServerOptions.Get_CheckinCount: Integer; safecall;
begin
  Result := CheckinCount;
end;

function TJVCSGetServerOptions.Get_CheckoutCount: Integer; safecall;
begin
  Result := CheckoutCount;
end;

function TJVCSGetServerOptions.Get_NewFileCount: Integer; safecall;
begin
  Result := NewFileCount;
end;

function TJVCSGetServerOptions.Get_UserCount: Integer; safecall;
begin
  Result := UserCount;
end;

function TJVCSGetServerOptions.Get_BytesTransmitted: WideString; safecall;
begin
  Result := BytesTransmitted;
end;

function TJVCSGetServerOptions.Get_BytesReceived: WideString; safecall;
begin
  Result := BytesReceived;
end;

function TJVCSGetServerOptions.Get_GetFilesCount: Integer; safecall;
begin
  Result := GetFilesCount;
end;

{$ENDIF COMVERSION}

{ TJVCSSetServerOptions protected }

procedure TJVCSSetServerOptions.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FConnectionTimeout]);
      WriteFields(False, [FLoginTimeout]);
      WriteFields(False, [FCasualCheckin]);
      WriteFields(False, [FWriteVCSLog]);
      WriteFields(False, [FCheckClientIP]);
      WriteFields(False, [FLoginExpires]);
      WriteFields(False, [FWriteServerLog]);
      WriteFields(False, [FLiveBackupPath]);
      WriteFields(False, [FLocalLoginNoPassword]);
      WriteFields(False, [FAutoLogin]);
      WriteFields(False, [FLogAccessFaults]);
    end;
end;

{ TJVCSSetServerOptions public }

procedure TJVCSSetServerOptions.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSSetServerOptions) then
    begin
      FConnectionTimeout := TJVCSSetServerOptions(Reference).FConnectionTimeout;
      FLoginTimeout := TJVCSSetServerOptions(Reference).FLoginTimeout;
      FCasualCheckin := TJVCSSetServerOptions(Reference).FCasualCheckin;
      FWriteVCSLog := TJVCSSetServerOptions(Reference).FWriteVCSLog;
      FCheckClientIP := TJVCSSetServerOptions(Reference).FCheckClientIP;
      FLoginExpires := TJVCSSetServerOptions(Reference).FLoginExpires;
      FWriteServerLog := TJVCSSetServerOptions(Reference).FWriteServerLog;
      FLiveBackupPath := TJVCSSetServerOptions(Reference).FLiveBackupPath;
      FLocalLoginNoPassword := TJVCSSetServerOptions(Reference).FLocalLoginNoPassword;
      FAutoLogin := TJVCSSetServerOptions(Reference).FAutoLogin;
      FLogAccessFaults := TJVCSSetServerOptions(Reference).FLogAccessFaults;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSSetServerOptions.Get_ConnectionTimeout: Integer; safecall;
begin
  Result := ConnectionTimeout;
end;

procedure TJVCSSetServerOptions.Set_ConnectionTimeout(Value: Integer); safecall;
begin
  ConnectionTimeout := Value;
end;

function TJVCSSetServerOptions.Get_LoginTimeout: TDateTime; safecall;
begin
  Result := LoginTimeout;
end;

procedure TJVCSSetServerOptions.Set_LoginTimeout(Value: TDateTime); safecall;
begin
  LoginTimeout := Value;
end;

function TJVCSSetServerOptions.Get_CasualCheckin: WordBool; safecall;
begin
  Result := CasualCheckin;
end;

procedure TJVCSSetServerOptions.Set_CasualCheckin(Value: WordBool); safecall;
begin
  CasualCheckin := Value;
end;

function TJVCSSetServerOptions.Get_WriteVCSLog: WordBool; safecall;
begin
  Result := WriteVCSLog;
end;

procedure TJVCSSetServerOptions.Set_WriteVCSLog(Value: WordBool); safecall;
begin
  WriteVCSLog := Value;
end;

function TJVCSSetServerOptions.Get_CheckClientIP: WordBool; safecall;
begin
  Result := CheckClientIP;
end;

procedure TJVCSSetServerOptions.Set_CheckClientIP(Value: WordBool); safecall;
begin
  CheckClientIP := Value;
end;

function TJVCSSetServerOptions.Get_LoginExpires: WordBool; safecall;
begin
  Result := LoginExpires;
end;

procedure TJVCSSetServerOptions.Set_LoginExpires(Value: WordBool); safecall;
begin
  LoginExpires := Value;
end;

function TJVCSSetServerOptions.Get_WriteServerLog: WordBool; safecall;
begin
  Result := WriteServerLog;
end;

procedure TJVCSSetServerOptions.Set_WriteServerLog(Value: WordBool); safecall;
begin
  WriteServerLog := Value;
end;

function TJVCSSetServerOptions.Get_LiveBackupPath: WideString; safecall;
begin
  Result := LiveBackupPath;
end;

procedure TJVCSSetServerOptions.Set_LiveBackupPath(const Value: WideString); safecall;
begin
  LiveBackupPath := Value;
end;

function TJVCSSetServerOptions.Get_LocalLoginNoPassword: WordBool; safecall;
begin
  Result := LocalLoginNoPassword;
end;

procedure TJVCSSetServerOptions.Set_LocalLoginNoPassword(Value: WordBool); safecall;
begin
  LocalLoginNoPassword := Value;
end;

function TJVCSSetServerOptions.Get_AutoLogin: WordBool; safecall;
begin
  Result := AutoLogin;
end;

procedure TJVCSSetServerOptions.Set_AutoLogin(Value: WordBool); safecall;
begin
  AutoLogin := Value;
end;

function TJVCSSetServerOptions.Get_LogAccessFaults: WordBool; safecall;
begin
  Result := LogAccessFaults;
end;

procedure TJVCSSetServerOptions.Set_LogAccessFaults(Value: WordBool); safecall;
begin
  LogAccessFaults := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectRights private }

procedure TJVCSGetProjectRights.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetProjectRights.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectRights.GetOutputItems(Index: Integer): TGetProjectRightsOutputItem;
begin
  Result := PGetProjectRightsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectRights public }

constructor TJVCSGetProjectRights.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectRights.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectRights.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectRights) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectRights(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectRightsOutputItem));
        try
          with PGetProjectRightsOutputItem(P)^ do
          begin
            UserID := TJVCSGetProjectRights(Reference).OutputItems[I].UserID;
            ProjectID := TJVCSGetProjectRights(Reference).OutputItems[I].ProjectID;
            AccessLevel := TJVCSGetProjectRights(Reference).OutputItems[I].AccessLevel;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectRightsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectRights.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectRights.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectRightsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectRightsOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectRightsOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectRightsOutputItem(P)^.AccessLevel := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectRightsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectRightsOutputItem.Create(AOwner: TComponent; APtr: PGetProjectRightsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectRightsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectRightsOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetProjectRightsOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetProjectRightsOutputItem.Get_AccessLevel: Integer; safecall;
begin
  Result := FPtr^.AccessLevel;
end;

function TJVCSGetProjectRights.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectRights.Get_OutputItems(Index: Integer): IJVCSGetProjectRightsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectRightsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSSetProjectRights protected }

procedure TJVCSSetProjectRights.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FProjectID]);
      WriteFields(False, [FAccessLevel]);
    end;
end;

{ TJVCSSetProjectRights public }

procedure TJVCSSetProjectRights.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSSetProjectRights) then
    begin
      FUserID := TJVCSSetProjectRights(Reference).FUserID;
      FProjectID := TJVCSSetProjectRights(Reference).FProjectID;
      FAccessLevel := TJVCSSetProjectRights(Reference).FAccessLevel;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSSetProjectRights.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSSetProjectRights.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSSetProjectRights.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSSetProjectRights.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSSetProjectRights.Get_AccessLevel: Integer; safecall;
begin
  Result := AccessLevel;
end;

procedure TJVCSSetProjectRights.Set_AccessLevel(Value: Integer); safecall;
begin
  AccessLevel := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetUserlist private }

procedure TJVCSGetUserlist.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetUserlistOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetUserlist.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetUserlist.GetOutputItems(Index: Integer): TGetUserlistOutputItem;
begin
  Result := PGetUserlistOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetUserlist public }

constructor TJVCSGetUserlist.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetUserlist.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetUserlist.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetUserlist) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetUserlist(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetUserlistOutputItem));
        try
          with PGetUserlistOutputItem(P)^ do
          begin
            UserID := TJVCSGetUserlist(Reference).OutputItems[I].UserID;
            UserName := TJVCSGetUserlist(Reference).OutputItems[I].UserName;
            UserAccessLevel := TJVCSGetUserlist(Reference).OutputItems[I].UserAccessLevel;
            UserAccessID := TJVCSGetUserlist(Reference).OutputItems[I].UserAccessID;
            UserDeleted := TJVCSGetUserlist(Reference).OutputItems[I].UserDeleted;
            UserDescription := TJVCSGetUserlist(Reference).OutputItems[I].UserDescription;
            UserIP := TJVCSGetUserlist(Reference).OutputItems[I].UserIP;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetUserlistOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetUserlist.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetUserlist.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetUserlistOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetUserlistOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetUserlistOutputItem(P)^.UserName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetUserlistOutputItem(P)^.UserAccessLevel := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetUserlistOutputItem(P)^.UserAccessID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetUserlistOutputItem(P)^.UserDeleted := (StrToInt64Def(ResponseBuffer.Fields[4], 0) <> 0);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetUserlistOutputItem(P)^.UserDescription := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetUserlistOutputItem(P)^.UserIP := ResponseBuffer.Fields[6];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetUserlistOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetUserlistOutputItem.Create(AOwner: TComponent; APtr: PGetUserlistOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetUserlistOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetUserlistOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetUserlistOutputItem.Get_UserName: WideString; safecall;
begin
  Result := FPtr^.UserName;
end;

function TJVCSGetUserlistOutputItem.Get_UserAccessLevel: Integer; safecall;
begin
  Result := FPtr^.UserAccessLevel;
end;

function TJVCSGetUserlistOutputItem.Get_UserAccessID: Integer; safecall;
begin
  Result := FPtr^.UserAccessID;
end;

function TJVCSGetUserlistOutputItem.Get_UserDeleted: WordBool; safecall;
begin
  Result := FPtr^.UserDeleted;
end;

function TJVCSGetUserlistOutputItem.Get_UserDescription: WideString; safecall;
begin
  Result := FPtr^.UserDescription;
end;

function TJVCSGetUserlistOutputItem.Get_UserIP: WideString; safecall;
begin
  Result := FPtr^.UserIP;
end;

function TJVCSGetUserlist.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetUserlist.Get_OutputItems(Index: Integer): IJVCSGetUserlistOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetUserlistOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetUsers private }

procedure TJVCSGetUsers.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetUsers.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetUsers.GetOutputItems(Index: Integer): TGetUsersOutputItem;
begin
  Result := PGetUsersOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetUsers public }

constructor TJVCSGetUsers.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetUsers.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetUsers.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetUsers) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetUsers(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetUsersOutputItem));
        try
          with PGetUsersOutputItem(P)^ do
          begin
            UserID := TJVCSGetUsers(Reference).OutputItems[I].UserID;
            UserName := TJVCSGetUsers(Reference).OutputItems[I].UserName;
            UserAcessLevel := TJVCSGetUsers(Reference).OutputItems[I].UserAcessLevel;
            UserDeleted := TJVCSGetUsers(Reference).OutputItems[I].UserDeleted;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetUsersOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetUsers.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetUsers.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetUsersOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetUsersOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetUsersOutputItem(P)^.UserName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetUsersOutputItem(P)^.UserAcessLevel := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetUsersOutputItem(P)^.UserDeleted := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetUsersOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetUsersOutputItem.Create(AOwner: TComponent; APtr: PGetUsersOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetUsersOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetUsersOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetUsersOutputItem.Get_UserName: WideString; safecall;
begin
  Result := FPtr^.UserName;
end;

function TJVCSGetUsersOutputItem.Get_UserAcessLevel: Integer; safecall;
begin
  Result := FPtr^.UserAcessLevel;
end;

function TJVCSGetUsersOutputItem.Get_UserDeleted: WordBool; safecall;
begin
  Result := FPtr^.UserDeleted;
end;

function TJVCSGetUsers.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetUsers.Get_OutputItems(Index: Integer): IJVCSGetUsersOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetUsersOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateUser protected }

procedure TJVCSAddUpdateUser.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FUserName]);
      WriteFields(False, [FUserPassword]);
      WriteFields(False, [FUserAccessLevel]);
      WriteFields(False, [FUserDescription]);
      WriteFields(False, [FUserIP]);
    end;
end;

{ TJVCSAddUpdateUser public }

procedure TJVCSAddUpdateUser.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateUser) then
    begin
      FUserID := TJVCSAddUpdateUser(Reference).FUserID;
      FUserName := TJVCSAddUpdateUser(Reference).FUserName;
      FUserPassword := TJVCSAddUpdateUser(Reference).FUserPassword;
      FUserAccessLevel := TJVCSAddUpdateUser(Reference).FUserAccessLevel;
      FUserDescription := TJVCSAddUpdateUser(Reference).FUserDescription;
      FUserIP := TJVCSAddUpdateUser(Reference).FUserIP;
      FAccepted := TJVCSAddUpdateUser(Reference).FAccepted;
      FErrorMessage := TJVCSAddUpdateUser(Reference).FErrorMessage;
      FNewUserID := TJVCSAddUpdateUser(Reference).FNewUserID;
    end;
end;

procedure TJVCSAddUpdateUser.Initialize; 
begin
  inherited Initialize;
  FAccepted := False;
  FErrorMessage := '';
  FNewUserID := -1;
end;

procedure TJVCSAddUpdateUser.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAccepted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FNewUserID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateUser.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSAddUpdateUser.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSAddUpdateUser.Get_UserName: WideString; safecall;
begin
  Result := UserName;
end;

procedure TJVCSAddUpdateUser.Set_UserName(const Value: WideString); safecall;
begin
  UserName := Value;
end;

function TJVCSAddUpdateUser.Get_UserPassword: WideString; safecall;
begin
  Result := UserPassword;
end;

procedure TJVCSAddUpdateUser.Set_UserPassword(const Value: WideString); safecall;
begin
  UserPassword := Value;
end;

function TJVCSAddUpdateUser.Get_UserAccessLevel: Integer; safecall;
begin
  Result := UserAccessLevel;
end;

procedure TJVCSAddUpdateUser.Set_UserAccessLevel(Value: Integer); safecall;
begin
  UserAccessLevel := Value;
end;

function TJVCSAddUpdateUser.Get_UserDescription: WideString; safecall;
begin
  Result := UserDescription;
end;

procedure TJVCSAddUpdateUser.Set_UserDescription(const Value: WideString); safecall;
begin
  UserDescription := Value;
end;

function TJVCSAddUpdateUser.Get_UserIP: WideString; safecall;
begin
  Result := UserIP;
end;

procedure TJVCSAddUpdateUser.Set_UserIP(const Value: WideString); safecall;
begin
  UserIP := Value;
end;

function TJVCSAddUpdateUser.Get_Accepted: WordBool; safecall;
begin
  Result := Accepted;
end;

function TJVCSAddUpdateUser.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

function TJVCSAddUpdateUser.Get_NewUserID: Integer; safecall;
begin
  Result := NewUserID;
end;

{$ENDIF COMVERSION}

{ TJVCSChangePassword protected }

procedure TJVCSChangePassword.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FOldPassword]);
      WriteFields(False, [FNewPassword]);
    end;
end;

{ TJVCSChangePassword public }

procedure TJVCSChangePassword.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSChangePassword) then
    begin
      FUserID := TJVCSChangePassword(Reference).FUserID;
      FOldPassword := TJVCSChangePassword(Reference).FOldPassword;
      FNewPassword := TJVCSChangePassword(Reference).FNewPassword;
      FAccepted := TJVCSChangePassword(Reference).FAccepted;
      FErrorMessage := TJVCSChangePassword(Reference).FErrorMessage;
    end;
end;

procedure TJVCSChangePassword.Initialize; 
begin
  inherited Initialize;
  FAccepted := False;
  FErrorMessage := '';
end;

procedure TJVCSChangePassword.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAccepted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSChangePassword.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSChangePassword.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSChangePassword.Get_OldPassword: WideString; safecall;
begin
  Result := OldPassword;
end;

procedure TJVCSChangePassword.Set_OldPassword(const Value: WideString); safecall;
begin
  OldPassword := Value;
end;

function TJVCSChangePassword.Get_NewPassword: WideString; safecall;
begin
  Result := NewPassword;
end;

procedure TJVCSChangePassword.Set_NewPassword(const Value: WideString); safecall;
begin
  NewPassword := Value;
end;

function TJVCSChangePassword.Get_Accepted: WordBool; safecall;
begin
  Result := Accepted;
end;

function TJVCSChangePassword.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveUser protected }

procedure TJVCSRemoveUser.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
    end;
end;

{ TJVCSRemoveUser public }

procedure TJVCSRemoveUser.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveUser) then
    begin
      FUserID := TJVCSRemoveUser(Reference).FUserID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveUser.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRemoveUser.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetServerTime public }

procedure TJVCSGetServerTime.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetServerTime) then
    begin
      FServerTime := TJVCSGetServerTime(Reference).FServerTime;
      FLocalGMTDiff := TJVCSGetServerTime(Reference).FLocalGMTDiff;
    end;
end;

procedure TJVCSGetServerTime.Initialize; 
begin
  inherited Initialize;
  FServerTime := 0;
  FLocalGMTDiff := -1;
end;

procedure TJVCSGetServerTime.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FServerTime := SafeStrToFloat(ResponseBuffer.Fields[0]);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FLocalGMTDiff := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetServerTime.Get_ServerTime: TDateTime; safecall;
begin
  Result := ServerTime;
end;

function TJVCSGetServerTime.Get_LocalGMTDiff: Integer; safecall;
begin
  Result := LocalGMTDiff;
end;

{$ENDIF COMVERSION}

{ TJVCSGetServerLog public }

constructor TJVCSGetServerLog.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FServerLogFile := TMemoryStream.Create;
  {$IFDEF COMVERSION}
  FServerLogFileStreamAdapter := TJVCSStreamAdapter.Create(Self, FServerLogFile);
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetServerLog.Destroy;
begin
  {$IFDEF COMVERSION}
  FServerLogFileStreamAdapter.Free;
  {$ENDIF COMVERSION}
  FServerLogFile.Free;
  inherited Destroy;
end;

procedure TJVCSGetServerLog.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetServerLog) then
    begin
      FFileFound := TJVCSGetServerLog(Reference).FFileFound;
      FServerLogFile.Clear;
      FServerLogFile.CopyFrom(TJVCSGetServerLog(Reference).FServerLogFile, 0);
      FServerLogFile.Seek(0, soFromBeginning);
    end;
end;

procedure TJVCSGetServerLog.Initialize; 
begin
  inherited Initialize;
  FFileFound := False;
  FServerLogFile.Clear;
end;

procedure TJVCSGetServerLog.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  FieldType: TMWFieldType;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FFileFound := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwBlob) then
      begin
        FieldType := mwBlob;
        FServerLogFile.Clear;
        ResponseBuffer.GetStreamField(1, FServerLogFile, FieldType);
        FServerLogFile.Seek(0, soFromBeginning);
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetServerLog.Get_FileFound: WordBool; safecall;
begin
  Result := FileFound;
end;

function TJVCSGetServerLog.Get_ServerLogFile: IJVCSReadonlyStream; safecall;
begin
  Result := FServerLogFileStreamAdapter;
end;

{$ENDIF COMVERSION}

{$IFDEF COMVERSION}
{$ENDIF COMVERSION}

{ TJVCSGetArchiveTstamp public }

procedure TJVCSGetArchiveTstamp.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetArchiveTstamp) then
    begin
      FTimestamp := TJVCSGetArchiveTstamp(Reference).FTimestamp;
    end;
end;

procedure TJVCSGetArchiveTstamp.Initialize; 
begin
  inherited Initialize;
  FTimestamp := 0;
end;

procedure TJVCSGetArchiveTstamp.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FTimestamp := SafeStrToFloat(ResponseBuffer.Fields[0]);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetArchiveTstamp.Get_Timestamp: TDateTime; safecall;
begin
  Result := Timestamp;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectId protected }

procedure TJVCSGetProjectId.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectName]);
    end;
end;

{ TJVCSGetProjectId public }

procedure TJVCSGetProjectId.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectId) then
    begin
      FProjectName := TJVCSGetProjectId(Reference).FProjectName;
      FProjectID := TJVCSGetProjectId(Reference).FProjectID;
      FProjectDeleted := TJVCSGetProjectId(Reference).FProjectDeleted;
      FTransactionID := TJVCSGetProjectId(Reference).FTransactionID;
      FAccessLevel := TJVCSGetProjectId(Reference).FAccessLevel;
    end;
end;

procedure TJVCSGetProjectId.Initialize; 
begin
  inherited Initialize;
  FProjectID := -1;
  FProjectDeleted := False;
  FTransactionID := -1;
  FAccessLevel := -1;
end;

procedure TJVCSGetProjectId.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FProjectDeleted := (StrToInt64Def(ResponseBuffer.Fields[1], 0) <> 0);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FTransactionID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FAccessLevel := StrToInt64Def(ResponseBuffer.Fields[3], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetProjectId.Get_ProjectName: WideString; safecall;
begin
  Result := ProjectName;
end;

procedure TJVCSGetProjectId.Set_ProjectName(const Value: WideString); safecall;
begin
  ProjectName := Value;
end;

function TJVCSGetProjectId.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

function TJVCSGetProjectId.Get_ProjectDeleted: WordBool; safecall;
begin
  Result := ProjectDeleted;
end;

function TJVCSGetProjectId.Get_TransactionID: Integer; safecall;
begin
  Result := TransactionID;
end;

function TJVCSGetProjectId.Get_AccessLevel: Integer; safecall;
begin
  Result := AccessLevel;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectRight protected }

procedure TJVCSGetProjectRight.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetProjectRight public }

procedure TJVCSGetProjectRight.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectRight) then
    begin
      FProjectID := TJVCSGetProjectRight(Reference).FProjectID;
      FProjectRight := TJVCSGetProjectRight(Reference).FProjectRight;
    end;
end;

procedure TJVCSGetProjectRight.Initialize; 
begin
  inherited Initialize;
  FProjectRight := -1;
end;

procedure TJVCSGetProjectRight.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FProjectRight := StrToInt64Def(ResponseBuffer.Fields[0], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetProjectRight.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetProjectRight.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetProjectRight.Get_ProjectRight: Integer; safecall;
begin
  Result := ProjectRight;
end;

{$ENDIF COMVERSION}

{ TJVCSSearchModules private }

procedure TJVCSSearchModules.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSSearchModules.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSSearchModules.GetOutputItems(Index: Integer): TSearchModulesOutputItem;
begin
  Result := PSearchModulesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSSearchModules protected }

procedure TJVCSSearchModules.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FMaskString]);
    end;
end;

{ TJVCSSearchModules public }

constructor TJVCSSearchModules.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSSearchModules.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSSearchModules.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSSearchModules) then
    begin
      FMaskString := TJVCSSearchModules(Reference).FMaskString;
      ClearOutputItems;
      for I := 0 to TJVCSSearchModules(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TSearchModulesOutputItem));
        try
          with PSearchModulesOutputItem(P)^ do
          begin
            ModuleID := TJVCSSearchModules(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSSearchModules(Reference).OutputItems[I].ModuleName;
            Path := TJVCSSearchModules(Reference).OutputItems[I].Path;
            AssignedToProject := TJVCSSearchModules(Reference).OutputItems[I].AssignedToProject;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSSearchModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSSearchModules.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSSearchModules.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TSearchModulesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PSearchModulesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PSearchModulesOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PSearchModulesOutputItem(P)^.Path := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PSearchModulesOutputItem(P)^.AssignedToProject := ResponseBuffer.Fields[3];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSSearchModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSSearchModulesOutputItem.Create(AOwner: TComponent; APtr: PSearchModulesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSSearchModulesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSSearchModulesOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSSearchModulesOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSSearchModulesOutputItem.Get_Path: WideString; safecall;
begin
  Result := FPtr^.Path;
end;

function TJVCSSearchModulesOutputItem.Get_AssignedToProject: WideString; safecall;
begin
  Result := FPtr^.AssignedToProject;
end;

function TJVCSSearchModules.Get_MaskString: WideString; safecall;
begin
  Result := MaskString;
end;

procedure TJVCSSearchModules.Set_MaskString(const Value: WideString); safecall;
begin
  MaskString := Value;
end;

function TJVCSSearchModules.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSSearchModules.Get_OutputItems(Index: Integer): IJVCSSearchModulesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSSearchModulesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetDesertedModules private }

procedure TJVCSGetDesertedModules.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetDesertedModules.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetDesertedModules.GetOutputItems(Index: Integer): TGetDesertedModulesOutputItem;
begin
  Result := PGetDesertedModulesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetDesertedModules public }

constructor TJVCSGetDesertedModules.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetDesertedModules.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetDesertedModules.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetDesertedModules) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetDesertedModules(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetDesertedModulesOutputItem));
        try
          with PGetDesertedModulesOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetDesertedModules(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetDesertedModules(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetDesertedModules(Reference).OutputItems[I].ModulePath;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetDesertedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetDesertedModules.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetDesertedModules.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetDesertedModulesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetDesertedModulesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetDesertedModulesOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetDesertedModulesOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetDesertedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetDesertedModulesOutputItem.Create(AOwner: TComponent; APtr: PGetDesertedModulesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetDesertedModulesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetDesertedModulesOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetDesertedModulesOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetDesertedModulesOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetDesertedModules.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetDesertedModules.Get_OutputItems(Index: Integer): IJVCSGetDesertedModulesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetDesertedModulesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetSpaceByProjects private }

procedure TJVCSGetSpaceByProjects.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetSpaceByProjects.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetSpaceByProjects.GetOutputItems(Index: Integer): TGetSpaceByProjectsOutputItem;
begin
  Result := PGetSpaceByProjectsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetSpaceByProjects public }

constructor TJVCSGetSpaceByProjects.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetSpaceByProjects.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetSpaceByProjects.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSpaceByProjects) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetSpaceByProjects(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetSpaceByProjectsOutputItem));
        try
          with PGetSpaceByProjectsOutputItem(P)^ do
          begin
            ProjectName := TJVCSGetSpaceByProjects(Reference).OutputItems[I].ProjectName;
            RevisionCount := TJVCSGetSpaceByProjects(Reference).OutputItems[I].RevisionCount;
            ModuleSizeTotal := TJVCSGetSpaceByProjects(Reference).OutputItems[I].ModuleSizeTotal;
            CompressedSizeTotal := TJVCSGetSpaceByProjects(Reference).OutputItems[I].CompressedSizeTotal;
            LastAccessed := TJVCSGetSpaceByProjects(Reference).OutputItems[I].LastAccessed;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSpaceByProjectsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetSpaceByProjects.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetSpaceByProjects.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetSpaceByProjectsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetSpaceByProjectsOutputItem(P)^.ProjectName := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetSpaceByProjectsOutputItem(P)^.RevisionCount := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetSpaceByProjectsOutputItem(P)^.ModuleSizeTotal := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetSpaceByProjectsOutputItem(P)^.CompressedSizeTotal := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetSpaceByProjectsOutputItem(P)^.LastAccessed := SafeStrToFloat(ResponseBuffer.Fields[4]);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSpaceByProjectsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetSpaceByProjectsOutputItem.Create(AOwner: TComponent; APtr: PGetSpaceByProjectsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetSpaceByProjectsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetSpaceByProjectsOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetSpaceByProjectsOutputItem.Get_RevisionCount: Integer; safecall;
begin
  Result := FPtr^.RevisionCount;
end;

function TJVCSGetSpaceByProjectsOutputItem.Get_ModuleSizeTotal: Integer; safecall;
begin
  Result := FPtr^.ModuleSizeTotal;
end;

function TJVCSGetSpaceByProjectsOutputItem.Get_CompressedSizeTotal: Integer; safecall;
begin
  Result := FPtr^.CompressedSizeTotal;
end;

function TJVCSGetSpaceByProjectsOutputItem.Get_LastAccessed: TDateTime; safecall;
begin
  Result := FPtr^.LastAccessed;
end;

function TJVCSGetSpaceByProjects.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetSpaceByProjects.Get_OutputItems(Index: Integer): IJVCSGetSpaceByProjectsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetSpaceByProjectsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetSpaceByModules private }

procedure TJVCSGetSpaceByModules.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetSpaceByModules.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetSpaceByModules.GetOutputItems(Index: Integer): TGetSpaceByModulesOutputItem;
begin
  Result := PGetSpaceByModulesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetSpaceByModules protected }

procedure TJVCSGetSpaceByModules.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetSpaceByModules public }

constructor TJVCSGetSpaceByModules.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetSpaceByModules.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetSpaceByModules.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSpaceByModules) then
    begin
      FProjectID := TJVCSGetSpaceByModules(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetSpaceByModules(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetSpaceByModulesOutputItem));
        try
          with PGetSpaceByModulesOutputItem(P)^ do
          begin
            ModuleName := TJVCSGetSpaceByModules(Reference).OutputItems[I].ModuleName;
            RevisionCount := TJVCSGetSpaceByModules(Reference).OutputItems[I].RevisionCount;
            ModuleSizeTotal := TJVCSGetSpaceByModules(Reference).OutputItems[I].ModuleSizeTotal;
            CompressedSizeTotal := TJVCSGetSpaceByModules(Reference).OutputItems[I].CompressedSizeTotal;
            LastAccessed := TJVCSGetSpaceByModules(Reference).OutputItems[I].LastAccessed;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSpaceByModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetSpaceByModules.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetSpaceByModules.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetSpaceByModulesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetSpaceByModulesOutputItem(P)^.ModuleName := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetSpaceByModulesOutputItem(P)^.RevisionCount := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetSpaceByModulesOutputItem(P)^.ModuleSizeTotal := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetSpaceByModulesOutputItem(P)^.CompressedSizeTotal := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetSpaceByModulesOutputItem(P)^.LastAccessed := SafeStrToFloat(ResponseBuffer.Fields[4]);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSpaceByModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetSpaceByModulesOutputItem.Create(AOwner: TComponent; APtr: PGetSpaceByModulesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetSpaceByModulesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetSpaceByModulesOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetSpaceByModulesOutputItem.Get_RevisionCount: Integer; safecall;
begin
  Result := FPtr^.RevisionCount;
end;

function TJVCSGetSpaceByModulesOutputItem.Get_ModuleSizeTotal: Integer; safecall;
begin
  Result := FPtr^.ModuleSizeTotal;
end;

function TJVCSGetSpaceByModulesOutputItem.Get_CompressedSizeTotal: Integer; safecall;
begin
  Result := FPtr^.CompressedSizeTotal;
end;

function TJVCSGetSpaceByModulesOutputItem.Get_LastAccessed: TDateTime; safecall;
begin
  Result := FPtr^.LastAccessed;
end;

function TJVCSGetSpaceByModules.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetSpaceByModules.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetSpaceByModules.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetSpaceByModules.Get_OutputItems(Index: Integer): IJVCSGetSpaceByModulesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetSpaceByModulesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSLiveBackup private }

procedure TJVCSLiveBackup.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PLiveBackupOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSLiveBackup.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSLiveBackup.GetOutputItems(Index: Integer): TLiveBackupOutputItem;
begin
  Result := PLiveBackupOutputItem(FOutputItems[Index])^;
end;

{ TJVCSLiveBackup protected }

procedure TJVCSLiveBackup.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FTargetFolder]);
    end;
end;

{ TJVCSLiveBackup public }

constructor TJVCSLiveBackup.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSLiveBackup.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSLiveBackup.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSLiveBackup) then
    begin
      FTargetFolder := TJVCSLiveBackup(Reference).FTargetFolder;
      FBackupSuccess := TJVCSLiveBackup(Reference).FBackupSuccess;
      FErrorMessage := TJVCSLiveBackup(Reference).FErrorMessage;
      ClearOutputItems;
      for I := 0 to TJVCSLiveBackup(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TLiveBackupOutputItem));
        try
          with PLiveBackupOutputItem(P)^ do
          begin
            TableName := TJVCSLiveBackup(Reference).OutputItems[I].TableName;
            TableSize := TJVCSLiveBackup(Reference).OutputItems[I].TableSize;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSLiveBackupOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSLiveBackup.Initialize; 
begin
  inherited Initialize;
  FBackupSuccess := False;
  FErrorMessage := '';
  ClearOutputItems;
end;

procedure TJVCSLiveBackup.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FBackupSuccess := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TLiveBackupOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PLiveBackupOutputItem(P)^.TableName := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PLiveBackupOutputItem(P)^.TableSize := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSLiveBackupOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSLiveBackupOutputItem.Create(AOwner: TComponent; APtr: PLiveBackupOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSLiveBackupOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSLiveBackupOutputItem.Get_TableName: WideString; safecall;
begin
  Result := FPtr^.TableName;
end;

function TJVCSLiveBackupOutputItem.Get_TableSize: Integer; safecall;
begin
  Result := FPtr^.TableSize;
end;

function TJVCSLiveBackup.Get_TargetFolder: WideString; safecall;
begin
  Result := TargetFolder;
end;

procedure TJVCSLiveBackup.Set_TargetFolder(const Value: WideString); safecall;
begin
  TargetFolder := Value;
end;

function TJVCSLiveBackup.Get_BackupSuccess: WordBool; safecall;
begin
  Result := BackupSuccess;
end;

function TJVCSLiveBackup.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

function TJVCSLiveBackup.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSLiveBackup.Get_OutputItems(Index: Integer): IJVCSLiveBackupOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSLiveBackupOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSPurgeProject protected }

procedure TJVCSPurgeProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FRevisionsToKeep]);
      WriteFields(False, [FExec]);
    end;
end;

{ TJVCSPurgeProject public }

procedure TJVCSPurgeProject.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSPurgeProject) then
    begin
      FProjectID := TJVCSPurgeProject(Reference).FProjectID;
      FRevisionsToKeep := TJVCSPurgeProject(Reference).FRevisionsToKeep;
      FExec := TJVCSPurgeProject(Reference).FExec;
      FAffectedFileCount := TJVCSPurgeProject(Reference).FAffectedFileCount;
      FDeletedRevisionCount := TJVCSPurgeProject(Reference).FDeletedRevisionCount;
    end;
end;

procedure TJVCSPurgeProject.Initialize; 
begin
  inherited Initialize;
  FAffectedFileCount := -1;
  FDeletedRevisionCount := -1;
end;

procedure TJVCSPurgeProject.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAffectedFileCount := StrToInt64Def(ResponseBuffer.Fields[0], -1);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FDeletedRevisionCount := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSPurgeProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSPurgeProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSPurgeProject.Get_RevisionsToKeep: Integer; safecall;
begin
  Result := RevisionsToKeep;
end;

procedure TJVCSPurgeProject.Set_RevisionsToKeep(Value: Integer); safecall;
begin
  RevisionsToKeep := Value;
end;

function TJVCSPurgeProject.Get_Exec: WordBool; safecall;
begin
  Result := Exec;
end;

procedure TJVCSPurgeProject.Set_Exec(Value: WordBool); safecall;
begin
  Exec := Value;
end;

function TJVCSPurgeProject.Get_AffectedFileCount: Integer; safecall;
begin
  Result := AffectedFileCount;
end;

function TJVCSPurgeProject.Get_DeletedRevisionCount: Integer; safecall;
begin
  Result := DeletedRevisionCount;
end;

{$ENDIF COMVERSION}

{ TJVCSReadConfigData private }

procedure TJVCSReadConfigData.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
  begin
    Finalize(PReadConfigDataInputItem(FInputItems[I])^);
    FreeMem(FInputItems[I]);
  end;
  FInputItems.Clear;
end;

procedure TJVCSReadConfigData.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PReadConfigDataOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSReadConfigData.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSReadConfigData.GetInputItems(Index: Integer): TReadConfigDataInputItem;
begin
  Result := PReadConfigDataInputItem(FInputItems[Index])^;
end;

function TJVCSReadConfigData.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSReadConfigData.GetOutputItems(Index: Integer): TReadConfigDataOutputItem;
begin
  Result := PReadConfigDataOutputItem(FOutputItems[Index])^;
end;

{ TJVCSReadConfigData protected }

procedure TJVCSReadConfigData.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [Value]);
        end;
    end;
end;

{ TJVCSReadConfigData public }

constructor TJVCSReadConfigData.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSReadConfigData.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

function TJVCSReadConfigData.AddInputItem(const AValue: string): Integer;
var
  P: PReadConfigDataInputItem;
begin
  P := AllocMem(SizeOf(TReadConfigDataInputItem));
  try
    P^.Value := AValue;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSReadConfigDataInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSReadConfigData.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSReadConfigData) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSReadConfigData(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReadConfigDataInputItem));
        try
          with PReadConfigDataInputItem(P)^ do
          begin
            Value := TJVCSReadConfigData(Reference).InputItems[I].Value;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSReadConfigDataInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
      ClearOutputItems;
      for I := 0 to TJVCSReadConfigData(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReadConfigDataOutputItem));
        try
          with PReadConfigDataOutputItem(P)^ do
          begin
            Value := TJVCSReadConfigData(Reference).OutputItems[I].Value;
            Data := TJVCSReadConfigData(Reference).OutputItems[I].Data;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReadConfigDataOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSReadConfigData.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSReadConfigData.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TReadConfigDataOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PReadConfigDataOutputItem(P)^.Value := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PReadConfigDataOutputItem(P)^.Data := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReadConfigDataOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSReadConfigDataInputItem.Create(AOwner: TComponent; APtr: PReadConfigDataInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReadConfigDataInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReadConfigDataInputItem.Get_Value: WideString; safecall;
begin
  Result := FPtr^.Value;
end;

constructor TJVCSReadConfigDataOutputItem.Create(AOwner: TComponent; APtr: PReadConfigDataOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReadConfigDataOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReadConfigDataOutputItem.Get_Value: WideString; safecall;
begin
  Result := FPtr^.Value;
end;

function TJVCSReadConfigDataOutputItem.Get_Data: WideString; safecall;
begin
  Result := FPtr^.Data;
end;

function TJVCSReadConfigData.COMAddInputItem(const AValue: WideString): Integer; safecall;
begin
  Result := AddInputItem(AValue);
end;

function TJVCSReadConfigData.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSReadConfigData.Get_InputItems(Index: Integer): IJVCSReadConfigDataInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSReadConfigDataInputItem, Result);
end;

function TJVCSReadConfigData.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSReadConfigData.Get_OutputItems(Index: Integer): IJVCSReadConfigDataOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSReadConfigDataOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSWriteConfigData private }

procedure TJVCSWriteConfigData.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
  begin
    Finalize(PWriteConfigDataInputItem(FInputItems[I])^);
    FreeMem(FInputItems[I]);
  end;
  FInputItems.Clear;
end;

function TJVCSWriteConfigData.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSWriteConfigData.GetInputItems(Index: Integer): TWriteConfigDataInputItem;
begin
  Result := PWriteConfigDataInputItem(FInputItems[Index])^;
end;

{ TJVCSWriteConfigData protected }

procedure TJVCSWriteConfigData.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [Value]);
          WriteFields(False, [Data]);
        end;
    end;
end;

{ TJVCSWriteConfigData public }

constructor TJVCSWriteConfigData.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSWriteConfigData.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSWriteConfigData.AddInputItem(const AValue: string; const AData: string): Integer;
var
  P: PWriteConfigDataInputItem;
begin
  P := AllocMem(SizeOf(TWriteConfigDataInputItem));
  try
    P^.Value := AValue;
    P^.Data := AData;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSWriteConfigDataInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSWriteConfigData.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSWriteConfigData) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSWriteConfigData(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TWriteConfigDataInputItem));
        try
          with PWriteConfigDataInputItem(P)^ do
          begin
            Value := TJVCSWriteConfigData(Reference).InputItems[I].Value;
            Data := TJVCSWriteConfigData(Reference).InputItems[I].Data;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSWriteConfigDataInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

{$IFDEF COMVERSION}
constructor TJVCSWriteConfigDataInputItem.Create(AOwner: TComponent; APtr: PWriteConfigDataInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSWriteConfigDataInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSWriteConfigDataInputItem.Get_Value: WideString; safecall;
begin
  Result := FPtr^.Value;
end;

function TJVCSWriteConfigDataInputItem.Get_Data: WideString; safecall;
begin
  Result := FPtr^.Data;
end;

function TJVCSWriteConfigData.COMAddInputItem(const AValue: WideString; const AData: WideString): Integer; safecall;
begin
  Result := AddInputItem(AValue, AData);
end;

function TJVCSWriteConfigData.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSWriteConfigData.Get_InputItems(Index: Integer): IJVCSWriteConfigDataInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSWriteConfigDataInputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectModuleList private }

procedure TJVCSGetProjectModuleList.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetProjectModuleList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectModuleList.GetOutputItems(Index: Integer): TGetProjectModuleListOutputItem;
begin
  Result := PGetProjectModuleListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectModuleList protected }

procedure TJVCSGetProjectModuleList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
    end;
end;

{ TJVCSGetProjectModuleList public }

constructor TJVCSGetProjectModuleList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectModuleList.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectModuleList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectModuleList) then
    begin
      FProjectID := TJVCSGetProjectModuleList(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetProjectModuleList(Reference).FExcludeHiddenModules;
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectModuleList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectModuleListOutputItem));
        try
          with PGetProjectModuleListOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetProjectModuleList(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetProjectModuleList(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetProjectModuleList(Reference).OutputItems[I].ModulePath;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectModuleListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectModuleList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectModuleList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectModuleListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectModuleListOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectModuleListOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectModuleListOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectModuleListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectModuleListOutputItem.Create(AOwner: TComponent; APtr: PGetProjectModuleListOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectModuleListOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectModuleListOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetProjectModuleListOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetProjectModuleListOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetProjectModuleList.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetProjectModuleList.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetProjectModuleList.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetProjectModuleList.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetProjectModuleList.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectModuleList.Get_OutputItems(Index: Integer): IJVCSGetProjectModuleListOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectModuleListOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetBlankModuleList private }

procedure TJVCSGetBlankModuleList.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetBlankModuleList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetBlankModuleList.GetOutputItems(Index: Integer): TGetBlankModuleListOutputItem;
begin
  Result := PGetBlankModuleListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetBlankModuleList protected }

procedure TJVCSGetBlankModuleList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
    end;
end;

{ TJVCSGetBlankModuleList public }

constructor TJVCSGetBlankModuleList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetBlankModuleList.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetBlankModuleList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetBlankModuleList) then
    begin
      FProjectID := TJVCSGetBlankModuleList(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetBlankModuleList(Reference).FExcludeHiddenModules;
      ClearOutputItems;
      for I := 0 to TJVCSGetBlankModuleList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetBlankModuleListOutputItem));
        try
          with PGetBlankModuleListOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetBlankModuleList(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetBlankModuleList(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetBlankModuleList(Reference).OutputItems[I].ModulePath;
            Hidden := TJVCSGetBlankModuleList(Reference).OutputItems[I].Hidden;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBlankModuleListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetBlankModuleList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetBlankModuleList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetBlankModuleListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetBlankModuleListOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetBlankModuleListOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetBlankModuleListOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetBlankModuleListOutputItem(P)^.Hidden := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBlankModuleListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetBlankModuleListOutputItem.Create(AOwner: TComponent; APtr: PGetBlankModuleListOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetBlankModuleListOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetBlankModuleListOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetBlankModuleListOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetBlankModuleListOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetBlankModuleListOutputItem.Get_Hidden: WordBool; safecall;
begin
  Result := FPtr^.Hidden;
end;

function TJVCSGetBlankModuleList.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetBlankModuleList.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetBlankModuleList.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetBlankModuleList.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetBlankModuleList.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetBlankModuleList.Get_OutputItems(Index: Integer): IJVCSGetBlankModuleListOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetBlankModuleListOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetSharedBy private }

procedure TJVCSGetSharedBy.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetSharedBy.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetSharedBy.GetOutputItems(Index: Integer): TGetSharedByOutputItem;
begin
  Result := PGetSharedByOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetSharedBy protected }

procedure TJVCSGetSharedBy.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetSharedBy public }

constructor TJVCSGetSharedBy.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetSharedBy.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetSharedBy.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSharedBy) then
    begin
      FModuleID := TJVCSGetSharedBy(Reference).FModuleID;
      ClearOutputItems;
      for I := 0 to TJVCSGetSharedBy(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetSharedByOutputItem));
        try
          with PGetSharedByOutputItem(P)^ do
          begin
            ProjectID := TJVCSGetSharedBy(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSGetSharedBy(Reference).OutputItems[I].ProjectName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSharedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetSharedBy.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetSharedBy.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetSharedByOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetSharedByOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetSharedByOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSharedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetSharedByOutputItem.Create(AOwner: TComponent; APtr: PGetSharedByOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetSharedByOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetSharedByOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetSharedByOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetSharedBy.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetSharedBy.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetSharedBy.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetSharedBy.Get_OutputItems(Index: Integer): IJVCSGetSharedByOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetSharedByOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddNewProject protected }

procedure TJVCSAddNewProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FProjectName]);
      WriteFields(False, [FDescription]);
    end;
end;

{ TJVCSAddNewProject public }

procedure TJVCSAddNewProject.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddNewProject) then
    begin
      FUserID := TJVCSAddNewProject(Reference).FUserID;
      FProjectName := TJVCSAddNewProject(Reference).FProjectName;
      FDescription := TJVCSAddNewProject(Reference).FDescription;
      FIsNewProject := TJVCSAddNewProject(Reference).FIsNewProject;
      FProjectID := TJVCSAddNewProject(Reference).FProjectID;
    end;
end;

procedure TJVCSAddNewProject.Initialize; 
begin
  inherited Initialize;
  FIsNewProject := False;
  FProjectID := -1;
end;

procedure TJVCSAddNewProject.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FIsNewProject := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FProjectID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddNewProject.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSAddNewProject.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSAddNewProject.Get_ProjectName: WideString; safecall;
begin
  Result := ProjectName;
end;

procedure TJVCSAddNewProject.Set_ProjectName(const Value: WideString); safecall;
begin
  ProjectName := Value;
end;

function TJVCSAddNewProject.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAddNewProject.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

function TJVCSAddNewProject.Get_IsNewProject: WordBool; safecall;
begin
  Result := IsNewProject;
end;

function TJVCSAddNewProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveProject private }

procedure TJVCSRemoveProject.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSRemoveProject.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSRemoveProject.GetOutputItems(Index: Integer): TRemoveProjectOutputItem;
begin
  Result := PRemoveProjectOutputItem(FOutputItems[Index])^;
end;

{ TJVCSRemoveProject protected }

procedure TJVCSRemoveProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSRemoveProject public }

constructor TJVCSRemoveProject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRemoveProject.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSRemoveProject.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProject) then
    begin
      FProjectID := TJVCSRemoveProject(Reference).FProjectID;
      FRemoved := TJVCSRemoveProject(Reference).FRemoved;
      FErrorMessage := TJVCSRemoveProject(Reference).FErrorMessage;
      ClearOutputItems;
      for I := 0 to TJVCSRemoveProject(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRemoveProjectOutputItem));
        try
          with PRemoveProjectOutputItem(P)^ do
          begin
            ModuleID := TJVCSRemoveProject(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSRemoveProject(Reference).OutputItems[I].ModuleName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSRemoveProject.Initialize; 
begin
  inherited Initialize;
  FRemoved := False;
  FErrorMessage := '';
  ClearOutputItems;
end;

procedure TJVCSRemoveProject.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TRemoveProjectOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PRemoveProjectOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PRemoveProjectOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRemoveProjectOutputItem.Create(AOwner: TComponent; APtr: PRemoveProjectOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRemoveProjectOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRemoveProjectOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSRemoveProjectOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSRemoveProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveProject.Get_Removed: WordBool; safecall;
begin
  Result := Removed;
end;

function TJVCSRemoveProject.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

function TJVCSRemoveProject.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSRemoveProject.Get_OutputItems(Index: Integer): IJVCSRemoveProjectOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSRemoveProjectOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRestoreProject protected }

procedure TJVCSRestoreProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSRestoreProject public }

procedure TJVCSRestoreProject.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRestoreProject) then
    begin
      FProjectID := TJVCSRestoreProject(Reference).FProjectID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRestoreProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRestoreProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectReferences private }

procedure TJVCSGetProjectReferences.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetProjectReferences.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectReferences.GetOutputItems(Index: Integer): TGetProjectReferencesOutputItem;
begin
  Result := PGetProjectReferencesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectReferences protected }

procedure TJVCSGetProjectReferences.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetProjectReferences public }

constructor TJVCSGetProjectReferences.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectReferences.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectReferences.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectReferences) then
    begin
      FProjectID := TJVCSGetProjectReferences(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectReferences(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectReferencesOutputItem));
        try
          with PGetProjectReferencesOutputItem(P)^ do
          begin
            ProjectID := TJVCSGetProjectReferences(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSGetProjectReferences(Reference).OutputItems[I].ProjectName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectReferencesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectReferences.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectReferences.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectReferencesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectReferencesOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectReferencesOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectReferencesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectReferencesOutputItem.Create(AOwner: TComponent; APtr: PGetProjectReferencesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectReferencesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectReferencesOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetProjectReferencesOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetProjectReferences.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetProjectReferences.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetProjectReferences.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectReferences.Get_OutputItems(Index: Integer): IJVCSGetProjectReferencesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectReferencesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateProjectReferences private }

procedure TJVCSAddUpdateProjectReferences.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
    FreeMem(FInputItems[I]);
  FInputItems.Clear;
end;

function TJVCSAddUpdateProjectReferences.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSAddUpdateProjectReferences.GetInputItems(Index: Integer): TAddUpdateProjectReferencesInputItem;
begin
  Result := PAddUpdateProjectReferencesInputItem(FInputItems[Index])^;
end;

{ TJVCSAddUpdateProjectReferences protected }

procedure TJVCSAddUpdateProjectReferences.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUpdate]);
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [ReferenceID]);
        end;
    end;
end;

{ TJVCSAddUpdateProjectReferences public }

constructor TJVCSAddUpdateProjectReferences.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSAddUpdateProjectReferences.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSAddUpdateProjectReferences.AddInputItem(AReferenceID: Integer): Integer;
var
  P: PAddUpdateProjectReferencesInputItem;
begin
  P := AllocMem(SizeOf(TAddUpdateProjectReferencesInputItem));
  try
    P^.ReferenceID := AReferenceID;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSAddUpdateProjectReferencesInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSAddUpdateProjectReferences.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateProjectReferences) then
    begin
      FProjectID := TJVCSAddUpdateProjectReferences(Reference).FProjectID;
      FUpdate := TJVCSAddUpdateProjectReferences(Reference).FUpdate;
      ClearInputItems;
      for I := 0 to TJVCSAddUpdateProjectReferences(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TAddUpdateProjectReferencesInputItem));
        try
          with PAddUpdateProjectReferencesInputItem(P)^ do
          begin
            ReferenceID := TJVCSAddUpdateProjectReferences(Reference).InputItems[I].ReferenceID;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSAddUpdateProjectReferencesInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

{$IFDEF COMVERSION}
constructor TJVCSAddUpdateProjectReferencesInputItem.Create(AOwner: TComponent; APtr: PAddUpdateProjectReferencesInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSAddUpdateProjectReferencesInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSAddUpdateProjectReferencesInputItem.Get_ReferenceID: Integer; safecall;
begin
  Result := FPtr^.ReferenceID;
end;

function TJVCSAddUpdateProjectReferences.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSAddUpdateProjectReferences.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSAddUpdateProjectReferences.Get_Update: WordBool; safecall;
begin
  Result := Update;
end;

procedure TJVCSAddUpdateProjectReferences.Set_Update(Value: WordBool); safecall;
begin
  Update := Value;
end;

function TJVCSAddUpdateProjectReferences.COMAddInputItem(AReferenceID: Integer): Integer; safecall;
begin
  Result := AddInputItem(AReferenceID);
end;

function TJVCSAddUpdateProjectReferences.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSAddUpdateProjectReferences.Get_InputItems(Index: Integer): IJVCSAddUpdateProjectReferencesInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSAddUpdateProjectReferencesInputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveProjectReferences protected }

procedure TJVCSRemoveProjectReferences.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FReferenceID]);
    end;
end;

{ TJVCSRemoveProjectReferences public }

procedure TJVCSRemoveProjectReferences.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProjectReferences) then
    begin
      FProjectID := TJVCSRemoveProjectReferences(Reference).FProjectID;
      FReferenceID := TJVCSRemoveProjectReferences(Reference).FReferenceID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveProjectReferences.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveProjectReferences.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveProjectReferences.Get_ReferenceID: Integer; safecall;
begin
  Result := ReferenceID;
end;

procedure TJVCSRemoveProjectReferences.Set_ReferenceID(Value: Integer); safecall;
begin
  ReferenceID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectInformation private }

procedure TJVCSGetProjectInformation.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetProjectInformationOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetProjectInformation.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectInformation.GetOutputItems(Index: Integer): TGetProjectInformationOutputItem;
begin
  Result := PGetProjectInformationOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectInformation protected }

procedure TJVCSGetProjectInformation.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetProjectInformation public }

constructor TJVCSGetProjectInformation.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectInformation.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectInformation.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectInformation) then
    begin
      FProjectID := TJVCSGetProjectInformation(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectInformation(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectInformationOutputItem));
        try
          with PGetProjectInformationOutputItem(P)^ do
          begin
            ProjectID := TJVCSGetProjectInformation(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSGetProjectInformation(Reference).OutputItems[I].ProjectName;
            Created := TJVCSGetProjectInformation(Reference).OutputItems[I].Created;
            CreatedBy := TJVCSGetProjectInformation(Reference).OutputItems[I].CreatedBy;
            LastWriteAccess := TJVCSGetProjectInformation(Reference).OutputItems[I].LastWriteAccess;
            LastUser := TJVCSGetProjectInformation(Reference).OutputItems[I].LastUser;
            Description := TJVCSGetProjectInformation(Reference).OutputItems[I].Description;
            Deleted := TJVCSGetProjectInformation(Reference).OutputItems[I].Deleted;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectInformationOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectInformation.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectInformation.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectInformationOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectInformationOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectInformationOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectInformationOutputItem(P)^.Created := SafeStrToFloat(ResponseBuffer.Fields[2]);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetProjectInformationOutputItem(P)^.CreatedBy := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetProjectInformationOutputItem(P)^.LastWriteAccess := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetProjectInformationOutputItem(P)^.LastUser := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetProjectInformationOutputItem(P)^.Description := ResponseBuffer.Fields[6];
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetProjectInformationOutputItem(P)^.Deleted := (StrToInt64Def(ResponseBuffer.Fields[7], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectInformationOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectInformationOutputItem.Create(AOwner: TComponent; APtr: PGetProjectInformationOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectInformationOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectInformationOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetProjectInformationOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetProjectInformationOutputItem.Get_Created: TDateTime; safecall;
begin
  Result := FPtr^.Created;
end;

function TJVCSGetProjectInformationOutputItem.Get_CreatedBy: WideString; safecall;
begin
  Result := FPtr^.CreatedBy;
end;

function TJVCSGetProjectInformationOutputItem.Get_LastWriteAccess: TDateTime; safecall;
begin
  Result := FPtr^.LastWriteAccess;
end;

function TJVCSGetProjectInformationOutputItem.Get_LastUser: WideString; safecall;
begin
  Result := FPtr^.LastUser;
end;

function TJVCSGetProjectInformationOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetProjectInformationOutputItem.Get_Deleted: WordBool; safecall;
begin
  Result := FPtr^.Deleted;
end;

function TJVCSGetProjectInformation.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetProjectInformation.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetProjectInformation.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectInformation.Get_OutputItems(Index: Integer): IJVCSGetProjectInformationOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectInformationOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectList private }

procedure TJVCSGetProjectList.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetProjectListOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetProjectList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectList.GetOutputItems(Index: Integer): TGetProjectListOutputItem;
begin
  Result := PGetProjectListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectList protected }

procedure TJVCSGetProjectList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(False, [FPurpose]);
      WriteFields(True, [FIncludeDetails]);
    end;
end;

{ TJVCSGetProjectList public }

constructor TJVCSGetProjectList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectList.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectList) then
    begin
      FPurpose := TJVCSGetProjectList(Reference).FPurpose;
      FIncludeDetails := TJVCSGetProjectList(Reference).FIncludeDetails;
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectListOutputItem));
        try
          with PGetProjectListOutputItem(P)^ do
          begin
            ProjectID := TJVCSGetProjectList(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSGetProjectList(Reference).OutputItems[I].ProjectName;
            ProjectDeleted := TJVCSGetProjectList(Reference).OutputItems[I].ProjectDeleted;
            History := TJVCSGetProjectList(Reference).OutputItems[I].History;
            Description := TJVCSGetProjectList(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectListOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectListOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectListOutputItem(P)^.ProjectDeleted := (StrToInt64Def(ResponseBuffer.Fields[2], 0) <> 0);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetProjectListOutputItem(P)^.History := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetProjectListOutputItem(P)^.Description := ResponseBuffer.Fields[4];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectListOutputItem.Create(AOwner: TComponent; APtr: PGetProjectListOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectListOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectListOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetProjectListOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetProjectListOutputItem.Get_ProjectDeleted: WordBool; safecall;
begin
  Result := FPtr^.ProjectDeleted;
end;

function TJVCSGetProjectListOutputItem.Get_History: WideString; safecall;
begin
  Result := FPtr^.History;
end;

function TJVCSGetProjectListOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetProjectList.Get_Purpose: WideString; safecall;
begin
  Result := Purpose;
end;

procedure TJVCSGetProjectList.Set_Purpose(const Value: WideString); safecall;
begin
  Purpose := Value;
end;

function TJVCSGetProjectList.Get_IncludeDetails: WordBool; safecall;
begin
  Result := IncludeDetails;
end;

procedure TJVCSGetProjectList.Set_IncludeDetails(Value: WordBool); safecall;
begin
  IncludeDetails := Value;
end;

function TJVCSGetProjectList.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectList.Get_OutputItems(Index: Integer): IJVCSGetProjectListOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectListOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetVersionList private }

procedure TJVCSGetVersionList.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetVersionList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetVersionList.GetOutputItems(Index: Integer): TGetVersionListOutputItem;
begin
  Result := PGetVersionListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetVersionList protected }

procedure TJVCSGetVersionList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
    end;
end;

{ TJVCSGetVersionList public }

constructor TJVCSGetVersionList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetVersionList.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetVersionList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetVersionList) then
    begin
      FProjectID := TJVCSGetVersionList(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetVersionList(Reference).FExcludeHiddenModules;
      ClearOutputItems;
      for I := 0 to TJVCSGetVersionList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetVersionListOutputItem));
        try
          with PGetVersionListOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetVersionList(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetVersionList(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetVersionList(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetVersionList(Reference).OutputItems[I].CheckedOut;
            Timestamp := TJVCSGetVersionList(Reference).OutputItems[I].Timestamp;
            UserID := TJVCSGetVersionList(Reference).OutputItems[I].UserID;
            RevisionID := TJVCSGetVersionList(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetVersionList(Reference).OutputItems[I].Version;
            Revision := TJVCSGetVersionList(Reference).OutputItems[I].Revision;
            Hidden := TJVCSGetVersionList(Reference).OutputItems[I].Hidden;
            Owner := TJVCSGetVersionList(Reference).OutputItems[I].Owner;
            RevisionCount := TJVCSGetVersionList(Reference).OutputItems[I].RevisionCount;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetVersionListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetVersionList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetVersionList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetVersionListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetVersionListOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetVersionListOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetVersionListOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetVersionListOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetVersionListOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetVersionListOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetVersionListOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetVersionListOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetVersionListOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetVersionListOutputItem(P)^.Hidden := (StrToInt64Def(ResponseBuffer.Fields[9], 0) <> 0);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetVersionListOutputItem(P)^.Owner := ResponseBuffer.Fields[10];
          if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
            PGetVersionListOutputItem(P)^.RevisionCount := StrToInt64Def(ResponseBuffer.Fields[11], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetVersionListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetVersionListOutputItem.Create(AOwner: TComponent; APtr: PGetVersionListOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetVersionListOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetVersionListOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetVersionListOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetVersionListOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetVersionListOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetVersionListOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetVersionListOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetVersionListOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetVersionListOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetVersionListOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetVersionListOutputItem.Get_Hidden: WordBool; safecall;
begin
  Result := FPtr^.Hidden;
end;

function TJVCSGetVersionListOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetVersionListOutputItem.Get_RevisionCount: Integer; safecall;
begin
  Result := FPtr^.RevisionCount;
end;

function TJVCSGetVersionList.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetVersionList.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetVersionList.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetVersionList.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetVersionList.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetVersionList.Get_OutputItems(Index: Integer): IJVCSGetVersionListOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetVersionListOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionList private }

procedure TJVCSGetRevisionList.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRevisionList.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRevisionList.GetOutputItems(Index: Integer): TGetRevisionListOutputItem;
begin
  Result := PGetRevisionListOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRevisionList protected }

procedure TJVCSGetRevisionList.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
    end;
end;

{ TJVCSGetRevisionList public }

constructor TJVCSGetRevisionList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRevisionList.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRevisionList.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionList) then
    begin
      FProjectID := TJVCSGetRevisionList(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetRevisionList(Reference).FExcludeHiddenModules;
      ClearOutputItems;
      for I := 0 to TJVCSGetRevisionList(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRevisionListOutputItem));
        try
          with PGetRevisionListOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRevisionList(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRevisionList(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRevisionList(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetRevisionList(Reference).OutputItems[I].CheckedOut;
            Timestamp := TJVCSGetRevisionList(Reference).OutputItems[I].Timestamp;
            UserID := TJVCSGetRevisionList(Reference).OutputItems[I].UserID;
            RevisionID := TJVCSGetRevisionList(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetRevisionList(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRevisionList(Reference).OutputItems[I].Revision;
            Hidden := TJVCSGetRevisionList(Reference).OutputItems[I].Hidden;
            Owner := TJVCSGetRevisionList(Reference).OutputItems[I].Owner;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRevisionList.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRevisionList.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRevisionListOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRevisionListOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRevisionListOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRevisionListOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRevisionListOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRevisionListOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRevisionListOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRevisionListOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRevisionListOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRevisionListOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetRevisionListOutputItem(P)^.Hidden := (StrToInt64Def(ResponseBuffer.Fields[9], 0) <> 0);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetRevisionListOutputItem(P)^.Owner := ResponseBuffer.Fields[10];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRevisionListOutputItem.Create(AOwner: TComponent; APtr: PGetRevisionListOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRevisionListOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRevisionListOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRevisionListOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRevisionListOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRevisionListOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetRevisionListOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetRevisionListOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetRevisionListOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetRevisionListOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRevisionListOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRevisionListOutputItem.Get_Hidden: WordBool; safecall;
begin
  Result := FPtr^.Hidden;
end;

function TJVCSGetRevisionListOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetRevisionList.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetRevisionList.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetRevisionList.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetRevisionList.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetRevisionList.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRevisionList.Get_OutputItems(Index: Integer): IJVCSGetRevisionListOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRevisionListOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLatestRevisions private }

procedure TJVCSGetLatestRevisions.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetLatestRevisions.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLatestRevisions.GetOutputItems(Index: Integer): TGetLatestRevisionsOutputItem;
begin
  Result := PGetLatestRevisionsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLatestRevisions protected }

procedure TJVCSGetLatestRevisions.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
      WriteFields(False, [FLabelID]);
    end;
end;

{ TJVCSGetLatestRevisions public }

constructor TJVCSGetLatestRevisions.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLatestRevisions.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLatestRevisions.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLatestRevisions) then
    begin
      FProjectID := TJVCSGetLatestRevisions(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetLatestRevisions(Reference).FExcludeHiddenModules;
      FLabelID := TJVCSGetLatestRevisions(Reference).FLabelID;
      ClearOutputItems;
      for I := 0 to TJVCSGetLatestRevisions(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLatestRevisionsOutputItem));
        try
          with PGetLatestRevisionsOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetLatestRevisions(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetLatestRevisions(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetLatestRevisions(Reference).OutputItems[I].ModulePath;
            RevisionID := TJVCSGetLatestRevisions(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetLatestRevisions(Reference).OutputItems[I].Version;
            Revision := TJVCSGetLatestRevisions(Reference).OutputItems[I].Revision;
            RevisionTimestamp := TJVCSGetLatestRevisions(Reference).OutputItems[I].RevisionTimestamp;
            RevisionExtension := TJVCSGetLatestRevisions(Reference).OutputItems[I].RevisionExtension;
            RevisionCRC32 := TJVCSGetLatestRevisions(Reference).OutputItems[I].RevisionCRC32;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLatestRevisionsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLatestRevisions.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLatestRevisions.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLatestRevisionsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.RevisionTimestamp := SafeStrToFloat(ResponseBuffer.Fields[6]);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetLatestRevisionsOutputItem(P)^.RevisionCRC32 := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLatestRevisionsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLatestRevisionsOutputItem.Create(AOwner: TComponent; APtr: PGetLatestRevisionsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLatestRevisionsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_RevisionTimestamp: TDateTime; safecall;
begin
  Result := FPtr^.RevisionTimestamp;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSGetLatestRevisionsOutputItem.Get_RevisionCRC32: Integer; safecall;
begin
  Result := FPtr^.RevisionCRC32;
end;

function TJVCSGetLatestRevisions.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetLatestRevisions.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetLatestRevisions.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetLatestRevisions.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetLatestRevisions.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSGetLatestRevisions.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSGetLatestRevisions.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLatestRevisions.Get_OutputItems(Index: Integer): IJVCSGetLatestRevisionsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLatestRevisionsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetVersionRevision private }

procedure TJVCSGetVersionRevision.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetVersionRevision.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetVersionRevision.GetOutputItems(Index: Integer): TGetVersionRevisionOutputItem;
begin
  Result := PGetVersionRevisionOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetVersionRevision protected }

procedure TJVCSGetVersionRevision.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
      WriteFields(False, [FVersion]);
      WriteFields(False, [FRevision]);
    end;
end;

{ TJVCSGetVersionRevision public }

constructor TJVCSGetVersionRevision.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetVersionRevision.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetVersionRevision.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetVersionRevision) then
    begin
      FProjectID := TJVCSGetVersionRevision(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetVersionRevision(Reference).FExcludeHiddenModules;
      FVersion := TJVCSGetVersionRevision(Reference).FVersion;
      FRevision := TJVCSGetVersionRevision(Reference).FRevision;
      ClearOutputItems;
      for I := 0 to TJVCSGetVersionRevision(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetVersionRevisionOutputItem));
        try
          with PGetVersionRevisionOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetVersionRevision(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetVersionRevision(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetVersionRevision(Reference).OutputItems[I].ModulePath;
            RevisionID := TJVCSGetVersionRevision(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetVersionRevision(Reference).OutputItems[I].Version;
            Revision := TJVCSGetVersionRevision(Reference).OutputItems[I].Revision;
            RevisionTimestamp := TJVCSGetVersionRevision(Reference).OutputItems[I].RevisionTimestamp;
            RevisionExtension := TJVCSGetVersionRevision(Reference).OutputItems[I].RevisionExtension;
            RevisionCRC32 := TJVCSGetVersionRevision(Reference).OutputItems[I].RevisionCRC32;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetVersionRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetVersionRevision.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetVersionRevision.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetVersionRevisionOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetVersionRevisionOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetVersionRevisionOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetVersionRevisionOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetVersionRevisionOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetVersionRevisionOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetVersionRevisionOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetVersionRevisionOutputItem(P)^.RevisionTimestamp := SafeStrToFloat(ResponseBuffer.Fields[6]);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetVersionRevisionOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetVersionRevisionOutputItem(P)^.RevisionCRC32 := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetVersionRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetVersionRevisionOutputItem.Create(AOwner: TComponent; APtr: PGetVersionRevisionOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetVersionRevisionOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetVersionRevisionOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetVersionRevisionOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetVersionRevisionOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetVersionRevisionOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetVersionRevisionOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetVersionRevisionOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetVersionRevisionOutputItem.Get_RevisionTimestamp: TDateTime; safecall;
begin
  Result := FPtr^.RevisionTimestamp;
end;

function TJVCSGetVersionRevisionOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSGetVersionRevisionOutputItem.Get_RevisionCRC32: Integer; safecall;
begin
  Result := FPtr^.RevisionCRC32;
end;

function TJVCSGetVersionRevision.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetVersionRevision.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetVersionRevision.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetVersionRevision.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetVersionRevision.Get_Version: Integer; safecall;
begin
  Result := Version;
end;

procedure TJVCSGetVersionRevision.Set_Version(Value: Integer); safecall;
begin
  Version := Value;
end;

function TJVCSGetVersionRevision.Get_Revision: Integer; safecall;
begin
  Result := Revision;
end;

procedure TJVCSGetVersionRevision.Set_Revision(Value: Integer); safecall;
begin
  Revision := Value;
end;

function TJVCSGetVersionRevision.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetVersionRevision.Get_OutputItems(Index: Integer): IJVCSGetVersionRevisionOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetVersionRevisionOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRollbackRevisions private }

procedure TJVCSGetRollbackRevisions.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRollbackRevisions.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRollbackRevisions.GetOutputItems(Index: Integer): TGetRollbackRevisionsOutputItem;
begin
  Result := PGetRollbackRevisionsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRollbackRevisions protected }

procedure TJVCSGetRollbackRevisions.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FExcludeHiddenModules]);
      WriteFields(False, [FRollbackDate]);
    end;
end;

{ TJVCSGetRollbackRevisions public }

constructor TJVCSGetRollbackRevisions.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRollbackRevisions.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRollbackRevisions.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRollbackRevisions) then
    begin
      FProjectID := TJVCSGetRollbackRevisions(Reference).FProjectID;
      FExcludeHiddenModules := TJVCSGetRollbackRevisions(Reference).FExcludeHiddenModules;
      FRollbackDate := TJVCSGetRollbackRevisions(Reference).FRollbackDate;
      ClearOutputItems;
      for I := 0 to TJVCSGetRollbackRevisions(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRollbackRevisionsOutputItem));
        try
          with PGetRollbackRevisionsOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRollbackRevisions(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRollbackRevisions(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRollbackRevisions(Reference).OutputItems[I].ModulePath;
            RevisionID := TJVCSGetRollbackRevisions(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetRollbackRevisions(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRollbackRevisions(Reference).OutputItems[I].Revision;
            RevisionTimestamp := TJVCSGetRollbackRevisions(Reference).OutputItems[I].RevisionTimestamp;
            RevisionExtension := TJVCSGetRollbackRevisions(Reference).OutputItems[I].RevisionExtension;
            RevisionCRC32 := TJVCSGetRollbackRevisions(Reference).OutputItems[I].RevisionCRC32;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRollbackRevisionsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRollbackRevisions.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRollbackRevisions.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRollbackRevisionsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.RevisionTimestamp := SafeStrToFloat(ResponseBuffer.Fields[6]);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRollbackRevisionsOutputItem(P)^.RevisionCRC32 := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRollbackRevisionsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRollbackRevisionsOutputItem.Create(AOwner: TComponent; APtr: PGetRollbackRevisionsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRollbackRevisionsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_RevisionTimestamp: TDateTime; safecall;
begin
  Result := FPtr^.RevisionTimestamp;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSGetRollbackRevisionsOutputItem.Get_RevisionCRC32: Integer; safecall;
begin
  Result := FPtr^.RevisionCRC32;
end;

function TJVCSGetRollbackRevisions.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetRollbackRevisions.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetRollbackRevisions.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetRollbackRevisions.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetRollbackRevisions.Get_RollbackDate: TDateTime; safecall;
begin
  Result := RollbackDate;
end;

procedure TJVCSGetRollbackRevisions.Set_RollbackDate(Value: TDateTime); safecall;
begin
  RollbackDate := Value;
end;

function TJVCSGetRollbackRevisions.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRollbackRevisions.Get_OutputItems(Index: Integer): IJVCSGetRollbackRevisionsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRollbackRevisionsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLockedModules private }

procedure TJVCSGetLockedModules.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetLockedModules.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLockedModules.GetOutputItems(Index: Integer): TGetLockedModulesOutputItem;
begin
  Result := PGetLockedModulesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLockedModules protected }

procedure TJVCSGetLockedModules.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
    end;
end;

{ TJVCSGetLockedModules public }

constructor TJVCSGetLockedModules.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLockedModules.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLockedModules.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLockedModules) then
    begin
      FProjectID := TJVCSGetLockedModules(Reference).FProjectID;
      FUserID := TJVCSGetLockedModules(Reference).FUserID;
      ClearOutputItems;
      for I := 0 to TJVCSGetLockedModules(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLockedModulesOutputItem));
        try
          with PGetLockedModulesOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetLockedModules(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetLockedModules(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetLockedModules(Reference).OutputItems[I].ModulePath;
            Version := TJVCSGetLockedModules(Reference).OutputItems[I].Version;
            Revision := TJVCSGetLockedModules(Reference).OutputItems[I].Revision;
            LockedTimestamp := TJVCSGetLockedModules(Reference).OutputItems[I].LockedTimestamp;
            Owner := TJVCSGetLockedModules(Reference).OutputItems[I].Owner;
            OwnerID := TJVCSGetLockedModules(Reference).OutputItems[I].OwnerID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLockedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLockedModules.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLockedModules.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLockedModulesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLockedModulesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLockedModulesOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLockedModulesOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetLockedModulesOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetLockedModulesOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetLockedModulesOutputItem(P)^.LockedTimestamp := SafeStrToFloat(ResponseBuffer.Fields[5]);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetLockedModulesOutputItem(P)^.Owner := ResponseBuffer.Fields[6];
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetLockedModulesOutputItem(P)^.OwnerID := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLockedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLockedModulesOutputItem.Create(AOwner: TComponent; APtr: PGetLockedModulesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLockedModulesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLockedModulesOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetLockedModulesOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetLockedModulesOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetLockedModulesOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetLockedModulesOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetLockedModulesOutputItem.Get_LockedTimestamp: TDateTime; safecall;
begin
  Result := FPtr^.LockedTimestamp;
end;

function TJVCSGetLockedModulesOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetLockedModulesOutputItem.Get_OwnerID: Integer; safecall;
begin
  Result := FPtr^.OwnerID;
end;

function TJVCSGetLockedModules.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetLockedModules.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetLockedModules.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSGetLockedModules.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSGetLockedModules.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLockedModules.Get_OutputItems(Index: Integer): IJVCSGetLockedModulesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLockedModulesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRenameProject private }

procedure TJVCSRenameProject.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
    FreeMem(FInputItems[I]);
  FInputItems.Clear;
end;

procedure TJVCSRenameProject.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSRenameProject.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSRenameProject.GetInputItems(Index: Integer): TRenameProjectInputItem;
begin
  Result := PRenameProjectInputItem(FInputItems[Index])^;
end;

function TJVCSRenameProject.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSRenameProject.GetOutputItems(Index: Integer): TRenameProjectOutputItem;
begin
  Result := PRenameProjectOutputItem(FOutputItems[Index])^;
end;

{ TJVCSRenameProject protected }

procedure TJVCSRenameProject.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FProjectID]);
      WriteFields(False, [FNewProjectName]);
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [ModuleID]);
          WriteFields(False, [NewModuleName]);
        end;
    end;
end;

{ TJVCSRenameProject public }

constructor TJVCSRenameProject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRenameProject.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

function TJVCSRenameProject.AddInputItem(AModuleID: Integer; const ANewModuleName: string): Integer;
var
  P: PRenameProjectInputItem;
begin
  P := AllocMem(SizeOf(TRenameProjectInputItem));
  try
    P^.ModuleID := AModuleID;
    P^.NewModuleName := ANewModuleName;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSRenameProjectInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSRenameProject.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRenameProject) then
    begin
      FUserID := TJVCSRenameProject(Reference).FUserID;
      FProjectID := TJVCSRenameProject(Reference).FProjectID;
      FNewProjectName := TJVCSRenameProject(Reference).FNewProjectName;
      ClearInputItems;
      for I := 0 to TJVCSRenameProject(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRenameProjectInputItem));
        try
          with PRenameProjectInputItem(P)^ do
          begin
            ModuleID := TJVCSRenameProject(Reference).InputItems[I].ModuleID;
            NewModuleName := TJVCSRenameProject(Reference).InputItems[I].NewModuleName;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSRenameProjectInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
      FRenamed := TJVCSRenameProject(Reference).FRenamed;
      ClearOutputItems;
      for I := 0 to TJVCSRenameProject(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRenameProjectOutputItem));
        try
          with PRenameProjectOutputItem(P)^ do
          begin
            ModuleName := TJVCSRenameProject(Reference).OutputItems[I].ModuleName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRenameProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSRenameProject.Initialize; 
begin
  inherited Initialize;
  FRenamed := False;
  ClearOutputItems;
end;

procedure TJVCSRenameProject.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FRenamed := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TRenameProjectOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PRenameProjectOutputItem(P)^.ModuleName := ResponseBuffer.Fields[0];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRenameProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRenameProjectInputItem.Create(AOwner: TComponent; APtr: PRenameProjectInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRenameProjectInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRenameProjectInputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSRenameProjectInputItem.Get_NewModuleName: WideString; safecall;
begin
  Result := FPtr^.NewModuleName;
end;

constructor TJVCSRenameProjectOutputItem.Create(AOwner: TComponent; APtr: PRenameProjectOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRenameProjectOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRenameProjectOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSRenameProject.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRenameProject.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSRenameProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRenameProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRenameProject.Get_NewProjectName: WideString; safecall;
begin
  Result := NewProjectName;
end;

procedure TJVCSRenameProject.Set_NewProjectName(const Value: WideString); safecall;
begin
  NewProjectName := Value;
end;

function TJVCSRenameProject.COMAddInputItem(AModuleID: Integer; const ANewModuleName: WideString): Integer; safecall;
begin
  Result := AddInputItem(AModuleID, ANewModuleName);
end;

function TJVCSRenameProject.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSRenameProject.Get_InputItems(Index: Integer): IJVCSRenameProjectInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSRenameProjectInputItem, Result);
end;

function TJVCSRenameProject.Get_Renamed: WordBool; safecall;
begin
  Result := Renamed;
end;

function TJVCSRenameProject.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSRenameProject.Get_OutputItems(Index: Integer): IJVCSRenameProjectOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSRenameProjectOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateProjectGroup protected }

procedure TJVCSAddUpdateProjectGroup.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FGroupID]);
      WriteFields(False, [FParentID]);
      WriteFields(False, [FGroupLevel]);
      WriteFields(False, [FFlags]);
      WriteFields(False, [FGroupName]);
      WriteFields(False, [FGroupDescription]);
    end;
end;

{ TJVCSAddUpdateProjectGroup public }

procedure TJVCSAddUpdateProjectGroup.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateProjectGroup) then
    begin
      FGroupID := TJVCSAddUpdateProjectGroup(Reference).FGroupID;
      FParentID := TJVCSAddUpdateProjectGroup(Reference).FParentID;
      FGroupLevel := TJVCSAddUpdateProjectGroup(Reference).FGroupLevel;
      FFlags := TJVCSAddUpdateProjectGroup(Reference).FFlags;
      FGroupName := TJVCSAddUpdateProjectGroup(Reference).FGroupName;
      FGroupDescription := TJVCSAddUpdateProjectGroup(Reference).FGroupDescription;
      FAddedGroupID := TJVCSAddUpdateProjectGroup(Reference).FAddedGroupID;
    end;
end;

procedure TJVCSAddUpdateProjectGroup.Initialize; 
begin
  inherited Initialize;
  FAddedGroupID := -1;
end;

procedure TJVCSAddUpdateProjectGroup.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAddedGroupID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateProjectGroup.Get_GroupID: Integer; safecall;
begin
  Result := GroupID;
end;

procedure TJVCSAddUpdateProjectGroup.Set_GroupID(Value: Integer); safecall;
begin
  GroupID := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_ParentID: Integer; safecall;
begin
  Result := ParentID;
end;

procedure TJVCSAddUpdateProjectGroup.Set_ParentID(Value: Integer); safecall;
begin
  ParentID := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_GroupLevel: Integer; safecall;
begin
  Result := GroupLevel;
end;

procedure TJVCSAddUpdateProjectGroup.Set_GroupLevel(Value: Integer); safecall;
begin
  GroupLevel := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_Flags: Integer; safecall;
begin
  Result := Flags;
end;

procedure TJVCSAddUpdateProjectGroup.Set_Flags(Value: Integer); safecall;
begin
  Flags := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_GroupName: WideString; safecall;
begin
  Result := GroupName;
end;

procedure TJVCSAddUpdateProjectGroup.Set_GroupName(const Value: WideString); safecall;
begin
  GroupName := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_GroupDescription: WideString; safecall;
begin
  Result := GroupDescription;
end;

procedure TJVCSAddUpdateProjectGroup.Set_GroupDescription(const Value: WideString); safecall;
begin
  GroupDescription := Value;
end;

function TJVCSAddUpdateProjectGroup.Get_AddedGroupID: Integer; safecall;
begin
  Result := AddedGroupID;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveProjectGroup protected }

procedure TJVCSRemoveProjectGroup.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FGroupID]);
    end;
end;

{ TJVCSRemoveProjectGroup public }

procedure TJVCSRemoveProjectGroup.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProjectGroup) then
    begin
      FGroupID := TJVCSRemoveProjectGroup(Reference).FGroupID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveProjectGroup.Get_GroupID: Integer; safecall;
begin
  Result := GroupID;
end;

procedure TJVCSRemoveProjectGroup.Set_GroupID(Value: Integer); safecall;
begin
  GroupID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectGroupInformation private }

procedure TJVCSGetProjectGroupInformation.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetProjectGroupInformationOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetProjectGroupInformation.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectGroupInformation.GetOutputItems(Index: Integer): TGetProjectGroupInformationOutputItem;
begin
  Result := PGetProjectGroupInformationOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectGroupInformation public }

constructor TJVCSGetProjectGroupInformation.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectGroupInformation.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectGroupInformation.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectGroupInformation) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectGroupInformation(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectGroupInformationOutputItem));
        try
          with PGetProjectGroupInformationOutputItem(P)^ do
          begin
            RecordType := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].RecordType;
            GroupID := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].GroupID;
            ParentID := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].ParentID;
            GroupLevel := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].GroupLevel;
            Flags := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].Flags;
            GroupName := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].GroupName;
            GroupDescription := TJVCSGetProjectGroupInformation(Reference).OutputItems[I].GroupDescription;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectGroupInformationOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectGroupInformation.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectGroupInformation.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectGroupInformationOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.RecordType := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.GroupID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.ParentID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.GroupLevel := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.Flags := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.GroupName := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetProjectGroupInformationOutputItem(P)^.GroupDescription := ResponseBuffer.Fields[6];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectGroupInformationOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectGroupInformationOutputItem.Create(AOwner: TComponent; APtr: PGetProjectGroupInformationOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectGroupInformationOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_RecordType: WideString; safecall;
begin
  Result := FPtr^.RecordType;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_GroupID: Integer; safecall;
begin
  Result := FPtr^.GroupID;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_ParentID: Integer; safecall;
begin
  Result := FPtr^.ParentID;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_GroupLevel: Integer; safecall;
begin
  Result := FPtr^.GroupLevel;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_Flags: Integer; safecall;
begin
  Result := FPtr^.Flags;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_GroupName: WideString; safecall;
begin
  Result := FPtr^.GroupName;
end;

function TJVCSGetProjectGroupInformationOutputItem.Get_GroupDescription: WideString; safecall;
begin
  Result := FPtr^.GroupDescription;
end;

function TJVCSGetProjectGroupInformation.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectGroupInformation.Get_OutputItems(Index: Integer): IJVCSGetProjectGroupInformationOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectGroupInformationOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddRemoveProjectToGroup protected }

procedure TJVCSAddRemoveProjectToGroup.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FGroupID]);
      WriteFields(False, [FAdd]);
    end;
end;

{ TJVCSAddRemoveProjectToGroup public }

procedure TJVCSAddRemoveProjectToGroup.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddRemoveProjectToGroup) then
    begin
      FProjectID := TJVCSAddRemoveProjectToGroup(Reference).FProjectID;
      FGroupID := TJVCSAddRemoveProjectToGroup(Reference).FGroupID;
      FAdd := TJVCSAddRemoveProjectToGroup(Reference).FAdd;
      FAdded := TJVCSAddRemoveProjectToGroup(Reference).FAdded;
    end;
end;

procedure TJVCSAddRemoveProjectToGroup.Initialize; 
begin
  inherited Initialize;
  FAdded := False;
end;

procedure TJVCSAddRemoveProjectToGroup.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAdded := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddRemoveProjectToGroup.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSAddRemoveProjectToGroup.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSAddRemoveProjectToGroup.Get_GroupID: Integer; safecall;
begin
  Result := GroupID;
end;

procedure TJVCSAddRemoveProjectToGroup.Set_GroupID(Value: Integer); safecall;
begin
  GroupID := Value;
end;

function TJVCSAddRemoveProjectToGroup.Get_Add: WordBool; safecall;
begin
  Result := Add;
end;

procedure TJVCSAddRemoveProjectToGroup.Set_Add(Value: WordBool); safecall;
begin
  Add := Value;
end;

function TJVCSAddRemoveProjectToGroup.Get_Added: WordBool; safecall;
begin
  Result := Added;
end;

{$ENDIF COMVERSION}

{ TJVCSGetModuleId protected }

procedure TJVCSGetModuleId.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleName]);
    end;
end;

{ TJVCSGetModuleId public }

procedure TJVCSGetModuleId.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetModuleId) then
    begin
      FModuleName := TJVCSGetModuleId(Reference).FModuleName;
      FModuleID := TJVCSGetModuleId(Reference).FModuleID;
      FErrorMessage := TJVCSGetModuleId(Reference).FErrorMessage;
    end;
end;

procedure TJVCSGetModuleId.Initialize; 
begin
  inherited Initialize;
  FModuleID := -1;
  FErrorMessage := '';
end;

procedure TJVCSGetModuleId.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetModuleId.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSGetModuleId.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSGetModuleId.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

function TJVCSGetModuleId.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSGetModuleName protected }

procedure TJVCSGetModuleName.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetModuleName public }

procedure TJVCSGetModuleName.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetModuleName) then
    begin
      FModuleID := TJVCSGetModuleName(Reference).FModuleID;
      FModuleName := TJVCSGetModuleName(Reference).FModuleName;
      FErrorMessage := TJVCSGetModuleName(Reference).FErrorMessage;
    end;
end;

procedure TJVCSGetModuleName.Initialize; 
begin
  inherited Initialize;
  FModuleName := '';
  FErrorMessage := '';
end;

procedure TJVCSGetModuleName.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleName := ResponseBuffer.Fields[0];
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetModuleName.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetModuleName.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetModuleName.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

function TJVCSGetModuleName.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSRenameModule protected }

procedure TJVCSRenameModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
      WriteFields(False, [FNewModuleName]);
      WriteFields(False, [FProjectID]);
    end;
end;

{ TJVCSRenameModule public }

procedure TJVCSRenameModule.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRenameModule) then
    begin
      FModuleID := TJVCSRenameModule(Reference).FModuleID;
      FNewModuleName := TJVCSRenameModule(Reference).FNewModuleName;
      FProjectID := TJVCSRenameModule(Reference).FProjectID;
      FSuccess := TJVCSRenameModule(Reference).FSuccess;
      FErrorMessage := TJVCSRenameModule(Reference).FErrorMessage;
    end;
end;

procedure TJVCSRenameModule.Initialize; 
begin
  inherited Initialize;
  FSuccess := False;
  FErrorMessage := '';
end;

procedure TJVCSRenameModule.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FSuccess := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSRenameModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSRenameModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSRenameModule.Get_NewModuleName: WideString; safecall;
begin
  Result := NewModuleName;
end;

procedure TJVCSRenameModule.Set_NewModuleName(const Value: WideString); safecall;
begin
  NewModuleName := Value;
end;

function TJVCSRenameModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRenameModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRenameModule.Get_Success: WordBool; safecall;
begin
  Result := Success;
end;

function TJVCSRenameModule.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSGetModulesLike private }

procedure TJVCSGetModulesLike.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetModulesLike.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetModulesLike.GetOutputItems(Index: Integer): TGetModulesLikeOutputItem;
begin
  Result := PGetModulesLikeOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetModulesLike protected }

procedure TJVCSGetModulesLike.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleName]);
    end;
end;

{ TJVCSGetModulesLike public }

constructor TJVCSGetModulesLike.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetModulesLike.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetModulesLike.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetModulesLike) then
    begin
      FModuleName := TJVCSGetModulesLike(Reference).FModuleName;
      ClearOutputItems;
      for I := 0 to TJVCSGetModulesLike(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetModulesLikeOutputItem));
        try
          with PGetModulesLikeOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetModulesLike(Reference).OutputItems[I].ModuleID;
            ModulePath := TJVCSGetModulesLike(Reference).OutputItems[I].ModulePath;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetModulesLikeOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetModulesLike.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetModulesLike.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetModulesLikeOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetModulesLikeOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetModulesLikeOutputItem(P)^.ModulePath := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetModulesLikeOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetModulesLikeOutputItem.Create(AOwner: TComponent; APtr: PGetModulesLikeOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetModulesLikeOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetModulesLikeOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetModulesLikeOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetModulesLike.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSGetModulesLike.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSGetModulesLike.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetModulesLike.Get_OutputItems(Index: Integer): IJVCSGetModulesLikeOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetModulesLikeOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionListByName private }

procedure TJVCSGetRevisionListByName.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRevisionListByName.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRevisionListByName.GetOutputItems(Index: Integer): TGetRevisionListByNameOutputItem;
begin
  Result := PGetRevisionListByNameOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRevisionListByName protected }

procedure TJVCSGetRevisionListByName.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleName]);
      WriteFields(False, [FProjectID]);
    end;
end;

{ TJVCSGetRevisionListByName public }

constructor TJVCSGetRevisionListByName.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRevisionListByName.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRevisionListByName.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionListByName) then
    begin
      FModuleName := TJVCSGetRevisionListByName(Reference).FModuleName;
      FProjectID := TJVCSGetRevisionListByName(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetRevisionListByName(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByNameOutputItem));
        try
          with PGetRevisionListByNameOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRevisionListByName(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRevisionListByName(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRevisionListByName(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetRevisionListByName(Reference).OutputItems[I].CheckedOut;
            Timestamp := TJVCSGetRevisionListByName(Reference).OutputItems[I].Timestamp;
            UserID := TJVCSGetRevisionListByName(Reference).OutputItems[I].UserID;
            RevisionID := TJVCSGetRevisionListByName(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetRevisionListByName(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRevisionListByName(Reference).OutputItems[I].Revision;
            Owner := TJVCSGetRevisionListByName(Reference).OutputItems[I].Owner;
            ProjectID := TJVCSGetRevisionListByName(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByNameOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRevisionListByName.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRevisionListByName.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByNameOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.Owner := ResponseBuffer.Fields[9];
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetRevisionListByNameOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[10], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByNameOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRevisionListByNameOutputItem.Create(AOwner: TComponent; APtr: PGetRevisionListByNameOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRevisionListByNameOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetRevisionListByNameOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetRevisionListByName.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSGetRevisionListByName.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSGetRevisionListByName.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetRevisionListByName.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetRevisionListByName.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRevisionListByName.Get_OutputItems(Index: Integer): IJVCSGetRevisionListByNameOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRevisionListByNameOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionListById private }

procedure TJVCSGetRevisionListById.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRevisionListById.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRevisionListById.GetOutputItems(Index: Integer): TGetRevisionListByIdOutputItem;
begin
  Result := PGetRevisionListByIdOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRevisionListById protected }

procedure TJVCSGetRevisionListById.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
      WriteFields(False, [FProjectID]);
    end;
end;

{ TJVCSGetRevisionListById public }

constructor TJVCSGetRevisionListById.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRevisionListById.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRevisionListById.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionListById) then
    begin
      FModuleID := TJVCSGetRevisionListById(Reference).FModuleID;
      FProjectID := TJVCSGetRevisionListById(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetRevisionListById(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByIdOutputItem));
        try
          with PGetRevisionListByIdOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRevisionListById(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRevisionListById(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRevisionListById(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetRevisionListById(Reference).OutputItems[I].CheckedOut;
            Timestamp := TJVCSGetRevisionListById(Reference).OutputItems[I].Timestamp;
            UserID := TJVCSGetRevisionListById(Reference).OutputItems[I].UserID;
            RevisionID := TJVCSGetRevisionListById(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetRevisionListById(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRevisionListById(Reference).OutputItems[I].Revision;
            Owner := TJVCSGetRevisionListById(Reference).OutputItems[I].Owner;
            ProjectID := TJVCSGetRevisionListById(Reference).OutputItems[I].ProjectID;
            Hidden := TJVCSGetRevisionListById(Reference).OutputItems[I].Hidden;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByIdOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRevisionListById.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRevisionListById.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByIdOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.UserID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.Owner := ResponseBuffer.Fields[9];
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[10], -1);
          if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
            PGetRevisionListByIdOutputItem(P)^.Hidden := (StrToInt64Def(ResponseBuffer.Fields[11], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByIdOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRevisionListByIdOutputItem.Create(AOwner: TComponent; APtr: PGetRevisionListByIdOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRevisionListByIdOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetRevisionListByIdOutputItem.Get_Hidden: WordBool; safecall;
begin
  Result := FPtr^.Hidden;
end;

function TJVCSGetRevisionListById.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetRevisionListById.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetRevisionListById.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetRevisionListById.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetRevisionListById.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRevisionListById.Get_OutputItems(Index: Integer): IJVCSGetRevisionListByIdOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRevisionListByIdOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionListByVersion private }

procedure TJVCSGetRevisionListByVersion.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRevisionListByVersion.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRevisionListByVersion.GetOutputItems(Index: Integer): TGetRevisionListByVersionOutputItem;
begin
  Result := PGetRevisionListByVersionOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRevisionListByVersion protected }

procedure TJVCSGetRevisionListByVersion.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FVersion]);
      WriteFields(False, [FRevision]);
      WriteFields(False, [FExcludeHiddenModules]);
    end;
end;

{ TJVCSGetRevisionListByVersion public }

constructor TJVCSGetRevisionListByVersion.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRevisionListByVersion.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRevisionListByVersion.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionListByVersion) then
    begin
      FProjectID := TJVCSGetRevisionListByVersion(Reference).FProjectID;
      FVersion := TJVCSGetRevisionListByVersion(Reference).FVersion;
      FRevision := TJVCSGetRevisionListByVersion(Reference).FRevision;
      FExcludeHiddenModules := TJVCSGetRevisionListByVersion(Reference).FExcludeHiddenModules;
      ClearOutputItems;
      for I := 0 to TJVCSGetRevisionListByVersion(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByVersionOutputItem));
        try
          with PGetRevisionListByVersionOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].CheckedOut;
            Timestamp := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].Timestamp;
            RevisionID := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].Revision;
            Owner := TJVCSGetRevisionListByVersion(Reference).OutputItems[I].Owner;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByVersionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRevisionListByVersion.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRevisionListByVersion.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRevisionListByVersionOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRevisionListByVersionOutputItem(P)^.Owner := ResponseBuffer.Fields[8];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionListByVersionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRevisionListByVersionOutputItem.Create(AOwner: TComponent; APtr: PGetRevisionListByVersionOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRevisionListByVersionOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRevisionListByVersionOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSGetRevisionListByVersion.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetRevisionListByVersion.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetRevisionListByVersion.Get_Version: Integer; safecall;
begin
  Result := Version;
end;

procedure TJVCSGetRevisionListByVersion.Set_Version(Value: Integer); safecall;
begin
  Version := Value;
end;

function TJVCSGetRevisionListByVersion.Get_Revision: Integer; safecall;
begin
  Result := Revision;
end;

procedure TJVCSGetRevisionListByVersion.Set_Revision(Value: Integer); safecall;
begin
  Revision := Value;
end;

function TJVCSGetRevisionListByVersion.Get_ExcludeHiddenModules: WordBool; safecall;
begin
  Result := ExcludeHiddenModules;
end;

procedure TJVCSGetRevisionListByVersion.Set_ExcludeHiddenModules(Value: WordBool); safecall;
begin
  ExcludeHiddenModules := Value;
end;

function TJVCSGetRevisionListByVersion.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRevisionListByVersion.Get_OutputItems(Index: Integer): IJVCSGetRevisionListByVersionOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRevisionListByVersionOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionStatus private }

procedure TJVCSGetRevisionStatus.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetRevisionStatus.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetRevisionStatus.GetOutputItems(Index: Integer): TGetRevisionStatusOutputItem;
begin
  Result := PGetRevisionStatusOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetRevisionStatus protected }

procedure TJVCSGetRevisionStatus.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FRevisionID]);
    end;
end;

{ TJVCSGetRevisionStatus public }

constructor TJVCSGetRevisionStatus.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetRevisionStatus.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetRevisionStatus.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionStatus) then
    begin
      FRevisionID := TJVCSGetRevisionStatus(Reference).FRevisionID;
      ClearOutputItems;
      for I := 0 to TJVCSGetRevisionStatus(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetRevisionStatusOutputItem));
        try
          with PGetRevisionStatusOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetRevisionStatus(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSGetRevisionStatus(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSGetRevisionStatus(Reference).OutputItems[I].ModulePath;
            CheckedOut := TJVCSGetRevisionStatus(Reference).OutputItems[I].CheckedOut;
            Version := TJVCSGetRevisionStatus(Reference).OutputItems[I].Version;
            Revision := TJVCSGetRevisionStatus(Reference).OutputItems[I].Revision;
            RevisionOriginalTime := TJVCSGetRevisionStatus(Reference).OutputItems[I].RevisionOriginalTime;
            RevisionOriginalSize := TJVCSGetRevisionStatus(Reference).OutputItems[I].RevisionOriginalSize;
            RevisionOriginalCRC := TJVCSGetRevisionStatus(Reference).OutputItems[I].RevisionOriginalCRC;
            RevisionCompressedSize := TJVCSGetRevisionStatus(Reference).OutputItems[I].RevisionCompressedSize;
            RevisionExtension := TJVCSGetRevisionStatus(Reference).OutputItems[I].RevisionExtension;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionStatusOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetRevisionStatus.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetRevisionStatus.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetRevisionStatusOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetRevisionStatusOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetRevisionStatusOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetRevisionStatusOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetRevisionStatusOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[3], 0) <> 0);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetRevisionStatusOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetRevisionStatusOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetRevisionStatusOutputItem(P)^.RevisionOriginalTime := SafeStrToFloat(ResponseBuffer.Fields[6]);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetRevisionStatusOutputItem(P)^.RevisionOriginalSize := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetRevisionStatusOutputItem(P)^.RevisionOriginalCRC := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetRevisionStatusOutputItem(P)^.RevisionCompressedSize := StrToInt64Def(ResponseBuffer.Fields[9], -1);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetRevisionStatusOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[10];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetRevisionStatusOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetRevisionStatusOutputItem.Create(AOwner: TComponent; APtr: PGetRevisionStatusOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetRevisionStatusOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetRevisionStatusOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetRevisionStatusOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetRevisionStatusOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSGetRevisionStatusOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetRevisionStatusOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetRevisionStatusOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetRevisionStatusOutputItem.Get_RevisionOriginalTime: TDateTime; safecall;
begin
  Result := FPtr^.RevisionOriginalTime;
end;

function TJVCSGetRevisionStatusOutputItem.Get_RevisionOriginalSize: Integer; safecall;
begin
  Result := FPtr^.RevisionOriginalSize;
end;

function TJVCSGetRevisionStatusOutputItem.Get_RevisionOriginalCRC: Integer; safecall;
begin
  Result := FPtr^.RevisionOriginalCRC;
end;

function TJVCSGetRevisionStatusOutputItem.Get_RevisionCompressedSize: Integer; safecall;
begin
  Result := FPtr^.RevisionCompressedSize;
end;

function TJVCSGetRevisionStatusOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSGetRevisionStatus.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSGetRevisionStatus.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSGetRevisionStatus.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetRevisionStatus.Get_OutputItems(Index: Integer): IJVCSGetRevisionStatusOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetRevisionStatusOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetRevisionComment protected }

procedure TJVCSGetRevisionComment.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FRevisionID]);
    end;
end;

{ TJVCSGetRevisionComment public }

procedure TJVCSGetRevisionComment.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetRevisionComment) then
    begin
      FRevisionID := TJVCSGetRevisionComment(Reference).FRevisionID;
      FCheckinComment := TJVCSGetRevisionComment(Reference).FCheckinComment;
      FCheckoutComment := TJVCSGetRevisionComment(Reference).FCheckoutComment;
      FVersionState := TJVCSGetRevisionComment(Reference).FVersionState;
    end;
end;

procedure TJVCSGetRevisionComment.Initialize; 
begin
  inherited Initialize;
  FCheckinComment := '';
  FCheckoutComment := '';
  FVersionState := -1;
end;

procedure TJVCSGetRevisionComment.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FCheckinComment := ResponseBuffer.Fields[0];
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FCheckoutComment := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FVersionState := StrToInt64Def(ResponseBuffer.Fields[2], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetRevisionComment.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSGetRevisionComment.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSGetRevisionComment.Get_CheckinComment: WideString; safecall;
begin
  Result := CheckinComment;
end;

function TJVCSGetRevisionComment.Get_CheckoutComment: WideString; safecall;
begin
  Result := CheckoutComment;
end;

function TJVCSGetRevisionComment.Get_VersionState: Integer; safecall;
begin
  Result := VersionState;
end;

{$ENDIF COMVERSION}

{ TJVCSChangeRevisionComment protected }

procedure TJVCSChangeRevisionComment.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FRevisionID]);
      WriteFields(False, [FCommentType]);
      WriteFields(False, [FCommentValue]);
    end;
end;

{ TJVCSChangeRevisionComment public }

procedure TJVCSChangeRevisionComment.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSChangeRevisionComment) then
    begin
      FRevisionID := TJVCSChangeRevisionComment(Reference).FRevisionID;
      FCommentType := TJVCSChangeRevisionComment(Reference).FCommentType;
      FCommentValue := TJVCSChangeRevisionComment(Reference).FCommentValue;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSChangeRevisionComment.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSChangeRevisionComment.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSChangeRevisionComment.Get_CommentType: WideString; safecall;
begin
  Result := CommentType;
end;

procedure TJVCSChangeRevisionComment.Set_CommentType(const Value: WideString); safecall;
begin
  CommentType := Value;
end;

function TJVCSChangeRevisionComment.Get_CommentValue: WideString; safecall;
begin
  Result := CommentValue;
end;

procedure TJVCSChangeRevisionComment.Set_CommentValue(const Value: WideString); safecall;
begin
  CommentValue := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetBlobStatus private }

procedure TJVCSGetBlobStatus.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetBlobStatus.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetBlobStatus.GetOutputItems(Index: Integer): TGetBlobStatusOutputItem;
begin
  Result := PGetBlobStatusOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetBlobStatus protected }

procedure TJVCSGetBlobStatus.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetBlobStatus public }

constructor TJVCSGetBlobStatus.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetBlobStatus.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetBlobStatus.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetBlobStatus) then
    begin
      FModuleID := TJVCSGetBlobStatus(Reference).FModuleID;
      ClearOutputItems;
      for I := 0 to TJVCSGetBlobStatus(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetBlobStatusOutputItem));
        try
          with PGetBlobStatusOutputItem(P)^ do
          begin
            RevisionID := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionID;
            Version := TJVCSGetBlobStatus(Reference).OutputItems[I].Version;
            Revision := TJVCSGetBlobStatus(Reference).OutputItems[I].Revision;
            RevisionOriginalTime := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionOriginalTime;
            RevisionOriginalSize := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionOriginalSize;
            RevisionOriginalCRC := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionOriginalCRC;
            RevisionCompressedSize := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionCompressedSize;
            RevisionExtension := TJVCSGetBlobStatus(Reference).OutputItems[I].RevisionExtension;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBlobStatusOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetBlobStatus.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetBlobStatus.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetBlobStatusOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetBlobStatusOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetBlobStatusOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionOriginalTime := SafeStrToFloat(ResponseBuffer.Fields[3]);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionOriginalSize := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionOriginalCRC := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionCompressedSize := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetBlobStatusOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[7];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBlobStatusOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetBlobStatusOutputItem.Create(AOwner: TComponent; APtr: PGetBlobStatusOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetBlobStatusOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetBlobStatusOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetBlobStatusOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionOriginalTime: TDateTime; safecall;
begin
  Result := FPtr^.RevisionOriginalTime;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionOriginalSize: Integer; safecall;
begin
  Result := FPtr^.RevisionOriginalSize;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionOriginalCRC: Integer; safecall;
begin
  Result := FPtr^.RevisionOriginalCRC;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionCompressedSize: Integer; safecall;
begin
  Result := FPtr^.RevisionCompressedSize;
end;

function TJVCSGetBlobStatusOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSGetBlobStatus.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetBlobStatus.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetBlobStatus.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetBlobStatus.Get_OutputItems(Index: Integer): IJVCSGetBlobStatusOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetBlobStatusOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetModuleHistory private }

procedure TJVCSGetModuleHistory.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetModuleHistoryOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetModuleHistory.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetModuleHistory.GetOutputItems(Index: Integer): TGetModuleHistoryOutputItem;
begin
  Result := PGetModuleHistoryOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetModuleHistory protected }

procedure TJVCSGetModuleHistory.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetModuleHistory public }

constructor TJVCSGetModuleHistory.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetModuleHistory.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetModuleHistory.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetModuleHistory) then
    begin
      FModuleID := TJVCSGetModuleHistory(Reference).FModuleID;
      FModuleDescription := TJVCSGetModuleHistory(Reference).FModuleDescription;
      ClearOutputItems;
      for I := 0 to TJVCSGetModuleHistory(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetModuleHistoryOutputItem));
        try
          with PGetModuleHistoryOutputItem(P)^ do
          begin
            CheckedOut := TJVCSGetModuleHistory(Reference).OutputItems[I].CheckedOut;
            Version := TJVCSGetModuleHistory(Reference).OutputItems[I].Version;
            Revision := TJVCSGetModuleHistory(Reference).OutputItems[I].Revision;
            UserName := TJVCSGetModuleHistory(Reference).OutputItems[I].UserName;
            Timestamp := TJVCSGetModuleHistory(Reference).OutputItems[I].Timestamp;
            Size := TJVCSGetModuleHistory(Reference).OutputItems[I].Size;
            Extension := TJVCSGetModuleHistory(Reference).OutputItems[I].Extension;
            CheckinComment := TJVCSGetModuleHistory(Reference).OutputItems[I].CheckinComment;
            CheckoutComment := TJVCSGetModuleHistory(Reference).OutputItems[I].CheckoutComment;
            RevisionID := TJVCSGetModuleHistory(Reference).OutputItems[I].RevisionID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetModuleHistoryOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetModuleHistory.Initialize; 
begin
  inherited Initialize;
  FModuleDescription := '';
  ClearOutputItems;
end;

procedure TJVCSGetModuleHistory.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleDescription := ResponseBuffer.Fields[0];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetModuleHistoryOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetModuleHistoryOutputItem(P)^.CheckedOut := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetModuleHistoryOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetModuleHistoryOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetModuleHistoryOutputItem(P)^.UserName := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetModuleHistoryOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetModuleHistoryOutputItem(P)^.Size := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetModuleHistoryOutputItem(P)^.Extension := ResponseBuffer.Fields[6];
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetModuleHistoryOutputItem(P)^.CheckinComment := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetModuleHistoryOutputItem(P)^.CheckoutComment := ResponseBuffer.Fields[8];
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetModuleHistoryOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[9], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetModuleHistoryOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetModuleHistoryOutputItem.Create(AOwner: TComponent; APtr: PGetModuleHistoryOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetModuleHistoryOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetModuleHistoryOutputItem.Get_CheckedOut: WordBool; safecall;
begin
  Result := FPtr^.CheckedOut;
end;

function TJVCSGetModuleHistoryOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSGetModuleHistoryOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSGetModuleHistoryOutputItem.Get_UserName: WideString; safecall;
begin
  Result := FPtr^.UserName;
end;

function TJVCSGetModuleHistoryOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetModuleHistoryOutputItem.Get_Size: Integer; safecall;
begin
  Result := FPtr^.Size;
end;

function TJVCSGetModuleHistoryOutputItem.Get_Extension: WideString; safecall;
begin
  Result := FPtr^.Extension;
end;

function TJVCSGetModuleHistoryOutputItem.Get_CheckinComment: WideString; safecall;
begin
  Result := FPtr^.CheckinComment;
end;

function TJVCSGetModuleHistoryOutputItem.Get_CheckoutComment: WideString; safecall;
begin
  Result := FPtr^.CheckoutComment;
end;

function TJVCSGetModuleHistoryOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetModuleHistory.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetModuleHistory.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetModuleHistory.Get_ModuleDescription: WideString; safecall;
begin
  Result := ModuleDescription;
end;

function TJVCSGetModuleHistory.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetModuleHistory.Get_OutputItems(Index: Integer): IJVCSGetModuleHistoryOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetModuleHistoryOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSIsMemberOfProject protected }

procedure TJVCSIsMemberOfProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FModuleFullName]);
    end;
end;

{ TJVCSIsMemberOfProject public }

procedure TJVCSIsMemberOfProject.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSIsMemberOfProject) then
    begin
      FProjectID := TJVCSIsMemberOfProject(Reference).FProjectID;
      FModuleFullName := TJVCSIsMemberOfProject(Reference).FModuleFullName;
      FIsMemberOf := TJVCSIsMemberOfProject(Reference).FIsMemberOf;
      FModuleID := TJVCSIsMemberOfProject(Reference).FModuleID;
    end;
end;

procedure TJVCSIsMemberOfProject.Initialize; 
begin
  inherited Initialize;
  FIsMemberOf := False;
  FModuleID := -1;
end;

procedure TJVCSIsMemberOfProject.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FIsMemberOf := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FModuleID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSIsMemberOfProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSIsMemberOfProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSIsMemberOfProject.Get_ModuleFullName: WideString; safecall;
begin
  Result := ModuleFullName;
end;

procedure TJVCSIsMemberOfProject.Set_ModuleFullName(const Value: WideString); safecall;
begin
  ModuleFullName := Value;
end;

function TJVCSIsMemberOfProject.Get_IsMemberOf: WordBool; safecall;
begin
  Result := IsMemberOf;
end;

function TJVCSIsMemberOfProject.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

{$ENDIF COMVERSION}

{ TJVCSGetSingleBlob protected }

procedure TJVCSGetSingleBlob.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FRevisionID]);
      WriteFields(False, [FExtension]);
    end;
end;

{ TJVCSGetSingleBlob public }

constructor TJVCSGetSingleBlob.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FModuleBinary := TMemoryStream.Create;
  {$IFDEF COMVERSION}
  FModuleBinaryStreamAdapter := TJVCSStreamAdapter.Create(Self, FModuleBinary);
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetSingleBlob.Destroy;
begin
  {$IFDEF COMVERSION}
  FModuleBinaryStreamAdapter.Free;
  {$ENDIF COMVERSION}
  FModuleBinary.Free;
  inherited Destroy;
end;

procedure TJVCSGetSingleBlob.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSingleBlob) then
    begin
      FRevisionID := TJVCSGetSingleBlob(Reference).FRevisionID;
      FExtension := TJVCSGetSingleBlob(Reference).FExtension;
      FModuleOriginalTime := TJVCSGetSingleBlob(Reference).FModuleOriginalTime;
      FModuleOriginalSize := TJVCSGetSingleBlob(Reference).FModuleOriginalSize;
      FModuleOriginalCRC := TJVCSGetSingleBlob(Reference).FModuleOriginalCRC;
      FModuleCompressedSize := TJVCSGetSingleBlob(Reference).FModuleCompressedSize;
      FModuleExtension := TJVCSGetSingleBlob(Reference).FModuleExtension;
      FModuleBinary.Clear;
      FModuleBinary.CopyFrom(TJVCSGetSingleBlob(Reference).FModuleBinary, 0);
      FModuleBinary.Seek(0, soFromBeginning);
    end;
end;

procedure TJVCSGetSingleBlob.Initialize; 
begin
  inherited Initialize;
  FModuleOriginalTime := 0;
  FModuleOriginalSize := -1;
  FModuleOriginalCRC := -1;
  FModuleCompressedSize := -1;
  FModuleExtension := '';
  FModuleBinary.Clear;
end;

procedure TJVCSGetSingleBlob.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  FieldType: TMWFieldType;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleOriginalTime := SafeStrToFloat(ResponseBuffer.Fields[0]);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FModuleOriginalSize := StrToInt64Def(ResponseBuffer.Fields[1], -1);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FModuleOriginalCRC := StrToInt64Def(ResponseBuffer.Fields[2], -1);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FModuleCompressedSize := StrToInt64Def(ResponseBuffer.Fields[3], -1);
      if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
        FModuleExtension := ResponseBuffer.Fields[4];
      if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwBlob) then
      begin
        FieldType := mwBlob;
        FModuleBinary.Clear;
        ResponseBuffer.GetStreamField(5, FModuleBinary, FieldType);
        FModuleBinary.Seek(0, soFromBeginning);
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetSingleBlob.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSGetSingleBlob.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSGetSingleBlob.Get_Extension: WideString; safecall;
begin
  Result := Extension;
end;

procedure TJVCSGetSingleBlob.Set_Extension(const Value: WideString); safecall;
begin
  Extension := Value;
end;

function TJVCSGetSingleBlob.Get_ModuleOriginalTime: TDateTime; safecall;
begin
  Result := ModuleOriginalTime;
end;

function TJVCSGetSingleBlob.Get_ModuleOriginalSize: Integer; safecall;
begin
  Result := ModuleOriginalSize;
end;

function TJVCSGetSingleBlob.Get_ModuleOriginalCRC: Integer; safecall;
begin
  Result := ModuleOriginalCRC;
end;

function TJVCSGetSingleBlob.Get_ModuleCompressedSize: Integer; safecall;
begin
  Result := ModuleCompressedSize;
end;

function TJVCSGetSingleBlob.Get_ModuleExtension: WideString; safecall;
begin
  Result := ModuleExtension;
end;

function TJVCSGetSingleBlob.Get_ModuleBinary: IJVCSReadonlyStream; safecall;
begin
  Result := FModuleBinaryStreamAdapter;
end;

{$ENDIF COMVERSION}

{ TJVCSGetSharedModules private }

procedure TJVCSGetSharedModules.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetSharedModules.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetSharedModules.GetOutputItems(Index: Integer): TGetSharedModulesOutputItem;
begin
  Result := PGetSharedModulesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetSharedModules public }

constructor TJVCSGetSharedModules.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetSharedModules.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetSharedModules.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetSharedModules) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetSharedModules(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetSharedModulesOutputItem));
        try
          with PGetSharedModulesOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetSharedModules(Reference).OutputItems[I].ModuleID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSharedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetSharedModules.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetSharedModules.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetSharedModulesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetSharedModulesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetSharedModulesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetSharedModulesOutputItem.Create(AOwner: TComponent; APtr: PGetSharedModulesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetSharedModulesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetSharedModulesOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetSharedModules.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetSharedModules.Get_OutputItems(Index: Integer): IJVCSGetSharedModulesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetSharedModulesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddNewModule private }

procedure TJVCSAddNewModule.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSAddNewModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSAddNewModule.GetOutputItems(Index: Integer): TAddNewModuleOutputItem;
begin
  Result := PAddNewModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSAddNewModule protected }

procedure TJVCSAddNewModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleFullName]);
      WriteFields(False, [FFlags]);
      WriteFields(False, [FDescription]);
    end;
end;

{ TJVCSAddNewModule public }

constructor TJVCSAddNewModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSAddNewModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSAddNewModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddNewModule) then
    begin
      FProjectID := TJVCSAddNewModule(Reference).FProjectID;
      FUserID := TJVCSAddNewModule(Reference).FUserID;
      FModuleFullName := TJVCSAddNewModule(Reference).FModuleFullName;
      FFlags := TJVCSAddNewModule(Reference).FFlags;
      FDescription := TJVCSAddNewModule(Reference).FDescription;
      FIsNewModule := TJVCSAddNewModule(Reference).FIsNewModule;
      FModuleID := TJVCSAddNewModule(Reference).FModuleID;
      ClearOutputItems;
      for I := 0 to TJVCSAddNewModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TAddNewModuleOutputItem));
        try
          with PAddNewModuleOutputItem(P)^ do
          begin
            ProjectID := TJVCSAddNewModule(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSAddNewModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSAddNewModule.Initialize; 
begin
  inherited Initialize;
  FIsNewModule := False;
  FModuleID := -1;
  ClearOutputItems;
end;

procedure TJVCSAddNewModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FIsNewModule := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FModuleID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TAddNewModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PAddNewModuleOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSAddNewModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSAddNewModuleOutputItem.Create(AOwner: TComponent; APtr: PAddNewModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSAddNewModuleOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSAddNewModuleOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSAddNewModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSAddNewModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSAddNewModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSAddNewModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSAddNewModule.Get_ModuleFullName: WideString; safecall;
begin
  Result := ModuleFullName;
end;

procedure TJVCSAddNewModule.Set_ModuleFullName(const Value: WideString); safecall;
begin
  ModuleFullName := Value;
end;

function TJVCSAddNewModule.Get_Flags: Integer; safecall;
begin
  Result := Flags;
end;

procedure TJVCSAddNewModule.Set_Flags(Value: Integer); safecall;
begin
  Flags := Value;
end;

function TJVCSAddNewModule.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAddNewModule.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

function TJVCSAddNewModule.Get_IsNewModule: WordBool; safecall;
begin
  Result := IsNewModule;
end;

function TJVCSAddNewModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

function TJVCSAddNewModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSAddNewModule.Get_OutputItems(Index: Integer): IJVCSAddNewModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSAddNewModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveModule private }

procedure TJVCSRemoveModule.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSRemoveModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSRemoveModule.GetOutputItems(Index: Integer): TRemoveModuleOutputItem;
begin
  Result := PRemoveModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSRemoveModule protected }

procedure TJVCSRemoveModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FRemoveFromArchive]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSRemoveModule public }

constructor TJVCSRemoveModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRemoveModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSRemoveModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveModule) then
    begin
      FProjectID := TJVCSRemoveModule(Reference).FProjectID;
      FUserID := TJVCSRemoveModule(Reference).FUserID;
      FModuleID := TJVCSRemoveModule(Reference).FModuleID;
      FRemoveFromArchive := TJVCSRemoveModule(Reference).FRemoveFromArchive;
      FModuleName := TJVCSRemoveModule(Reference).FModuleName;
      FModuleRemoved := TJVCSRemoveModule(Reference).FModuleRemoved;
      ClearOutputItems;
      for I := 0 to TJVCSRemoveModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRemoveModuleOutputItem));
        try
          with PRemoveModuleOutputItem(P)^ do
          begin
            ProjectID := TJVCSRemoveModule(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSRemoveModule.Initialize; 
begin
  inherited Initialize;
  FModuleRemoved := False;
  ClearOutputItems;
end;

procedure TJVCSRemoveModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TRemoveModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PRemoveModuleOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRemoveModuleOutputItem.Create(AOwner: TComponent; APtr: PRemoveModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRemoveModuleOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRemoveModuleOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSRemoveModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRemoveModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSRemoveModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSRemoveModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSRemoveModule.Get_RemoveFromArchive: WordBool; safecall;
begin
  Result := RemoveFromArchive;
end;

procedure TJVCSRemoveModule.Set_RemoveFromArchive(Value: WordBool); safecall;
begin
  RemoveFromArchive := Value;
end;

function TJVCSRemoveModule.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSRemoveModule.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSRemoveModule.Get_ModuleRemoved: WordBool; safecall;
begin
  Result := ModuleRemoved;
end;

function TJVCSRemoveModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSRemoveModule.Get_OutputItems(Index: Integer): IJVCSRemoveModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSRemoveModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveRevision private }

procedure TJVCSRemoveRevision.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSRemoveRevision.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSRemoveRevision.GetOutputItems(Index: Integer): TRemoveRevisionOutputItem;
begin
  Result := PRemoveRevisionOutputItem(FOutputItems[Index])^;
end;

{ TJVCSRemoveRevision protected }

procedure TJVCSRemoveRevision.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FRevisionID]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSRemoveRevision public }

constructor TJVCSRemoveRevision.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRemoveRevision.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSRemoveRevision.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveRevision) then
    begin
      FProjectID := TJVCSRemoveRevision(Reference).FProjectID;
      FUserID := TJVCSRemoveRevision(Reference).FUserID;
      FModuleID := TJVCSRemoveRevision(Reference).FModuleID;
      FRevisionID := TJVCSRemoveRevision(Reference).FRevisionID;
      FModuleName := TJVCSRemoveRevision(Reference).FModuleName;
      FRevisionRemoved := TJVCSRemoveRevision(Reference).FRevisionRemoved;
      ClearOutputItems;
      for I := 0 to TJVCSRemoveRevision(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRemoveRevisionOutputItem));
        try
          with PRemoveRevisionOutputItem(P)^ do
          begin
            ProjectID := TJVCSRemoveRevision(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSRemoveRevision.Initialize; 
begin
  inherited Initialize;
  FRevisionRemoved := False;
  ClearOutputItems;
end;

procedure TJVCSRemoveRevision.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FRevisionRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TRemoveRevisionOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PRemoveRevisionOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRemoveRevisionOutputItem.Create(AOwner: TComponent; APtr: PRemoveRevisionOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRemoveRevisionOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRemoveRevisionOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSRemoveRevision.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveRevision.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveRevision.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRemoveRevision.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSRemoveRevision.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSRemoveRevision.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSRemoveRevision.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSRemoveRevision.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSRemoveRevision.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSRemoveRevision.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSRemoveRevision.Get_RevisionRemoved: WordBool; safecall;
begin
  Result := RevisionRemoved;
end;

function TJVCSRemoveRevision.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSRemoveRevision.Get_OutputItems(Index: Integer): IJVCSRemoveRevisionOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSRemoveRevisionOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveVersion private }

procedure TJVCSRemoveVersion.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSRemoveVersion.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSRemoveVersion.GetOutputItems(Index: Integer): TRemoveVersionOutputItem;
begin
  Result := PRemoveVersionOutputItem(FOutputItems[Index])^;
end;

{ TJVCSRemoveVersion protected }

procedure TJVCSRemoveVersion.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FVersion]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSRemoveVersion public }

constructor TJVCSRemoveVersion.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRemoveVersion.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSRemoveVersion.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveVersion) then
    begin
      FProjectID := TJVCSRemoveVersion(Reference).FProjectID;
      FUserID := TJVCSRemoveVersion(Reference).FUserID;
      FModuleID := TJVCSRemoveVersion(Reference).FModuleID;
      FVersion := TJVCSRemoveVersion(Reference).FVersion;
      FModuleName := TJVCSRemoveVersion(Reference).FModuleName;
      FVersionRemoved := TJVCSRemoveVersion(Reference).FVersionRemoved;
      ClearOutputItems;
      for I := 0 to TJVCSRemoveVersion(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRemoveVersionOutputItem));
        try
          with PRemoveVersionOutputItem(P)^ do
          begin
            ProjectID := TJVCSRemoveVersion(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveVersionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSRemoveVersion.Initialize; 
begin
  inherited Initialize;
  FVersionRemoved := False;
  ClearOutputItems;
end;

procedure TJVCSRemoveVersion.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FVersionRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TRemoveVersionOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PRemoveVersionOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSRemoveVersionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRemoveVersionOutputItem.Create(AOwner: TComponent; APtr: PRemoveVersionOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRemoveVersionOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRemoveVersionOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSRemoveVersion.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveVersion.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveVersion.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRemoveVersion.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSRemoveVersion.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSRemoveVersion.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSRemoveVersion.Get_Version: Integer; safecall;
begin
  Result := Version;
end;

procedure TJVCSRemoveVersion.Set_Version(Value: Integer); safecall;
begin
  Version := Value;
end;

function TJVCSRemoveVersion.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSRemoveVersion.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSRemoveVersion.Get_VersionRemoved: WordBool; safecall;
begin
  Result := VersionRemoved;
end;

function TJVCSRemoveVersion.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSRemoveVersion.Get_OutputItems(Index: Integer): IJVCSRemoveVersionOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSRemoveVersionOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSMoveModule private }

procedure TJVCSMoveModule.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSMoveModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSMoveModule.GetOutputItems(Index: Integer): TMoveModuleOutputItem;
begin
  Result := PMoveModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSMoveModule protected }

procedure TJVCSMoveModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FNewModulePath]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSMoveModule public }

constructor TJVCSMoveModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSMoveModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSMoveModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSMoveModule) then
    begin
      FProjectID := TJVCSMoveModule(Reference).FProjectID;
      FUserID := TJVCSMoveModule(Reference).FUserID;
      FModuleID := TJVCSMoveModule(Reference).FModuleID;
      FNewModulePath := TJVCSMoveModule(Reference).FNewModulePath;
      FModuleName := TJVCSMoveModule(Reference).FModuleName;
      FModuleMoved := TJVCSMoveModule(Reference).FModuleMoved;
      FErrorMessage := TJVCSMoveModule(Reference).FErrorMessage;
      ClearOutputItems;
      for I := 0 to TJVCSMoveModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TMoveModuleOutputItem));
        try
          with PMoveModuleOutputItem(P)^ do
          begin
            ProjectID := TJVCSMoveModule(Reference).OutputItems[I].ProjectID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSMoveModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSMoveModule.Initialize; 
begin
  inherited Initialize;
  FModuleMoved := False;
  FErrorMessage := '';
  ClearOutputItems;
end;

procedure TJVCSMoveModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FModuleMoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TMoveModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PMoveModuleOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSMoveModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSMoveModuleOutputItem.Create(AOwner: TComponent; APtr: PMoveModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSMoveModuleOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSMoveModuleOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSMoveModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSMoveModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSMoveModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSMoveModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSMoveModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSMoveModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSMoveModule.Get_NewModulePath: WideString; safecall;
begin
  Result := NewModulePath;
end;

procedure TJVCSMoveModule.Set_NewModulePath(const Value: WideString); safecall;
begin
  NewModulePath := Value;
end;

function TJVCSMoveModule.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSMoveModule.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSMoveModule.Get_ModuleMoved: WordBool; safecall;
begin
  Result := ModuleMoved;
end;

function TJVCSMoveModule.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

function TJVCSMoveModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSMoveModule.Get_OutputItems(Index: Integer): IJVCSMoveModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSMoveModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetCheckoutModule private }

procedure TJVCSGetCheckoutModule.ClearOutputItems;
var
  I: Integer;
  Item: TGetCheckoutModuleOutputItem;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Item := PGetCheckoutModuleOutputItem(FOutputItems[I])^;
    Item.ModuleBinary.Free;
    Item.ModuleBinary := nil;
  end;
  FOutputItems.Clear;
end;

function TJVCSGetCheckoutModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetCheckoutModule.GetOutputItems(Index: Integer): TGetCheckoutModuleOutputItem;
begin
  Result := PGetCheckoutModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetCheckoutModule protected }

procedure TJVCSGetCheckoutModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FRevisionID]);
      WriteFields(False, [FCheckOut]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSGetCheckoutModule public }

constructor TJVCSGetCheckoutModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetCheckoutModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetCheckoutModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetCheckoutModule) then
    begin
      FProjectID := TJVCSGetCheckoutModule(Reference).FProjectID;
      FUserID := TJVCSGetCheckoutModule(Reference).FUserID;
      FModuleID := TJVCSGetCheckoutModule(Reference).FModuleID;
      FRevisionID := TJVCSGetCheckoutModule(Reference).FRevisionID;
      FCheckOut := TJVCSGetCheckoutModule(Reference).FCheckOut;
      FModuleName := TJVCSGetCheckoutModule(Reference).FModuleName;
      FCheckoutAllowed := TJVCSGetCheckoutModule(Reference).FCheckoutAllowed;
      FOwner := TJVCSGetCheckoutModule(Reference).FOwner;
      ClearOutputItems;
      for I := 0 to TJVCSGetCheckoutModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetCheckoutModuleOutputItem));
        try
          with PGetCheckoutModuleOutputItem(P)^ do
          begin
            ModuleOriginalTime := TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleOriginalTime;
            ModuleOriginalSize := TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleOriginalSize;
            ModuleOriginalCRC := TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleOriginalCRC;
            ModuleCompressedSize := TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleCompressedSize;
            ModuleExtension := TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleExtension;
            ModuleBinary := TMemoryStream.Create;
            try
              if Assigned(TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleBinary) then
                ModuleBinary.CopyFrom(TJVCSGetCheckoutModule(Reference).OutputItems[I].ModuleBinary, 0);
              ModuleBinary.Seek(0, soFromBeginning);
            except
              ModuleBinary.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetCheckoutModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetCheckoutModule.Initialize; 
begin
  inherited Initialize;
  FCheckoutAllowed := False;
  FOwner := '';
  ClearOutputItems;
end;

procedure TJVCSGetCheckoutModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  FieldType: TMWFieldType;
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FCheckoutAllowed := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FOwner := ResponseBuffer.Fields[1];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetCheckoutModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetCheckoutModuleOutputItem(P)^.ModuleOriginalTime := SafeStrToFloat(ResponseBuffer.Fields[0]);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetCheckoutModuleOutputItem(P)^.ModuleOriginalSize := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetCheckoutModuleOutputItem(P)^.ModuleOriginalCRC := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetCheckoutModuleOutputItem(P)^.ModuleCompressedSize := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetCheckoutModuleOutputItem(P)^.ModuleExtension := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwBlob) then
          begin
            PGetCheckoutModuleOutputItem(P)^.ModuleBinary := TMemoryStream.Create;
            try
              PGetCheckoutModuleOutputItem(P)^.ModuleBinary.Clear;
              ResponseBuffer.GetStreamField(5, PGetCheckoutModuleOutputItem(P)^.ModuleBinary, FieldType);
              PGetCheckoutModuleOutputItem(P)^.ModuleBinary.Seek(0, soFromBeginning);
            except
              PGetCheckoutModuleOutputItem(P)^.ModuleBinary.Free;
              raise;
            end;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetCheckoutModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetCheckoutModuleOutputItem.Create(AOwner: TComponent; APtr: PGetCheckoutModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
  FModuleBinaryStreamAdapter := TJVCSStreamAdapter.Create(Self, nil);
end;

destructor TJVCSGetCheckoutModuleOutputItem.Destroy;
begin
  FModuleBinaryStreamAdapter.Free;
  inherited Destroy;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleOriginalTime: TDateTime; safecall;
begin
  Result := FPtr^.ModuleOriginalTime;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleOriginalSize: Integer; safecall;
begin
  Result := FPtr^.ModuleOriginalSize;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleOriginalCRC: Integer; safecall;
begin
  Result := FPtr^.ModuleOriginalCRC;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleCompressedSize: Integer; safecall;
begin
  Result := FPtr^.ModuleCompressedSize;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleExtension: WideString; safecall;
begin
  Result := FPtr^.ModuleExtension;
end;

function TJVCSGetCheckoutModuleOutputItem.Get_ModuleBinary: IJVCSReadonlyStream; safecall;
begin
  FModuleBinaryStreamAdapter.Stream := FPtr^.ModuleBinary;
  Result := FModuleBinaryStreamAdapter;
end;

function TJVCSGetCheckoutModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetCheckoutModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetCheckoutModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSGetCheckoutModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSGetCheckoutModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetCheckoutModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetCheckoutModule.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSGetCheckoutModule.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSGetCheckoutModule.Get_CheckOut: WordBool; safecall;
begin
  Result := CheckOut;
end;

procedure TJVCSGetCheckoutModule.Set_CheckOut(Value: WordBool); safecall;
begin
  CheckOut := Value;
end;

function TJVCSGetCheckoutModule.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSGetCheckoutModule.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSGetCheckoutModule.Get_CheckoutAllowed: WordBool; safecall;
begin
  Result := CheckoutAllowed;
end;

function TJVCSGetCheckoutModule.Get_Owner: WideString; safecall;
begin
  Result := Owner;
end;

function TJVCSGetCheckoutModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetCheckoutModule.Get_OutputItems(Index: Integer): IJVCSGetCheckoutModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetCheckoutModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSCheckoutOnlyModule private }

procedure TJVCSCheckoutOnlyModule.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSCheckoutOnlyModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSCheckoutOnlyModule.GetOutputItems(Index: Integer): TCheckoutOnlyModuleOutputItem;
begin
  Result := PCheckoutOnlyModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSCheckoutOnlyModule protected }

procedure TJVCSCheckoutOnlyModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FRevisionID]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSCheckoutOnlyModule public }

constructor TJVCSCheckoutOnlyModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSCheckoutOnlyModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSCheckoutOnlyModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSCheckoutOnlyModule) then
    begin
      FProjectID := TJVCSCheckoutOnlyModule(Reference).FProjectID;
      FUserID := TJVCSCheckoutOnlyModule(Reference).FUserID;
      FModuleID := TJVCSCheckoutOnlyModule(Reference).FModuleID;
      FRevisionID := TJVCSCheckoutOnlyModule(Reference).FRevisionID;
      FModuleName := TJVCSCheckoutOnlyModule(Reference).FModuleName;
      FCheckoutAllowed := TJVCSCheckoutOnlyModule(Reference).FCheckoutAllowed;
      FOwner := TJVCSCheckoutOnlyModule(Reference).FOwner;
      ClearOutputItems;
      for I := 0 to TJVCSCheckoutOnlyModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TCheckoutOnlyModuleOutputItem));
        try
          with PCheckoutOnlyModuleOutputItem(P)^ do
          begin
            ModuleExtension := TJVCSCheckoutOnlyModule(Reference).OutputItems[I].ModuleExtension;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSCheckoutOnlyModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSCheckoutOnlyModule.Initialize; 
begin
  inherited Initialize;
  FCheckoutAllowed := False;
  FOwner := '';
  ClearOutputItems;
end;

procedure TJVCSCheckoutOnlyModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FCheckoutAllowed := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FOwner := ResponseBuffer.Fields[1];
    end;
    ResponseBuffer.Next;
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TCheckoutOnlyModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PCheckoutOnlyModuleOutputItem(P)^.ModuleExtension := ResponseBuffer.Fields[0];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSCheckoutOnlyModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSCheckoutOnlyModuleOutputItem.Create(AOwner: TComponent; APtr: PCheckoutOnlyModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSCheckoutOnlyModuleOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSCheckoutOnlyModuleOutputItem.Get_ModuleExtension: WideString; safecall;
begin
  Result := FPtr^.ModuleExtension;
end;

function TJVCSCheckoutOnlyModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSCheckoutOnlyModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSCheckoutOnlyModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSCheckoutOnlyModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSCheckoutOnlyModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSCheckoutOnlyModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSCheckoutOnlyModule.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSCheckoutOnlyModule.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSCheckoutOnlyModule.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSCheckoutOnlyModule.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSCheckoutOnlyModule.Get_CheckoutAllowed: WordBool; safecall;
begin
  Result := CheckoutAllowed;
end;

function TJVCSCheckoutOnlyModule.Get_Owner: WideString; safecall;
begin
  Result := Owner;
end;

function TJVCSCheckoutOnlyModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSCheckoutOnlyModule.Get_OutputItems(Index: Integer): IJVCSCheckoutOnlyModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSCheckoutOnlyModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSUndoCheckoutModule protected }

procedure TJVCSUndoCheckoutModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FModuleName]);
    end;
end;

{ TJVCSUndoCheckoutModule public }

procedure TJVCSUndoCheckoutModule.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSUndoCheckoutModule) then
    begin
      FProjectID := TJVCSUndoCheckoutModule(Reference).FProjectID;
      FUserID := TJVCSUndoCheckoutModule(Reference).FUserID;
      FModuleID := TJVCSUndoCheckoutModule(Reference).FModuleID;
      FModuleName := TJVCSUndoCheckoutModule(Reference).FModuleName;
      FUndoCheckoutAllowed := TJVCSUndoCheckoutModule(Reference).FUndoCheckoutAllowed;
      FOwner := TJVCSUndoCheckoutModule(Reference).FOwner;
      FErrorMessage := TJVCSUndoCheckoutModule(Reference).FErrorMessage;
    end;
end;

procedure TJVCSUndoCheckoutModule.Initialize; 
begin
  inherited Initialize;
  FUndoCheckoutAllowed := False;
  FOwner := '';
  FErrorMessage := '';
end;

procedure TJVCSUndoCheckoutModule.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FUndoCheckoutAllowed := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FOwner := ResponseBuffer.Fields[1];
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[2];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSUndoCheckoutModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSUndoCheckoutModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSUndoCheckoutModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSUndoCheckoutModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSUndoCheckoutModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSUndoCheckoutModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSUndoCheckoutModule.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSUndoCheckoutModule.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSUndoCheckoutModule.Get_UndoCheckoutAllowed: WordBool; safecall;
begin
  Result := UndoCheckoutAllowed;
end;

function TJVCSUndoCheckoutModule.Get_Owner: WideString; safecall;
begin
  Result := Owner;
end;

function TJVCSUndoCheckoutModule.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSCheckinModule private }

procedure TJVCSCheckinModule.ClearInputItems;
var
  I: Integer;
  Item: TCheckinModuleInputItem;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
  begin
    Item := PCheckinModuleInputItem(FInputItems[I])^;
    Item.ModuleBinary.Free;
    Item.ModuleBinary := nil;
    Finalize(PCheckinModuleInputItem(FInputItems[I])^);
    FreeMem(FInputItems[I]);
  end;
  FInputItems.Clear;
end;

function TJVCSCheckinModule.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSCheckinModule.GetInputItems(Index: Integer): TCheckinModuleInputItem;
begin
  Result := PCheckinModuleInputItem(FInputItems[Index])^;
end;

{ TJVCSCheckinModule protected }

procedure TJVCSCheckinModule.DoExecute;
var
  I: Integer;
  nAutoExpand: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(False, [FPutOnly]);
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [ProjectID]);
          WriteFields(False, [UserID]);
          WriteFields(False, [ModuleID]);
          WriteFields(False, [LabelID]);
          WriteFields(False, [OldRevisionID]);
          WriteFields(False, [ModuleVersion]);
          WriteFields(False, [ModuleRevision]);
          WriteFields(False, [ModuleOriginalTime]);
          WriteFields(False, [ModuleOriginalSize]);
          WriteFields(False, [ModuleOriginalCRC]);
          WriteFields(False, [ModuleCompressedSize]);
          WriteFields(False, [ModuleExtension]);
          nAutoExpand := AutoExpand;
          AutoExpand := ModuleBinary.Size + (ModuleBinary.Size div 4) + 256;
          try
            WriteStreamField(False, mwBlob, ModuleBinary);
          finally
            AutoExpand := nAutoExpand;
          end;
          WriteFields(False, [CheckinComment]);
          WriteFields(False, [IDEVersion]);
          WriteFields(False, [ModuleName]);
          WriteFields(False, [FamilyID]);
        end;
    end;
end;

{ TJVCSCheckinModule public }

constructor TJVCSCheckinModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSCheckinModule.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSCheckinModule.AddInputItem(AProjectID: Integer; AUserID: Integer; AModuleID: Integer; ALabelID: Integer; AOldRevisionID: Integer; AModuleVersion: Integer; AModuleRevision: Integer; AModuleOriginalTime: TDateTime; AModuleOriginalSize: Integer; AModuleOriginalCRC: Integer; AModuleCompressedSize: Integer; const AModuleExtension: string; AModuleBinary: TStream; const ACheckinComment: string; AIDEVersion: Integer; const AModuleName: string; AFamilyID: Integer): Integer;
var
  P: PCheckinModuleInputItem;
begin
  P := AllocMem(SizeOf(TCheckinModuleInputItem));
  try
    P^.ProjectID := AProjectID;
    P^.UserID := AUserID;
    P^.ModuleID := AModuleID;
    P^.LabelID := ALabelID;
    P^.OldRevisionID := AOldRevisionID;
    P^.ModuleVersion := AModuleVersion;
    P^.ModuleRevision := AModuleRevision;
    P^.ModuleOriginalTime := AModuleOriginalTime;
    P^.ModuleOriginalSize := AModuleOriginalSize;
    P^.ModuleOriginalCRC := AModuleOriginalCRC;
    P^.ModuleCompressedSize := AModuleCompressedSize;
    P^.ModuleExtension := AModuleExtension;
    P^.ModuleBinary := TMemoryStream.Create;
    try
      P^.ModuleBinary.CopyFrom(AModuleBinary, 0);
      P^.ModuleBinary.Seek(0, soFromBeginning);
    except
      P^.ModuleBinary.Free;
      raise;
    end;
    P^.CheckinComment := ACheckinComment;
    P^.IDEVersion := AIDEVersion;
    P^.ModuleName := AModuleName;
    P^.FamilyID := AFamilyID;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSCheckinModuleInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSCheckinModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSCheckinModule) then
    begin
      FPutOnly := TJVCSCheckinModule(Reference).FPutOnly;
      ClearInputItems;
      for I := 0 to TJVCSCheckinModule(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TCheckinModuleInputItem));
        try
          with PCheckinModuleInputItem(P)^ do
          begin
            ProjectID := TJVCSCheckinModule(Reference).InputItems[I].ProjectID;
            UserID := TJVCSCheckinModule(Reference).InputItems[I].UserID;
            ModuleID := TJVCSCheckinModule(Reference).InputItems[I].ModuleID;
            LabelID := TJVCSCheckinModule(Reference).InputItems[I].LabelID;
            OldRevisionID := TJVCSCheckinModule(Reference).InputItems[I].OldRevisionID;
            ModuleVersion := TJVCSCheckinModule(Reference).InputItems[I].ModuleVersion;
            ModuleRevision := TJVCSCheckinModule(Reference).InputItems[I].ModuleRevision;
            ModuleOriginalTime := TJVCSCheckinModule(Reference).InputItems[I].ModuleOriginalTime;
            ModuleOriginalSize := TJVCSCheckinModule(Reference).InputItems[I].ModuleOriginalSize;
            ModuleOriginalCRC := TJVCSCheckinModule(Reference).InputItems[I].ModuleOriginalCRC;
            ModuleCompressedSize := TJVCSCheckinModule(Reference).InputItems[I].ModuleCompressedSize;
            ModuleExtension := TJVCSCheckinModule(Reference).InputItems[I].ModuleExtension;
            ModuleBinary := TMemoryStream.Create;
            try
              if Assigned(TJVCSCheckinModule(Reference).InputItems[I].ModuleBinary) then
                ModuleBinary.CopyFrom(TJVCSCheckinModule(Reference).InputItems[I].ModuleBinary, 0);
              ModuleBinary.Seek(0, soFromBeginning);
            except
              ModuleBinary.Free;
              raise;
            end;
            CheckinComment := TJVCSCheckinModule(Reference).InputItems[I].CheckinComment;
            IDEVersion := TJVCSCheckinModule(Reference).InputItems[I].IDEVersion;
            ModuleName := TJVCSCheckinModule(Reference).InputItems[I].ModuleName;
            FamilyID := TJVCSCheckinModule(Reference).InputItems[I].FamilyID;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSCheckinModuleInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
      FCheckinAllowed := TJVCSCheckinModule(Reference).FCheckinAllowed;
      FErrorMessage := TJVCSCheckinModule(Reference).FErrorMessage;
    end;
end;

procedure TJVCSCheckinModule.Initialize; 
begin
  inherited Initialize;
  FCheckinAllowed := False;
  FErrorMessage := '';
end;

procedure TJVCSCheckinModule.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FCheckinAllowed := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[1];
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSCheckinModuleInputItem.Create(AOwner: TComponent; APtr: PCheckinModuleInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
  FModuleBinaryStreamAdapter := TJVCSStreamAdapter.Create(Self, nil);
end;

destructor TJVCSCheckinModuleInputItem.Destroy;
begin
  FModuleBinaryStreamAdapter.Free;
  inherited Destroy;
end;

function TJVCSCheckinModuleInputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSCheckinModuleInputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSCheckinModuleInputItem.Get_LabelID: Integer; safecall;
begin
  Result := FPtr^.LabelID;
end;

function TJVCSCheckinModuleInputItem.Get_OldRevisionID: Integer; safecall;
begin
  Result := FPtr^.OldRevisionID;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleVersion: Integer; safecall;
begin
  Result := FPtr^.ModuleVersion;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleRevision: Integer; safecall;
begin
  Result := FPtr^.ModuleRevision;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleOriginalTime: TDateTime; safecall;
begin
  Result := FPtr^.ModuleOriginalTime;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleOriginalSize: Integer; safecall;
begin
  Result := FPtr^.ModuleOriginalSize;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleOriginalCRC: Integer; safecall;
begin
  Result := FPtr^.ModuleOriginalCRC;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleCompressedSize: Integer; safecall;
begin
  Result := FPtr^.ModuleCompressedSize;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleExtension: WideString; safecall;
begin
  Result := FPtr^.ModuleExtension;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleBinary: IJVCSReadonlyStream; safecall;
begin
  FModuleBinaryStreamAdapter.Stream := FPtr^.ModuleBinary;
  Result := FModuleBinaryStreamAdapter;
end;

function TJVCSCheckinModuleInputItem.Get_CheckinComment: WideString; safecall;
begin
  Result := FPtr^.CheckinComment;
end;

function TJVCSCheckinModuleInputItem.Get_IDEVersion: Integer; safecall;
begin
  Result := FPtr^.IDEVersion;
end;

function TJVCSCheckinModuleInputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSCheckinModuleInputItem.Get_FamilyID: Integer; safecall;
begin
  Result := FPtr^.FamilyID;
end;

function TJVCSCheckinModule.Get_PutOnly: WordBool; safecall;
begin
  Result := PutOnly;
end;

procedure TJVCSCheckinModule.Set_PutOnly(Value: WordBool); safecall;
begin
  PutOnly := Value;
end;

function TJVCSCheckinModule.COMAddInputItem(AProjectID: Integer; AUserID: Integer; AModuleID: Integer; ALabelID: Integer; AOldRevisionID: Integer; AModuleVersion: Integer; AModuleRevision: Integer; AModuleOriginalTime: TDateTime; AModuleOriginalSize: Integer; AModuleOriginalCRC: Integer; AModuleCompressedSize: Integer; const AModuleExtension: WideString; const AModuleBinary: IJVCSReadonlyStream; const ACheckinComment: WideString; AIDEVersion: Integer; const AModuleName: WideString; AFamilyID: Integer): Integer; safecall;
var
  ModuleBinaryStream: TMemoryStream;
begin
  ModuleBinaryStream := TMemoryStream.Create;
  try
    CopyFromIJVCSStream(ModuleBinaryStream, AModuleBinary);
    Result := AddInputItem(AProjectID, AUserID, AModuleID, ALabelID, AOldRevisionID, AModuleVersion, AModuleRevision, AModuleOriginalTime, AModuleOriginalSize, AModuleOriginalCRC, AModuleCompressedSize, AModuleExtension, ModuleBinaryStream, ACheckinComment, AIDEVersion, AModuleName, AFamilyID);
  finally
    ModuleBinaryStream.Free;
  end;
end;

function TJVCSCheckinModule.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSCheckinModule.Get_InputItems(Index: Integer): IJVCSCheckinModuleInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSCheckinModuleInputItem, Result);
end;

function TJVCSCheckinModule.Get_CheckinAllowed: WordBool; safecall;
begin
  Result := CheckinAllowed;
end;

function TJVCSCheckinModule.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSHideUnhideModule protected }

procedure TJVCSHideUnhideModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FHide]);
    end;
end;

{ TJVCSHideUnhideModule public }

procedure TJVCSHideUnhideModule.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSHideUnhideModule) then
    begin
      FProjectID := TJVCSHideUnhideModule(Reference).FProjectID;
      FModuleID := TJVCSHideUnhideModule(Reference).FModuleID;
      FUserID := TJVCSHideUnhideModule(Reference).FUserID;
      FHide := TJVCSHideUnhideModule(Reference).FHide;
      FSuccess := TJVCSHideUnhideModule(Reference).FSuccess;
    end;
end;

procedure TJVCSHideUnhideModule.Initialize; 
begin
  inherited Initialize;
  FSuccess := False;
end;

procedure TJVCSHideUnhideModule.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FSuccess := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSHideUnhideModule.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSHideUnhideModule.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSHideUnhideModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSHideUnhideModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSHideUnhideModule.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSHideUnhideModule.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSHideUnhideModule.Get_Hide: WordBool; safecall;
begin
  Result := Hide;
end;

procedure TJVCSHideUnhideModule.Set_Hide(Value: WordBool); safecall;
begin
  Hide := Value;
end;

function TJVCSHideUnhideModule.Get_Success: WordBool; safecall;
begin
  Result := Success;
end;

{$ENDIF COMVERSION}

{ TJVCSCopyRevision protected }

procedure TJVCSCopyRevision.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FSourceRevisionID]);
      WriteFields(False, [FTargetVersion]);
      WriteFields(False, [FTargetRevision]);
      WriteFields(False, [FModuleName]);
      WriteFields(False, [FIDEVersion]);
    end;
end;

{ TJVCSCopyRevision public }

procedure TJVCSCopyRevision.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSCopyRevision) then
    begin
      FProjectID := TJVCSCopyRevision(Reference).FProjectID;
      FUserID := TJVCSCopyRevision(Reference).FUserID;
      FModuleID := TJVCSCopyRevision(Reference).FModuleID;
      FSourceRevisionID := TJVCSCopyRevision(Reference).FSourceRevisionID;
      FTargetVersion := TJVCSCopyRevision(Reference).FTargetVersion;
      FTargetRevision := TJVCSCopyRevision(Reference).FTargetRevision;
      FModuleName := TJVCSCopyRevision(Reference).FModuleName;
      FIDEVersion := TJVCSCopyRevision(Reference).FIDEVersion;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSCopyRevision.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSCopyRevision.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSCopyRevision.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSCopyRevision.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSCopyRevision.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSCopyRevision.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSCopyRevision.Get_SourceRevisionID: Integer; safecall;
begin
  Result := SourceRevisionID;
end;

procedure TJVCSCopyRevision.Set_SourceRevisionID(Value: Integer); safecall;
begin
  SourceRevisionID := Value;
end;

function TJVCSCopyRevision.Get_TargetVersion: Integer; safecall;
begin
  Result := TargetVersion;
end;

procedure TJVCSCopyRevision.Set_TargetVersion(Value: Integer); safecall;
begin
  TargetVersion := Value;
end;

function TJVCSCopyRevision.Get_TargetRevision: Integer; safecall;
begin
  Result := TargetRevision;
end;

procedure TJVCSCopyRevision.Set_TargetRevision(Value: Integer); safecall;
begin
  TargetRevision := Value;
end;

function TJVCSCopyRevision.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSCopyRevision.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSCopyRevision.Get_IDEVersion: Integer; safecall;
begin
  Result := IDEVersion;
end;

procedure TJVCSCopyRevision.Set_IDEVersion(Value: Integer); safecall;
begin
  IDEVersion := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSMergeVerRevNr protected }

procedure TJVCSMergeVerRevNr.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FSourceRevisionID]);
      WriteFields(False, [FTargetVersion]);
      WriteFields(False, [FTargetRevision]);
      WriteFields(False, [FModuleName]);
      WriteFields(False, [FIDEVersion]);
    end;
end;

{ TJVCSMergeVerRevNr public }

procedure TJVCSMergeVerRevNr.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSMergeVerRevNr) then
    begin
      FProjectID := TJVCSMergeVerRevNr(Reference).FProjectID;
      FUserID := TJVCSMergeVerRevNr(Reference).FUserID;
      FModuleID := TJVCSMergeVerRevNr(Reference).FModuleID;
      FSourceRevisionID := TJVCSMergeVerRevNr(Reference).FSourceRevisionID;
      FTargetVersion := TJVCSMergeVerRevNr(Reference).FTargetVersion;
      FTargetRevision := TJVCSMergeVerRevNr(Reference).FTargetRevision;
      FModuleName := TJVCSMergeVerRevNr(Reference).FModuleName;
      FIDEVersion := TJVCSMergeVerRevNr(Reference).FIDEVersion;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSMergeVerRevNr.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSMergeVerRevNr.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSMergeVerRevNr.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSMergeVerRevNr.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSMergeVerRevNr.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSMergeVerRevNr.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSMergeVerRevNr.Get_SourceRevisionID: Integer; safecall;
begin
  Result := SourceRevisionID;
end;

procedure TJVCSMergeVerRevNr.Set_SourceRevisionID(Value: Integer); safecall;
begin
  SourceRevisionID := Value;
end;

function TJVCSMergeVerRevNr.Get_TargetVersion: Integer; safecall;
begin
  Result := TargetVersion;
end;

procedure TJVCSMergeVerRevNr.Set_TargetVersion(Value: Integer); safecall;
begin
  TargetVersion := Value;
end;

function TJVCSMergeVerRevNr.Get_TargetRevision: Integer; safecall;
begin
  Result := TargetRevision;
end;

procedure TJVCSMergeVerRevNr.Set_TargetRevision(Value: Integer); safecall;
begin
  TargetRevision := Value;
end;

function TJVCSMergeVerRevNr.Get_ModuleName: WideString; safecall;
begin
  Result := ModuleName;
end;

procedure TJVCSMergeVerRevNr.Set_ModuleName(const Value: WideString); safecall;
begin
  ModuleName := Value;
end;

function TJVCSMergeVerRevNr.Get_IDEVersion: Integer; safecall;
begin
  Result := IDEVersion;
end;

procedure TJVCSMergeVerRevNr.Set_IDEVersion(Value: Integer); safecall;
begin
  IDEVersion := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSReportProjectState private }

procedure TJVCSReportProjectState.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSReportProjectState.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSReportProjectState.GetOutputItems(Index: Integer): TReportProjectStateOutputItem;
begin
  Result := PReportProjectStateOutputItem(FOutputItems[Index])^;
end;

{ TJVCSReportProjectState protected }

procedure TJVCSReportProjectState.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FCheckedOut]);
      WriteFields(False, [FHidden]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FLabelID]);
    end;
end;

{ TJVCSReportProjectState public }

constructor TJVCSReportProjectState.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSReportProjectState.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSReportProjectState.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSReportProjectState) then
    begin
      FProjectID := TJVCSReportProjectState(Reference).FProjectID;
      FCheckedOut := TJVCSReportProjectState(Reference).FCheckedOut;
      FHidden := TJVCSReportProjectState(Reference).FHidden;
      FUserID := TJVCSReportProjectState(Reference).FUserID;
      FLabelID := TJVCSReportProjectState(Reference).FLabelID;
      ClearOutputItems;
      for I := 0 to TJVCSReportProjectState(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReportProjectStateOutputItem));
        try
          with PReportProjectStateOutputItem(P)^ do
          begin
            ModuleID := TJVCSReportProjectState(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSReportProjectState(Reference).OutputItems[I].ModuleName;
            ModulePath := TJVCSReportProjectState(Reference).OutputItems[I].ModulePath;
            RevisionID := TJVCSReportProjectState(Reference).OutputItems[I].RevisionID;
            Version := TJVCSReportProjectState(Reference).OutputItems[I].Version;
            Revision := TJVCSReportProjectState(Reference).OutputItems[I].Revision;
            RevisionTimestamp := TJVCSReportProjectState(Reference).OutputItems[I].RevisionTimestamp;
            RevisionExtension := TJVCSReportProjectState(Reference).OutputItems[I].RevisionExtension;
            LabelID := TJVCSReportProjectState(Reference).OutputItems[I].LabelID;
            ReadOnly := TJVCSReportProjectState(Reference).OutputItems[I].ReadOnly;
            Owner := TJVCSReportProjectState(Reference).OutputItems[I].Owner;
            RevisionFileSize := TJVCSReportProjectState(Reference).OutputItems[I].RevisionFileSize;
            RevisionCompressedSize := TJVCSReportProjectState(Reference).OutputItems[I].RevisionCompressedSize;
            RevisionCRC := TJVCSReportProjectState(Reference).OutputItems[I].RevisionCRC;
            Hidden := TJVCSReportProjectState(Reference).OutputItems[I].Hidden;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportProjectStateOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSReportProjectState.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSReportProjectState.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TReportProjectStateOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PReportProjectStateOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PReportProjectStateOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PReportProjectStateOutputItem(P)^.ModulePath := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PReportProjectStateOutputItem(P)^.Version := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PReportProjectStateOutputItem(P)^.Revision := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionTimestamp := SafeStrToFloat(ResponseBuffer.Fields[6]);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionExtension := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PReportProjectStateOutputItem(P)^.LabelID := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PReportProjectStateOutputItem(P)^.ReadOnly := (StrToInt64Def(ResponseBuffer.Fields[9], 0) <> 0);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PReportProjectStateOutputItem(P)^.Owner := ResponseBuffer.Fields[10];
          if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionFileSize := StrToInt64Def(ResponseBuffer.Fields[11], -1);
          if (ResponseBuffer.FieldCount > 12) and (ResponseBuffer.FieldType[12] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionCompressedSize := StrToInt64Def(ResponseBuffer.Fields[12], -1);
          if (ResponseBuffer.FieldCount > 13) and (ResponseBuffer.FieldType[13] = mwString) then
            PReportProjectStateOutputItem(P)^.RevisionCRC := StrToInt64Def(ResponseBuffer.Fields[13], -1);
          if (ResponseBuffer.FieldCount > 14) and (ResponseBuffer.FieldType[14] = mwString) then
            PReportProjectStateOutputItem(P)^.Hidden := (StrToInt64Def(ResponseBuffer.Fields[14], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportProjectStateOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSReportProjectStateOutputItem.Create(AOwner: TComponent; APtr: PReportProjectStateOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReportProjectStateOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReportProjectStateOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSReportProjectStateOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSReportProjectStateOutputItem.Get_ModulePath: WideString; safecall;
begin
  Result := FPtr^.ModulePath;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSReportProjectStateOutputItem.Get_Version: Integer; safecall;
begin
  Result := FPtr^.Version;
end;

function TJVCSReportProjectStateOutputItem.Get_Revision: Integer; safecall;
begin
  Result := FPtr^.Revision;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionTimestamp: TDateTime; safecall;
begin
  Result := FPtr^.RevisionTimestamp;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionExtension: WideString; safecall;
begin
  Result := FPtr^.RevisionExtension;
end;

function TJVCSReportProjectStateOutputItem.Get_LabelID: Integer; safecall;
begin
  Result := FPtr^.LabelID;
end;

function TJVCSReportProjectStateOutputItem.Get_ReadOnly: WordBool; safecall;
begin
  Result := FPtr^.ReadOnly;
end;

function TJVCSReportProjectStateOutputItem.Get_Owner: WideString; safecall;
begin
  Result := FPtr^.Owner;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionFileSize: Integer; safecall;
begin
  Result := FPtr^.RevisionFileSize;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionCompressedSize: Integer; safecall;
begin
  Result := FPtr^.RevisionCompressedSize;
end;

function TJVCSReportProjectStateOutputItem.Get_RevisionCRC: Integer; safecall;
begin
  Result := FPtr^.RevisionCRC;
end;

function TJVCSReportProjectStateOutputItem.Get_Hidden: WordBool; safecall;
begin
  Result := FPtr^.Hidden;
end;

function TJVCSReportProjectState.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSReportProjectState.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSReportProjectState.Get_CheckedOut: WordBool; safecall;
begin
  Result := CheckedOut;
end;

procedure TJVCSReportProjectState.Set_CheckedOut(Value: WordBool); safecall;
begin
  CheckedOut := Value;
end;

function TJVCSReportProjectState.Get_Hidden: WordBool; safecall;
begin
  Result := Hidden;
end;

procedure TJVCSReportProjectState.Set_Hidden(Value: WordBool); safecall;
begin
  Hidden := Value;
end;

function TJVCSReportProjectState.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSReportProjectState.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSReportProjectState.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSReportProjectState.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSReportProjectState.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSReportProjectState.Get_OutputItems(Index: Integer): IJVCSReportProjectStateOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSReportProjectStateOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSReportAllProjects private }

procedure TJVCSReportAllProjects.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PReportAllProjectsOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSReportAllProjects.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSReportAllProjects.GetOutputItems(Index: Integer): TReportAllProjectsOutputItem;
begin
  Result := PReportAllProjectsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSReportAllProjects public }

constructor TJVCSReportAllProjects.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSReportAllProjects.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSReportAllProjects.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSReportAllProjects) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSReportAllProjects(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReportAllProjectsOutputItem));
        try
          with PReportAllProjectsOutputItem(P)^ do
          begin
            ProjectID := TJVCSReportAllProjects(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSReportAllProjects(Reference).OutputItems[I].ProjectName;
            CreatedTime := TJVCSReportAllProjects(Reference).OutputItems[I].CreatedTime;
            CreatedBy := TJVCSReportAllProjects(Reference).OutputItems[I].CreatedBy;
            LastAccessedTime := TJVCSReportAllProjects(Reference).OutputItems[I].LastAccessedTime;
            LastAccessedBy := TJVCSReportAllProjects(Reference).OutputItems[I].LastAccessedBy;
            AssignedFileCount := TJVCSReportAllProjects(Reference).OutputItems[I].AssignedFileCount;
            FileSizeTotal := TJVCSReportAllProjects(Reference).OutputItems[I].FileSizeTotal;
            CompressedSizeTotal := TJVCSReportAllProjects(Reference).OutputItems[I].CompressedSizeTotal;
            ProjectDeleted := TJVCSReportAllProjects(Reference).OutputItems[I].ProjectDeleted;
            Description := TJVCSReportAllProjects(Reference).OutputItems[I].Description;
            AssignedModuleCount := TJVCSReportAllProjects(Reference).OutputItems[I].AssignedModuleCount;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportAllProjectsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSReportAllProjects.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSReportAllProjects.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TReportAllProjectsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PReportAllProjectsOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PReportAllProjectsOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PReportAllProjectsOutputItem(P)^.CreatedTime := SafeStrToFloat(ResponseBuffer.Fields[2]);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PReportAllProjectsOutputItem(P)^.CreatedBy := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PReportAllProjectsOutputItem(P)^.LastAccessedTime := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PReportAllProjectsOutputItem(P)^.LastAccessedBy := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PReportAllProjectsOutputItem(P)^.AssignedFileCount := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PReportAllProjectsOutputItem(P)^.FileSizeTotal := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PReportAllProjectsOutputItem(P)^.CompressedSizeTotal := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PReportAllProjectsOutputItem(P)^.ProjectDeleted := (StrToInt64Def(ResponseBuffer.Fields[9], 0) <> 0);
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PReportAllProjectsOutputItem(P)^.Description := ResponseBuffer.Fields[10];
          if (ResponseBuffer.FieldCount > 11) and (ResponseBuffer.FieldType[11] = mwString) then
            PReportAllProjectsOutputItem(P)^.AssignedModuleCount := StrToInt64Def(ResponseBuffer.Fields[11], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportAllProjectsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSReportAllProjectsOutputItem.Create(AOwner: TComponent; APtr: PReportAllProjectsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReportAllProjectsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReportAllProjectsOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSReportAllProjectsOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSReportAllProjectsOutputItem.Get_CreatedTime: TDateTime; safecall;
begin
  Result := FPtr^.CreatedTime;
end;

function TJVCSReportAllProjectsOutputItem.Get_CreatedBy: WideString; safecall;
begin
  Result := FPtr^.CreatedBy;
end;

function TJVCSReportAllProjectsOutputItem.Get_LastAccessedTime: TDateTime; safecall;
begin
  Result := FPtr^.LastAccessedTime;
end;

function TJVCSReportAllProjectsOutputItem.Get_LastAccessedBy: WideString; safecall;
begin
  Result := FPtr^.LastAccessedBy;
end;

function TJVCSReportAllProjectsOutputItem.Get_AssignedFileCount: Integer; safecall;
begin
  Result := FPtr^.AssignedFileCount;
end;

function TJVCSReportAllProjectsOutputItem.Get_FileSizeTotal: Integer; safecall;
begin
  Result := FPtr^.FileSizeTotal;
end;

function TJVCSReportAllProjectsOutputItem.Get_CompressedSizeTotal: Integer; safecall;
begin
  Result := FPtr^.CompressedSizeTotal;
end;

function TJVCSReportAllProjectsOutputItem.Get_ProjectDeleted: WordBool; safecall;
begin
  Result := FPtr^.ProjectDeleted;
end;

function TJVCSReportAllProjectsOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSReportAllProjectsOutputItem.Get_AssignedModuleCount: Integer; safecall;
begin
  Result := FPtr^.AssignedModuleCount;
end;

function TJVCSReportAllProjects.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSReportAllProjects.Get_OutputItems(Index: Integer): IJVCSReportAllProjectsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSReportAllProjectsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSReportProjectBugs private }

procedure TJVCSReportProjectBugs.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PReportProjectBugsOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSReportProjectBugs.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSReportProjectBugs.GetOutputItems(Index: Integer): TReportProjectBugsOutputItem;
begin
  Result := PReportProjectBugsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSReportProjectBugs protected }

procedure TJVCSReportProjectBugs.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FBugID]);
      WriteFields(False, [FSeverity]);
      WriteFields(False, [FStatus]);
    end;
end;

{ TJVCSReportProjectBugs public }

constructor TJVCSReportProjectBugs.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSReportProjectBugs.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSReportProjectBugs.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSReportProjectBugs) then
    begin
      FProjectID := TJVCSReportProjectBugs(Reference).FProjectID;
      FBugID := TJVCSReportProjectBugs(Reference).FBugID;
      FSeverity := TJVCSReportProjectBugs(Reference).FSeverity;
      FStatus := TJVCSReportProjectBugs(Reference).FStatus;
      ClearOutputItems;
      for I := 0 to TJVCSReportProjectBugs(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReportProjectBugsOutputItem));
        try
          with PReportProjectBugsOutputItem(P)^ do
          begin
            ItemType := TJVCSReportProjectBugs(Reference).OutputItems[I].ItemType;
            ItemID := TJVCSReportProjectBugs(Reference).OutputItems[I].ItemID;
            ItemName := TJVCSReportProjectBugs(Reference).OutputItems[I].ItemName;
            ItemPath := TJVCSReportProjectBugs(Reference).OutputItems[I].ItemPath;
            BugName := TJVCSReportProjectBugs(Reference).OutputItems[I].BugName;
            Severity := TJVCSReportProjectBugs(Reference).OutputItems[I].Severity;
            Status := TJVCSReportProjectBugs(Reference).OutputItems[I].Status;
            BugDescription := TJVCSReportProjectBugs(Reference).OutputItems[I].BugDescription;
            ReportedBy := TJVCSReportProjectBugs(Reference).OutputItems[I].ReportedBy;
            Workaround := TJVCSReportProjectBugs(Reference).OutputItems[I].Workaround;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportProjectBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSReportProjectBugs.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSReportProjectBugs.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TReportProjectBugsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PReportProjectBugsOutputItem(P)^.ItemType := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PReportProjectBugsOutputItem(P)^.ItemID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PReportProjectBugsOutputItem(P)^.ItemName := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PReportProjectBugsOutputItem(P)^.ItemPath := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PReportProjectBugsOutputItem(P)^.BugName := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PReportProjectBugsOutputItem(P)^.Severity := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PReportProjectBugsOutputItem(P)^.Status := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PReportProjectBugsOutputItem(P)^.BugDescription := ResponseBuffer.Fields[7];
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PReportProjectBugsOutputItem(P)^.ReportedBy := ResponseBuffer.Fields[8];
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PReportProjectBugsOutputItem(P)^.Workaround := ResponseBuffer.Fields[9];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportProjectBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSReportProjectBugsOutputItem.Create(AOwner: TComponent; APtr: PReportProjectBugsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReportProjectBugsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReportProjectBugsOutputItem.Get_ItemType: WideString; safecall;
begin
  Result := FPtr^.ItemType;
end;

function TJVCSReportProjectBugsOutputItem.Get_ItemID: Integer; safecall;
begin
  Result := FPtr^.ItemID;
end;

function TJVCSReportProjectBugsOutputItem.Get_ItemName: WideString; safecall;
begin
  Result := FPtr^.ItemName;
end;

function TJVCSReportProjectBugsOutputItem.Get_ItemPath: WideString; safecall;
begin
  Result := FPtr^.ItemPath;
end;

function TJVCSReportProjectBugsOutputItem.Get_BugName: WideString; safecall;
begin
  Result := FPtr^.BugName;
end;

function TJVCSReportProjectBugsOutputItem.Get_Severity: Integer; safecall;
begin
  Result := FPtr^.Severity;
end;

function TJVCSReportProjectBugsOutputItem.Get_Status: Integer; safecall;
begin
  Result := FPtr^.Status;
end;

function TJVCSReportProjectBugsOutputItem.Get_BugDescription: WideString; safecall;
begin
  Result := FPtr^.BugDescription;
end;

function TJVCSReportProjectBugsOutputItem.Get_ReportedBy: WideString; safecall;
begin
  Result := FPtr^.ReportedBy;
end;

function TJVCSReportProjectBugsOutputItem.Get_Workaround: WideString; safecall;
begin
  Result := FPtr^.Workaround;
end;

function TJVCSReportProjectBugs.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSReportProjectBugs.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSReportProjectBugs.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSReportProjectBugs.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSReportProjectBugs.Get_Severity: Integer; safecall;
begin
  Result := Severity;
end;

procedure TJVCSReportProjectBugs.Set_Severity(Value: Integer); safecall;
begin
  Severity := Value;
end;

function TJVCSReportProjectBugs.Get_Status: Integer; safecall;
begin
  Result := Status;
end;

procedure TJVCSReportProjectBugs.Set_Status(Value: Integer); safecall;
begin
  Status := Value;
end;

function TJVCSReportProjectBugs.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSReportProjectBugs.Get_OutputItems(Index: Integer): IJVCSReportProjectBugsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSReportProjectBugsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSReportMilestones private }

procedure TJVCSReportMilestones.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PReportMilestonesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSReportMilestones.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSReportMilestones.GetOutputItems(Index: Integer): TReportMilestonesOutputItem;
begin
  Result := PReportMilestonesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSReportMilestones public }

constructor TJVCSReportMilestones.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSReportMilestones.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSReportMilestones.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSReportMilestones) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSReportMilestones(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TReportMilestonesOutputItem));
        try
          with PReportMilestonesOutputItem(P)^ do
          begin
            ProjectID := TJVCSReportMilestones(Reference).OutputItems[I].ProjectID;
            ProjectName := TJVCSReportMilestones(Reference).OutputItems[I].ProjectName;
            MilestoneLevel := TJVCSReportMilestones(Reference).OutputItems[I].MilestoneLevel;
            MilestoneName := TJVCSReportMilestones(Reference).OutputItems[I].MilestoneName;
            ReachedTime := TJVCSReportMilestones(Reference).OutputItems[I].ReachedTime;
            ConfirmedBy := TJVCSReportMilestones(Reference).OutputItems[I].ConfirmedBy;
            Description := TJVCSReportMilestones(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSReportMilestones.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSReportMilestones.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TReportMilestonesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PReportMilestonesOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PReportMilestonesOutputItem(P)^.ProjectName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PReportMilestonesOutputItem(P)^.MilestoneLevel := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PReportMilestonesOutputItem(P)^.MilestoneName := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PReportMilestonesOutputItem(P)^.ReachedTime := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PReportMilestonesOutputItem(P)^.ConfirmedBy := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PReportMilestonesOutputItem(P)^.Description := ResponseBuffer.Fields[6];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSReportMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSReportMilestonesOutputItem.Create(AOwner: TComponent; APtr: PReportMilestonesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSReportMilestonesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSReportMilestonesOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSReportMilestonesOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSReportMilestonesOutputItem.Get_MilestoneLevel: Integer; safecall;
begin
  Result := FPtr^.MilestoneLevel;
end;

function TJVCSReportMilestonesOutputItem.Get_MilestoneName: WideString; safecall;
begin
  Result := FPtr^.MilestoneName;
end;

function TJVCSReportMilestonesOutputItem.Get_ReachedTime: TDateTime; safecall;
begin
  Result := FPtr^.ReachedTime;
end;

function TJVCSReportMilestonesOutputItem.Get_ConfirmedBy: WideString; safecall;
begin
  Result := FPtr^.ConfirmedBy;
end;

function TJVCSReportMilestonesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSReportMilestones.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSReportMilestones.Get_OutputItems(Index: Integer): IJVCSReportMilestonesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSReportMilestonesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetBugs private }

procedure TJVCSGetBugs.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetBugsOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetBugs.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetBugs.GetOutputItems(Index: Integer): TGetBugsOutputItem;
begin
  Result := PGetBugsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetBugs protected }

procedure TJVCSGetBugs.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FIncludeDescription]);
    end;
end;

{ TJVCSGetBugs public }

constructor TJVCSGetBugs.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetBugs.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetBugs.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetBugs) then
    begin
      FIncludeDescription := TJVCSGetBugs(Reference).FIncludeDescription;
      ClearOutputItems;
      for I := 0 to TJVCSGetBugs(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetBugsOutputItem));
        try
          with PGetBugsOutputItem(P)^ do
          begin
            BugID := TJVCSGetBugs(Reference).OutputItems[I].BugID;
            BugName := TJVCSGetBugs(Reference).OutputItems[I].BugName;
            Keywords := TJVCSGetBugs(Reference).OutputItems[I].Keywords;
            Severity := TJVCSGetBugs(Reference).OutputItems[I].Severity;
            CreatedTime := TJVCSGetBugs(Reference).OutputItems[I].CreatedTime;
            CreatedBy := TJVCSGetBugs(Reference).OutputItems[I].CreatedBy;
            Flags := TJVCSGetBugs(Reference).OutputItems[I].Flags;
            Status := TJVCSGetBugs(Reference).OutputItems[I].Status;
            Description := TJVCSGetBugs(Reference).OutputItems[I].Description;
            ReportedBy := TJVCSGetBugs(Reference).OutputItems[I].ReportedBy;
            Workaround := TJVCSGetBugs(Reference).OutputItems[I].Workaround;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetBugs.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetBugs.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetBugsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetBugsOutputItem(P)^.BugID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetBugsOutputItem(P)^.BugName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetBugsOutputItem(P)^.Keywords := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetBugsOutputItem(P)^.Severity := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetBugsOutputItem(P)^.CreatedTime := SafeStrToFloat(ResponseBuffer.Fields[4]);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetBugsOutputItem(P)^.CreatedBy := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetBugsOutputItem(P)^.Flags := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetBugsOutputItem(P)^.Status := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetBugsOutputItem(P)^.Description := ResponseBuffer.Fields[8];
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetBugsOutputItem(P)^.ReportedBy := ResponseBuffer.Fields[9];
          if (ResponseBuffer.FieldCount > 10) and (ResponseBuffer.FieldType[10] = mwString) then
            PGetBugsOutputItem(P)^.Workaround := ResponseBuffer.Fields[10];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetBugsOutputItem.Create(AOwner: TComponent; APtr: PGetBugsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetBugsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetBugsOutputItem.Get_BugID: Integer; safecall;
begin
  Result := FPtr^.BugID;
end;

function TJVCSGetBugsOutputItem.Get_BugName: WideString; safecall;
begin
  Result := FPtr^.BugName;
end;

function TJVCSGetBugsOutputItem.Get_Keywords: WideString; safecall;
begin
  Result := FPtr^.Keywords;
end;

function TJVCSGetBugsOutputItem.Get_Severity: Integer; safecall;
begin
  Result := FPtr^.Severity;
end;

function TJVCSGetBugsOutputItem.Get_CreatedTime: TDateTime; safecall;
begin
  Result := FPtr^.CreatedTime;
end;

function TJVCSGetBugsOutputItem.Get_CreatedBy: WideString; safecall;
begin
  Result := FPtr^.CreatedBy;
end;

function TJVCSGetBugsOutputItem.Get_Flags: Integer; safecall;
begin
  Result := FPtr^.Flags;
end;

function TJVCSGetBugsOutputItem.Get_Status: Integer; safecall;
begin
  Result := FPtr^.Status;
end;

function TJVCSGetBugsOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetBugsOutputItem.Get_ReportedBy: WideString; safecall;
begin
  Result := FPtr^.ReportedBy;
end;

function TJVCSGetBugsOutputItem.Get_Workaround: WideString; safecall;
begin
  Result := FPtr^.Workaround;
end;

function TJVCSGetBugs.Get_IncludeDescription: WordBool; safecall;
begin
  Result := IncludeDescription;
end;

procedure TJVCSGetBugs.Set_IncludeDescription(Value: WordBool); safecall;
begin
  IncludeDescription := Value;
end;

function TJVCSGetBugs.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetBugs.Get_OutputItems(Index: Integer): IJVCSGetBugsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetBugsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetBugsByProject private }

procedure TJVCSGetBugsByProject.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetBugsByProjectOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetBugsByProject.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetBugsByProject.GetOutputItems(Index: Integer): TGetBugsByProjectOutputItem;
begin
  Result := PGetBugsByProjectOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetBugsByProject protected }

procedure TJVCSGetBugsByProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetBugsByProject public }

constructor TJVCSGetBugsByProject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetBugsByProject.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetBugsByProject.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetBugsByProject) then
    begin
      FProjectID := TJVCSGetBugsByProject(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetBugsByProject(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetBugsByProjectOutputItem));
        try
          with PGetBugsByProjectOutputItem(P)^ do
          begin
            BugID := TJVCSGetBugsByProject(Reference).OutputItems[I].BugID;
            BugName := TJVCSGetBugsByProject(Reference).OutputItems[I].BugName;
            Description := TJVCSGetBugsByProject(Reference).OutputItems[I].Description;
            Severity := TJVCSGetBugsByProject(Reference).OutputItems[I].Severity;
            Done := TJVCSGetBugsByProject(Reference).OutputItems[I].Done;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsByProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetBugsByProject.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetBugsByProject.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetBugsByProjectOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetBugsByProjectOutputItem(P)^.BugID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetBugsByProjectOutputItem(P)^.BugName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetBugsByProjectOutputItem(P)^.Description := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetBugsByProjectOutputItem(P)^.Severity := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetBugsByProjectOutputItem(P)^.Done := (StrToInt64Def(ResponseBuffer.Fields[4], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsByProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetBugsByProjectOutputItem.Create(AOwner: TComponent; APtr: PGetBugsByProjectOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetBugsByProjectOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetBugsByProjectOutputItem.Get_BugID: Integer; safecall;
begin
  Result := FPtr^.BugID;
end;

function TJVCSGetBugsByProjectOutputItem.Get_BugName: WideString; safecall;
begin
  Result := FPtr^.BugName;
end;

function TJVCSGetBugsByProjectOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetBugsByProjectOutputItem.Get_Severity: Integer; safecall;
begin
  Result := FPtr^.Severity;
end;

function TJVCSGetBugsByProjectOutputItem.Get_Done: WordBool; safecall;
begin
  Result := FPtr^.Done;
end;

function TJVCSGetBugsByProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetBugsByProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetBugsByProject.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetBugsByProject.Get_OutputItems(Index: Integer): IJVCSGetBugsByProjectOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetBugsByProjectOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetBugsByModule private }

procedure TJVCSGetBugsByModule.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetBugsByModuleOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetBugsByModule.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetBugsByModule.GetOutputItems(Index: Integer): TGetBugsByModuleOutputItem;
begin
  Result := PGetBugsByModuleOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetBugsByModule protected }

procedure TJVCSGetBugsByModule.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
    end;
end;

{ TJVCSGetBugsByModule public }

constructor TJVCSGetBugsByModule.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetBugsByModule.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetBugsByModule.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetBugsByModule) then
    begin
      FModuleID := TJVCSGetBugsByModule(Reference).FModuleID;
      ClearOutputItems;
      for I := 0 to TJVCSGetBugsByModule(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetBugsByModuleOutputItem));
        try
          with PGetBugsByModuleOutputItem(P)^ do
          begin
            BugID := TJVCSGetBugsByModule(Reference).OutputItems[I].BugID;
            BugName := TJVCSGetBugsByModule(Reference).OutputItems[I].BugName;
            Description := TJVCSGetBugsByModule(Reference).OutputItems[I].Description;
            Severity := TJVCSGetBugsByModule(Reference).OutputItems[I].Severity;
            Done := TJVCSGetBugsByModule(Reference).OutputItems[I].Done;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsByModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetBugsByModule.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetBugsByModule.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetBugsByModuleOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetBugsByModuleOutputItem(P)^.BugID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetBugsByModuleOutputItem(P)^.BugName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetBugsByModuleOutputItem(P)^.Description := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetBugsByModuleOutputItem(P)^.Severity := StrToInt64Def(ResponseBuffer.Fields[3], -1);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetBugsByModuleOutputItem(P)^.Done := (StrToInt64Def(ResponseBuffer.Fields[4], 0) <> 0);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetBugsByModuleOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetBugsByModuleOutputItem.Create(AOwner: TComponent; APtr: PGetBugsByModuleOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetBugsByModuleOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetBugsByModuleOutputItem.Get_BugID: Integer; safecall;
begin
  Result := FPtr^.BugID;
end;

function TJVCSGetBugsByModuleOutputItem.Get_BugName: WideString; safecall;
begin
  Result := FPtr^.BugName;
end;

function TJVCSGetBugsByModuleOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetBugsByModuleOutputItem.Get_Severity: Integer; safecall;
begin
  Result := FPtr^.Severity;
end;

function TJVCSGetBugsByModuleOutputItem.Get_Done: WordBool; safecall;
begin
  Result := FPtr^.Done;
end;

function TJVCSGetBugsByModule.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetBugsByModule.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetBugsByModule.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetBugsByModule.Get_OutputItems(Index: Integer): IJVCSGetBugsByModuleOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetBugsByModuleOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetMostSevereBugs private }

procedure TJVCSGetMostSevereBugs.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetMostSevereBugs.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetMostSevereBugs.GetOutputItems(Index: Integer): TGetMostSevereBugsOutputItem;
begin
  Result := PGetMostSevereBugsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetMostSevereBugs protected }

procedure TJVCSGetMostSevereBugs.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleBased]);
    end;
end;

{ TJVCSGetMostSevereBugs public }

constructor TJVCSGetMostSevereBugs.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetMostSevereBugs.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetMostSevereBugs.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetMostSevereBugs) then
    begin
      FModuleBased := TJVCSGetMostSevereBugs(Reference).FModuleBased;
      ClearOutputItems;
      for I := 0 to TJVCSGetMostSevereBugs(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetMostSevereBugsOutputItem));
        try
          with PGetMostSevereBugsOutputItem(P)^ do
          begin
            ItemID := TJVCSGetMostSevereBugs(Reference).OutputItems[I].ItemID;
            BugID := TJVCSGetMostSevereBugs(Reference).OutputItems[I].BugID;
            Severity := TJVCSGetMostSevereBugs(Reference).OutputItems[I].Severity;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetMostSevereBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetMostSevereBugs.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetMostSevereBugs.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetMostSevereBugsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetMostSevereBugsOutputItem(P)^.ItemID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetMostSevereBugsOutputItem(P)^.BugID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetMostSevereBugsOutputItem(P)^.Severity := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetMostSevereBugsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetMostSevereBugsOutputItem.Create(AOwner: TComponent; APtr: PGetMostSevereBugsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetMostSevereBugsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetMostSevereBugsOutputItem.Get_ItemID: Integer; safecall;
begin
  Result := FPtr^.ItemID;
end;

function TJVCSGetMostSevereBugsOutputItem.Get_BugID: Integer; safecall;
begin
  Result := FPtr^.BugID;
end;

function TJVCSGetMostSevereBugsOutputItem.Get_Severity: Integer; safecall;
begin
  Result := FPtr^.Severity;
end;

function TJVCSGetMostSevereBugs.Get_ModuleBased: WordBool; safecall;
begin
  Result := ModuleBased;
end;

procedure TJVCSGetMostSevereBugs.Set_ModuleBased(Value: WordBool); safecall;
begin
  ModuleBased := Value;
end;

function TJVCSGetMostSevereBugs.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetMostSevereBugs.Get_OutputItems(Index: Integer): IJVCSGetMostSevereBugsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetMostSevereBugsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateBug protected }

procedure TJVCSAddUpdateBug.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FBugID]);
      WriteFields(False, [FBugName]);
      WriteFields(False, [FSeverity]);
      WriteFields(False, [FFlags]);
      WriteFields(False, [FDescription]);
      WriteFields(False, [FKeywords]);
      WriteFields(False, [FReportedBy]);
      WriteFields(False, [FWorkaround]);
      WriteFields(False, [FStatus]);
    end;
end;

{ TJVCSAddUpdateBug public }

procedure TJVCSAddUpdateBug.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateBug) then
    begin
      FBugID := TJVCSAddUpdateBug(Reference).FBugID;
      FBugName := TJVCSAddUpdateBug(Reference).FBugName;
      FSeverity := TJVCSAddUpdateBug(Reference).FSeverity;
      FFlags := TJVCSAddUpdateBug(Reference).FFlags;
      FDescription := TJVCSAddUpdateBug(Reference).FDescription;
      FKeywords := TJVCSAddUpdateBug(Reference).FKeywords;
      FReportedBy := TJVCSAddUpdateBug(Reference).FReportedBy;
      FWorkaround := TJVCSAddUpdateBug(Reference).FWorkaround;
      FStatus := TJVCSAddUpdateBug(Reference).FStatus;
      FNewBug := TJVCSAddUpdateBug(Reference).FNewBug;
      FNewBugID := TJVCSAddUpdateBug(Reference).FNewBugID;
      FErrorMessage := TJVCSAddUpdateBug(Reference).FErrorMessage;
    end;
end;

procedure TJVCSAddUpdateBug.Initialize; 
begin
  inherited Initialize;
  FNewBug := False;
  FNewBugID := -1;
  FErrorMessage := '';
end;

procedure TJVCSAddUpdateBug.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FNewBug := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FNewBugID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FErrorMessage := ResponseBuffer.Fields[2];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateBug.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSAddUpdateBug.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSAddUpdateBug.Get_BugName: WideString; safecall;
begin
  Result := BugName;
end;

procedure TJVCSAddUpdateBug.Set_BugName(const Value: WideString); safecall;
begin
  BugName := Value;
end;

function TJVCSAddUpdateBug.Get_Severity: Integer; safecall;
begin
  Result := Severity;
end;

procedure TJVCSAddUpdateBug.Set_Severity(Value: Integer); safecall;
begin
  Severity := Value;
end;

function TJVCSAddUpdateBug.Get_Flags: Integer; safecall;
begin
  Result := Flags;
end;

procedure TJVCSAddUpdateBug.Set_Flags(Value: Integer); safecall;
begin
  Flags := Value;
end;

function TJVCSAddUpdateBug.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAddUpdateBug.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

function TJVCSAddUpdateBug.Get_Keywords: WideString; safecall;
begin
  Result := Keywords;
end;

procedure TJVCSAddUpdateBug.Set_Keywords(const Value: WideString); safecall;
begin
  Keywords := Value;
end;

function TJVCSAddUpdateBug.Get_ReportedBy: WideString; safecall;
begin
  Result := ReportedBy;
end;

procedure TJVCSAddUpdateBug.Set_ReportedBy(const Value: WideString); safecall;
begin
  ReportedBy := Value;
end;

function TJVCSAddUpdateBug.Get_Workaround: WideString; safecall;
begin
  Result := Workaround;
end;

procedure TJVCSAddUpdateBug.Set_Workaround(const Value: WideString); safecall;
begin
  Workaround := Value;
end;

function TJVCSAddUpdateBug.Get_Status: Integer; safecall;
begin
  Result := Status;
end;

procedure TJVCSAddUpdateBug.Set_Status(Value: Integer); safecall;
begin
  Status := Value;
end;

function TJVCSAddUpdateBug.Get_NewBug: WordBool; safecall;
begin
  Result := NewBug;
end;

function TJVCSAddUpdateBug.Get_NewBugID: Integer; safecall;
begin
  Result := NewBugID;
end;

function TJVCSAddUpdateBug.Get_ErrorMessage: WideString; safecall;
begin
  Result := ErrorMessage;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveBug protected }

procedure TJVCSRemoveBug.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FBugID]);
    end;
end;

{ TJVCSRemoveBug public }

procedure TJVCSRemoveBug.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveBug) then
    begin
      FBugID := TJVCSRemoveBug(Reference).FBugID;
      FBugRemoved := TJVCSRemoveBug(Reference).FBugRemoved;
    end;
end;

procedure TJVCSRemoveBug.Initialize; 
begin
  inherited Initialize;
  FBugRemoved := False;
end;

procedure TJVCSRemoveBug.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FBugRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveBug.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSRemoveBug.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSRemoveBug.Get_BugRemoved: WordBool; safecall;
begin
  Result := BugRemoved;
end;

{$ENDIF COMVERSION}

{ TJVCSAssignRemoveBug protected }

procedure TJVCSAssignRemoveBug.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FItemID]);
      WriteFields(False, [FBugID]);
      WriteFields(False, [FProjectRelated]);
      WriteFields(False, [FAddBug]);
    end;
end;

{ TJVCSAssignRemoveBug public }

procedure TJVCSAssignRemoveBug.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAssignRemoveBug) then
    begin
      FItemID := TJVCSAssignRemoveBug(Reference).FItemID;
      FBugID := TJVCSAssignRemoveBug(Reference).FBugID;
      FProjectRelated := TJVCSAssignRemoveBug(Reference).FProjectRelated;
      FAddBug := TJVCSAssignRemoveBug(Reference).FAddBug;
      FBugAdded := TJVCSAssignRemoveBug(Reference).FBugAdded;
    end;
end;

procedure TJVCSAssignRemoveBug.Initialize; 
begin
  inherited Initialize;
  FBugAdded := False;
end;

procedure TJVCSAssignRemoveBug.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FBugAdded := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAssignRemoveBug.Get_ItemID: Integer; safecall;
begin
  Result := ItemID;
end;

procedure TJVCSAssignRemoveBug.Set_ItemID(Value: Integer); safecall;
begin
  ItemID := Value;
end;

function TJVCSAssignRemoveBug.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSAssignRemoveBug.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSAssignRemoveBug.Get_ProjectRelated: WordBool; safecall;
begin
  Result := ProjectRelated;
end;

procedure TJVCSAssignRemoveBug.Set_ProjectRelated(Value: WordBool); safecall;
begin
  ProjectRelated := Value;
end;

function TJVCSAssignRemoveBug.Get_AddBug: WordBool; safecall;
begin
  Result := AddBug;
end;

procedure TJVCSAssignRemoveBug.Set_AddBug(Value: WordBool); safecall;
begin
  AddBug := Value;
end;

function TJVCSAssignRemoveBug.Get_BugAdded: WordBool; safecall;
begin
  Result := BugAdded;
end;

{$ENDIF COMVERSION}

{ TJVCSEnableModuleProjectBug protected }

procedure TJVCSEnableModuleProjectBug.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FItemID]);
      WriteFields(False, [FBugID]);
      WriteFields(False, [FProjectRelated]);
      WriteFields(False, [FDone]);
    end;
end;

{ TJVCSEnableModuleProjectBug public }

procedure TJVCSEnableModuleProjectBug.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSEnableModuleProjectBug) then
    begin
      FItemID := TJVCSEnableModuleProjectBug(Reference).FItemID;
      FBugID := TJVCSEnableModuleProjectBug(Reference).FBugID;
      FProjectRelated := TJVCSEnableModuleProjectBug(Reference).FProjectRelated;
      FDone := TJVCSEnableModuleProjectBug(Reference).FDone;
      FBugAdded := TJVCSEnableModuleProjectBug(Reference).FBugAdded;
    end;
end;

procedure TJVCSEnableModuleProjectBug.Initialize; 
begin
  inherited Initialize;
  FBugAdded := False;
end;

procedure TJVCSEnableModuleProjectBug.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FBugAdded := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSEnableModuleProjectBug.Get_ItemID: Integer; safecall;
begin
  Result := ItemID;
end;

procedure TJVCSEnableModuleProjectBug.Set_ItemID(Value: Integer); safecall;
begin
  ItemID := Value;
end;

function TJVCSEnableModuleProjectBug.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSEnableModuleProjectBug.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSEnableModuleProjectBug.Get_ProjectRelated: WordBool; safecall;
begin
  Result := ProjectRelated;
end;

procedure TJVCSEnableModuleProjectBug.Set_ProjectRelated(Value: WordBool); safecall;
begin
  ProjectRelated := Value;
end;

function TJVCSEnableModuleProjectBug.Get_Done: WordBool; safecall;
begin
  Result := Done;
end;

procedure TJVCSEnableModuleProjectBug.Set_Done(Value: WordBool); safecall;
begin
  Done := Value;
end;

function TJVCSEnableModuleProjectBug.Get_BugAdded: WordBool; safecall;
begin
  Result := BugAdded;
end;

{$ENDIF COMVERSION}

{ TJVCSBugsUsedBy private }

procedure TJVCSBugsUsedBy.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSBugsUsedBy.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSBugsUsedBy.GetOutputItems(Index: Integer): TBugsUsedByOutputItem;
begin
  Result := PBugsUsedByOutputItem(FOutputItems[Index])^;
end;

{ TJVCSBugsUsedBy protected }

procedure TJVCSBugsUsedBy.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FBugID]);
    end;
end;

{ TJVCSBugsUsedBy public }

constructor TJVCSBugsUsedBy.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSBugsUsedBy.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSBugsUsedBy.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSBugsUsedBy) then
    begin
      FBugID := TJVCSBugsUsedBy(Reference).FBugID;
      ClearOutputItems;
      for I := 0 to TJVCSBugsUsedBy(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TBugsUsedByOutputItem));
        try
          with PBugsUsedByOutputItem(P)^ do
          begin
            ItemType := TJVCSBugsUsedBy(Reference).OutputItems[I].ItemType;
            ItemID := TJVCSBugsUsedBy(Reference).OutputItems[I].ItemID;
            ItemName := TJVCSBugsUsedBy(Reference).OutputItems[I].ItemName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSBugsUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSBugsUsedBy.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSBugsUsedBy.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TBugsUsedByOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PBugsUsedByOutputItem(P)^.ItemType := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PBugsUsedByOutputItem(P)^.ItemID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PBugsUsedByOutputItem(P)^.ItemName := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSBugsUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSBugsUsedByOutputItem.Create(AOwner: TComponent; APtr: PBugsUsedByOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSBugsUsedByOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSBugsUsedByOutputItem.Get_ItemType: WideString; safecall;
begin
  Result := FPtr^.ItemType;
end;

function TJVCSBugsUsedByOutputItem.Get_ItemID: Integer; safecall;
begin
  Result := FPtr^.ItemID;
end;

function TJVCSBugsUsedByOutputItem.Get_ItemName: WideString; safecall;
begin
  Result := FPtr^.ItemName;
end;

function TJVCSBugsUsedBy.Get_BugID: Integer; safecall;
begin
  Result := BugID;
end;

procedure TJVCSBugsUsedBy.Set_BugID(Value: Integer); safecall;
begin
  BugID := Value;
end;

function TJVCSBugsUsedBy.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSBugsUsedBy.Get_OutputItems(Index: Integer): IJVCSBugsUsedByOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSBugsUsedByOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLabels private }

procedure TJVCSGetLabels.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetLabelsOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetLabels.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLabels.GetOutputItems(Index: Integer): TGetLabelsOutputItem;
begin
  Result := PGetLabelsOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLabels protected }

procedure TJVCSGetLabels.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FIncludeDescription]);
    end;
end;

{ TJVCSGetLabels public }

constructor TJVCSGetLabels.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLabels.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLabels.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLabels) then
    begin
      FIncludeDescription := TJVCSGetLabels(Reference).FIncludeDescription;
      ClearOutputItems;
      for I := 0 to TJVCSGetLabels(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLabelsOutputItem));
        try
          with PGetLabelsOutputItem(P)^ do
          begin
            LabelID := TJVCSGetLabels(Reference).OutputItems[I].LabelID;
            LabelName := TJVCSGetLabels(Reference).OutputItems[I].LabelName;
            Description := TJVCSGetLabels(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLabels.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLabels.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLabelsOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLabelsOutputItem(P)^.LabelID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLabelsOutputItem(P)^.LabelName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLabelsOutputItem(P)^.Description := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLabelsOutputItem.Create(AOwner: TComponent; APtr: PGetLabelsOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLabelsOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLabelsOutputItem.Get_LabelID: Integer; safecall;
begin
  Result := FPtr^.LabelID;
end;

function TJVCSGetLabelsOutputItem.Get_LabelName: WideString; safecall;
begin
  Result := FPtr^.LabelName;
end;

function TJVCSGetLabelsOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetLabels.Get_IncludeDescription: WordBool; safecall;
begin
  Result := IncludeDescription;
end;

procedure TJVCSGetLabels.Set_IncludeDescription(Value: WordBool); safecall;
begin
  IncludeDescription := Value;
end;

function TJVCSGetLabels.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLabels.Get_OutputItems(Index: Integer): IJVCSGetLabelsOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLabelsOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLabelsByProject private }

procedure TJVCSGetLabelsByProject.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetLabelsByProject.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLabelsByProject.GetOutputItems(Index: Integer): TGetLabelsByProjectOutputItem;
begin
  Result := PGetLabelsByProjectOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLabelsByProject protected }

procedure TJVCSGetLabelsByProject.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetLabelsByProject public }

constructor TJVCSGetLabelsByProject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLabelsByProject.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLabelsByProject.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLabelsByProject) then
    begin
      FProjectID := TJVCSGetLabelsByProject(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetLabelsByProject(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLabelsByProjectOutputItem));
        try
          with PGetLabelsByProjectOutputItem(P)^ do
          begin
            ModuleID := TJVCSGetLabelsByProject(Reference).OutputItems[I].ModuleID;
            RevisionID := TJVCSGetLabelsByProject(Reference).OutputItems[I].RevisionID;
            LabelID := TJVCSGetLabelsByProject(Reference).OutputItems[I].LabelID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsByProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLabelsByProject.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLabelsByProject.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLabelsByProjectOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLabelsByProjectOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLabelsByProjectOutputItem(P)^.RevisionID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLabelsByProjectOutputItem(P)^.LabelID := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsByProjectOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLabelsByProjectOutputItem.Create(AOwner: TComponent; APtr: PGetLabelsByProjectOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLabelsByProjectOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLabelsByProjectOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetLabelsByProjectOutputItem.Get_RevisionID: Integer; safecall;
begin
  Result := FPtr^.RevisionID;
end;

function TJVCSGetLabelsByProjectOutputItem.Get_LabelID: Integer; safecall;
begin
  Result := FPtr^.LabelID;
end;

function TJVCSGetLabelsByProject.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetLabelsByProject.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetLabelsByProject.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLabelsByProject.Get_OutputItems(Index: Integer): IJVCSGetLabelsByProjectOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLabelsByProjectOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLabelsByRevision private }

procedure TJVCSGetLabelsByRevision.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetLabelsByRevisionOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetLabelsByRevision.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLabelsByRevision.GetOutputItems(Index: Integer): TGetLabelsByRevisionOutputItem;
begin
  Result := PGetLabelsByRevisionOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLabelsByRevision protected }

procedure TJVCSGetLabelsByRevision.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FRevisionID]);
    end;
end;

{ TJVCSGetLabelsByRevision public }

constructor TJVCSGetLabelsByRevision.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLabelsByRevision.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLabelsByRevision.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLabelsByRevision) then
    begin
      FRevisionID := TJVCSGetLabelsByRevision(Reference).FRevisionID;
      ClearOutputItems;
      for I := 0 to TJVCSGetLabelsByRevision(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLabelsByRevisionOutputItem));
        try
          with PGetLabelsByRevisionOutputItem(P)^ do
          begin
            LabelID := TJVCSGetLabelsByRevision(Reference).OutputItems[I].LabelID;
            LabelName := TJVCSGetLabelsByRevision(Reference).OutputItems[I].LabelName;
            Description := TJVCSGetLabelsByRevision(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsByRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLabelsByRevision.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLabelsByRevision.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLabelsByRevisionOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLabelsByRevisionOutputItem(P)^.LabelID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLabelsByRevisionOutputItem(P)^.LabelName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLabelsByRevisionOutputItem(P)^.Description := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLabelsByRevisionOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLabelsByRevisionOutputItem.Create(AOwner: TComponent; APtr: PGetLabelsByRevisionOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLabelsByRevisionOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLabelsByRevisionOutputItem.Get_LabelID: Integer; safecall;
begin
  Result := FPtr^.LabelID;
end;

function TJVCSGetLabelsByRevisionOutputItem.Get_LabelName: WideString; safecall;
begin
  Result := FPtr^.LabelName;
end;

function TJVCSGetLabelsByRevisionOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetLabelsByRevision.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSGetLabelsByRevision.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSGetLabelsByRevision.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLabelsByRevision.Get_OutputItems(Index: Integer): IJVCSGetLabelsByRevisionOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLabelsByRevisionOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetFileFamilies private }

procedure TJVCSGetFileFamilies.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetFileFamiliesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetFileFamilies.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetFileFamilies.GetOutputItems(Index: Integer): TGetFileFamiliesOutputItem;
begin
  Result := PGetFileFamiliesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetFileFamilies protected }

procedure TJVCSGetFileFamilies.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FIncludeDescription]);
    end;
end;

{ TJVCSGetFileFamilies public }

constructor TJVCSGetFileFamilies.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetFileFamilies.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetFileFamilies.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetFileFamilies) then
    begin
      FIncludeDescription := TJVCSGetFileFamilies(Reference).FIncludeDescription;
      ClearOutputItems;
      for I := 0 to TJVCSGetFileFamilies(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetFileFamiliesOutputItem));
        try
          with PGetFileFamiliesOutputItem(P)^ do
          begin
            FamilyID := TJVCSGetFileFamilies(Reference).OutputItems[I].FamilyID;
            Name := TJVCSGetFileFamilies(Reference).OutputItems[I].Name;
            Parent := TJVCSGetFileFamilies(Reference).OutputItems[I].Parent;
            Children := TJVCSGetFileFamilies(Reference).OutputItems[I].Children;
            Description := TJVCSGetFileFamilies(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetFileFamiliesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetFileFamilies.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetFileFamilies.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetFileFamiliesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetFileFamiliesOutputItem(P)^.FamilyID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetFileFamiliesOutputItem(P)^.Name := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetFileFamiliesOutputItem(P)^.Parent := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetFileFamiliesOutputItem(P)^.Children := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetFileFamiliesOutputItem(P)^.Description := ResponseBuffer.Fields[4];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetFileFamiliesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetFileFamiliesOutputItem.Create(AOwner: TComponent; APtr: PGetFileFamiliesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetFileFamiliesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetFileFamiliesOutputItem.Get_FamilyID: Integer; safecall;
begin
  Result := FPtr^.FamilyID;
end;

function TJVCSGetFileFamiliesOutputItem.Get_Name: WideString; safecall;
begin
  Result := FPtr^.Name;
end;

function TJVCSGetFileFamiliesOutputItem.Get_Parent: WideString; safecall;
begin
  Result := FPtr^.Parent;
end;

function TJVCSGetFileFamiliesOutputItem.Get_Children: WideString; safecall;
begin
  Result := FPtr^.Children;
end;

function TJVCSGetFileFamiliesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetFileFamilies.Get_IncludeDescription: WordBool; safecall;
begin
  Result := IncludeDescription;
end;

procedure TJVCSGetFileFamilies.Set_IncludeDescription(Value: WordBool); safecall;
begin
  IncludeDescription := Value;
end;

function TJVCSGetFileFamilies.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetFileFamilies.Get_OutputItems(Index: Integer): IJVCSGetFileFamiliesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetFileFamiliesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetFamilyExtensions protected }

procedure TJVCSGetFamilyExtensions.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FParentExtension]);
    end;
end;

{ TJVCSGetFamilyExtensions public }

procedure TJVCSGetFamilyExtensions.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetFamilyExtensions) then
    begin
      FParentExtension := TJVCSGetFamilyExtensions(Reference).FParentExtension;
      FFamilyExtensions := TJVCSGetFamilyExtensions(Reference).FFamilyExtensions;
      FFamilyID := TJVCSGetFamilyExtensions(Reference).FFamilyID;
    end;
end;

procedure TJVCSGetFamilyExtensions.Initialize; 
begin
  inherited Initialize;
  FFamilyExtensions := '';
  FFamilyID := -1;
end;

procedure TJVCSGetFamilyExtensions.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FFamilyExtensions := ResponseBuffer.Fields[0];
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FFamilyID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetFamilyExtensions.Get_ParentExtension: WideString; safecall;
begin
  Result := ParentExtension;
end;

procedure TJVCSGetFamilyExtensions.Set_ParentExtension(const Value: WideString); safecall;
begin
  ParentExtension := Value;
end;

function TJVCSGetFamilyExtensions.Get_FamilyExtensions: WideString; safecall;
begin
  Result := FamilyExtensions;
end;

function TJVCSGetFamilyExtensions.Get_FamilyID: Integer; safecall;
begin
  Result := FamilyID;
end;

{$ENDIF COMVERSION}

{ TJVCSGetMilestones private }

procedure TJVCSGetMilestones.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetMilestonesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetMilestones.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetMilestones.GetOutputItems(Index: Integer): TGetMilestonesOutputItem;
begin
  Result := PGetMilestonesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetMilestones public }

constructor TJVCSGetMilestones.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetMilestones.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetMilestones.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetMilestones) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetMilestones(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetMilestonesOutputItem));
        try
          with PGetMilestonesOutputItem(P)^ do
          begin
            MilestoneID := TJVCSGetMilestones(Reference).OutputItems[I].MilestoneID;
            Milestone := TJVCSGetMilestones(Reference).OutputItems[I].Milestone;
            MilestoneName := TJVCSGetMilestones(Reference).OutputItems[I].MilestoneName;
            Description := TJVCSGetMilestones(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetMilestones.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetMilestones.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetMilestonesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetMilestonesOutputItem(P)^.MilestoneID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetMilestonesOutputItem(P)^.Milestone := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetMilestonesOutputItem(P)^.MilestoneName := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetMilestonesOutputItem(P)^.Description := ResponseBuffer.Fields[3];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetMilestonesOutputItem.Create(AOwner: TComponent; APtr: PGetMilestonesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetMilestonesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetMilestonesOutputItem.Get_MilestoneID: Integer; safecall;
begin
  Result := FPtr^.MilestoneID;
end;

function TJVCSGetMilestonesOutputItem.Get_Milestone: Integer; safecall;
begin
  Result := FPtr^.Milestone;
end;

function TJVCSGetMilestonesOutputItem.Get_MilestoneName: WideString; safecall;
begin
  Result := FPtr^.MilestoneName;
end;

function TJVCSGetMilestonesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetMilestones.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetMilestones.Get_OutputItems(Index: Integer): IJVCSGetMilestonesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetMilestonesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateMilestones protected }

procedure TJVCSAddUpdateMilestones.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FMilestoneID]);
      WriteFields(False, [FMilestone]);
      WriteFields(False, [FMilestoneName]);
      WriteFields(False, [FDescription]);
    end;
end;

{ TJVCSAddUpdateMilestones public }

procedure TJVCSAddUpdateMilestones.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateMilestones) then
    begin
      FMilestoneID := TJVCSAddUpdateMilestones(Reference).FMilestoneID;
      FMilestone := TJVCSAddUpdateMilestones(Reference).FMilestone;
      FMilestoneName := TJVCSAddUpdateMilestones(Reference).FMilestoneName;
      FDescription := TJVCSAddUpdateMilestones(Reference).FDescription;
      FNewMilestone := TJVCSAddUpdateMilestones(Reference).FNewMilestone;
      FNewMilestoneID := TJVCSAddUpdateMilestones(Reference).FNewMilestoneID;
    end;
end;

procedure TJVCSAddUpdateMilestones.Initialize; 
begin
  inherited Initialize;
  FNewMilestone := False;
  FNewMilestoneID := -1;
end;

procedure TJVCSAddUpdateMilestones.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FNewMilestone := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FNewMilestoneID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateMilestones.Get_MilestoneID: Integer; safecall;
begin
  Result := MilestoneID;
end;

procedure TJVCSAddUpdateMilestones.Set_MilestoneID(Value: Integer); safecall;
begin
  MilestoneID := Value;
end;

function TJVCSAddUpdateMilestones.Get_Milestone: Integer; safecall;
begin
  Result := Milestone;
end;

procedure TJVCSAddUpdateMilestones.Set_Milestone(Value: Integer); safecall;
begin
  Milestone := Value;
end;

function TJVCSAddUpdateMilestones.Get_MilestoneName: WideString; safecall;
begin
  Result := MilestoneName;
end;

procedure TJVCSAddUpdateMilestones.Set_MilestoneName(const Value: WideString); safecall;
begin
  MilestoneName := Value;
end;

function TJVCSAddUpdateMilestones.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAddUpdateMilestones.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

function TJVCSAddUpdateMilestones.Get_NewMilestone: WordBool; safecall;
begin
  Result := NewMilestone;
end;

function TJVCSAddUpdateMilestones.Get_NewMilestoneID: Integer; safecall;
begin
  Result := NewMilestoneID;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveMilestone protected }

procedure TJVCSRemoveMilestone.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FMilestoneID]);
    end;
end;

{ TJVCSRemoveMilestone public }

procedure TJVCSRemoveMilestone.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveMilestone) then
    begin
      FMilestoneID := TJVCSRemoveMilestone(Reference).FMilestoneID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveMilestone.Get_MilestoneID: Integer; safecall;
begin
  Result := MilestoneID;
end;

procedure TJVCSRemoveMilestone.Set_MilestoneID(Value: Integer); safecall;
begin
  MilestoneID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSGetProjectMilestones private }

procedure TJVCSGetProjectMilestones.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetProjectMilestonesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetProjectMilestones.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetProjectMilestones.GetOutputItems(Index: Integer): TGetProjectMilestonesOutputItem;
begin
  Result := PGetProjectMilestonesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetProjectMilestones protected }

procedure TJVCSGetProjectMilestones.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
    end;
end;

{ TJVCSGetProjectMilestones public }

constructor TJVCSGetProjectMilestones.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetProjectMilestones.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetProjectMilestones.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetProjectMilestones) then
    begin
      FProjectID := TJVCSGetProjectMilestones(Reference).FProjectID;
      ClearOutputItems;
      for I := 0 to TJVCSGetProjectMilestones(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetProjectMilestonesOutputItem));
        try
          with PGetProjectMilestonesOutputItem(P)^ do
          begin
            ProjectID := TJVCSGetProjectMilestones(Reference).OutputItems[I].ProjectID;
            MilestoneID := TJVCSGetProjectMilestones(Reference).OutputItems[I].MilestoneID;
            ConfirmedBy := TJVCSGetProjectMilestones(Reference).OutputItems[I].ConfirmedBy;
            ReachedTime := TJVCSGetProjectMilestones(Reference).OutputItems[I].ReachedTime;
            Description := TJVCSGetProjectMilestones(Reference).OutputItems[I].Description;
            Milestone := TJVCSGetProjectMilestones(Reference).OutputItems[I].Milestone;
            MilestoneName := TJVCSGetProjectMilestones(Reference).OutputItems[I].MilestoneName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetProjectMilestones.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetProjectMilestones.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetProjectMilestonesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.MilestoneID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.ConfirmedBy := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.ReachedTime := SafeStrToFloat(ResponseBuffer.Fields[3]);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.Description := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.Milestone := StrToInt64Def(ResponseBuffer.Fields[5], -1);
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetProjectMilestonesOutputItem(P)^.MilestoneName := ResponseBuffer.Fields[6];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetProjectMilestonesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetProjectMilestonesOutputItem.Create(AOwner: TComponent; APtr: PGetProjectMilestonesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetProjectMilestonesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_MilestoneID: Integer; safecall;
begin
  Result := FPtr^.MilestoneID;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_ConfirmedBy: WideString; safecall;
begin
  Result := FPtr^.ConfirmedBy;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_ReachedTime: TDateTime; safecall;
begin
  Result := FPtr^.ReachedTime;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_Milestone: Integer; safecall;
begin
  Result := FPtr^.Milestone;
end;

function TJVCSGetProjectMilestonesOutputItem.Get_MilestoneName: WideString; safecall;
begin
  Result := FPtr^.MilestoneName;
end;

function TJVCSGetProjectMilestones.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetProjectMilestones.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetProjectMilestones.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetProjectMilestones.Get_OutputItems(Index: Integer): IJVCSGetProjectMilestonesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetProjectMilestonesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAssignProjectMilestone protected }

procedure TJVCSAssignProjectMilestone.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FMilestoneID]);
      WriteFields(False, [FConfirm]);
      WriteFields(False, [FDescription]);
    end;
end;

{ TJVCSAssignProjectMilestone public }

procedure TJVCSAssignProjectMilestone.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAssignProjectMilestone) then
    begin
      FProjectID := TJVCSAssignProjectMilestone(Reference).FProjectID;
      FMilestoneID := TJVCSAssignProjectMilestone(Reference).FMilestoneID;
      FConfirm := TJVCSAssignProjectMilestone(Reference).FConfirm;
      FDescription := TJVCSAssignProjectMilestone(Reference).FDescription;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSAssignProjectMilestone.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSAssignProjectMilestone.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSAssignProjectMilestone.Get_MilestoneID: Integer; safecall;
begin
  Result := MilestoneID;
end;

procedure TJVCSAssignProjectMilestone.Set_MilestoneID(Value: Integer); safecall;
begin
  MilestoneID := Value;
end;

function TJVCSAssignProjectMilestone.Get_Confirm: WideString; safecall;
begin
  Result := Confirm;
end;

procedure TJVCSAssignProjectMilestone.Set_Confirm(const Value: WideString); safecall;
begin
  Confirm := Value;
end;

function TJVCSAssignProjectMilestone.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAssignProjectMilestone.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveProjectMilestone protected }

procedure TJVCSRemoveProjectMilestone.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FMilestoneID]);
    end;
end;

{ TJVCSRemoveProjectMilestone public }

procedure TJVCSRemoveProjectMilestone.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveProjectMilestone) then
    begin
      FProjectID := TJVCSRemoveProjectMilestone(Reference).FProjectID;
      FMilestoneID := TJVCSRemoveProjectMilestone(Reference).FMilestoneID;
    end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveProjectMilestone.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveProjectMilestone.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveProjectMilestone.Get_MilestoneID: Integer; safecall;
begin
  Result := MilestoneID;
end;

procedure TJVCSRemoveProjectMilestone.Set_MilestoneID(Value: Integer); safecall;
begin
  MilestoneID := Value;
end;

{$ENDIF COMVERSION}

{ TJVCSFamilyUsedBy private }

procedure TJVCSFamilyUsedBy.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSFamilyUsedBy.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSFamilyUsedBy.GetOutputItems(Index: Integer): TFamilyUsedByOutputItem;
begin
  Result := PFamilyUsedByOutputItem(FOutputItems[Index])^;
end;

{ TJVCSFamilyUsedBy protected }

procedure TJVCSFamilyUsedBy.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FFamilyID]);
    end;
end;

{ TJVCSFamilyUsedBy public }

constructor TJVCSFamilyUsedBy.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSFamilyUsedBy.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSFamilyUsedBy.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSFamilyUsedBy) then
    begin
      FFamilyID := TJVCSFamilyUsedBy(Reference).FFamilyID;
      ClearOutputItems;
      for I := 0 to TJVCSFamilyUsedBy(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TFamilyUsedByOutputItem));
        try
          with PFamilyUsedByOutputItem(P)^ do
          begin
            ModuleID := TJVCSFamilyUsedBy(Reference).OutputItems[I].ModuleID;
            ModuleName := TJVCSFamilyUsedBy(Reference).OutputItems[I].ModuleName;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSFamilyUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSFamilyUsedBy.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSFamilyUsedBy.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TFamilyUsedByOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PFamilyUsedByOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PFamilyUsedByOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSFamilyUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSFamilyUsedByOutputItem.Create(AOwner: TComponent; APtr: PFamilyUsedByOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSFamilyUsedByOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSFamilyUsedByOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSFamilyUsedByOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSFamilyUsedBy.Get_FamilyID: Integer; safecall;
begin
  Result := FamilyID;
end;

procedure TJVCSFamilyUsedBy.Set_FamilyID(Value: Integer); safecall;
begin
  FamilyID := Value;
end;

function TJVCSFamilyUsedBy.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSFamilyUsedBy.Get_OutputItems(Index: Integer): IJVCSFamilyUsedByOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSFamilyUsedByOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateLabel protected }

procedure TJVCSAddUpdateLabel.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FLabelID]);
      WriteFields(False, [FLabelName]);
      WriteFields(False, [FDescription]);
    end;
end;

{ TJVCSAddUpdateLabel public }

procedure TJVCSAddUpdateLabel.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateLabel) then
    begin
      FLabelID := TJVCSAddUpdateLabel(Reference).FLabelID;
      FLabelName := TJVCSAddUpdateLabel(Reference).FLabelName;
      FDescription := TJVCSAddUpdateLabel(Reference).FDescription;
      FNewLabel := TJVCSAddUpdateLabel(Reference).FNewLabel;
      FNewLabelID := TJVCSAddUpdateLabel(Reference).FNewLabelID;
    end;
end;

procedure TJVCSAddUpdateLabel.Initialize; 
begin
  inherited Initialize;
  FNewLabel := False;
  FNewLabelID := -1;
end;

procedure TJVCSAddUpdateLabel.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FNewLabel := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FNewLabelID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateLabel.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSAddUpdateLabel.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSAddUpdateLabel.Get_LabelName: WideString; safecall;
begin
  Result := LabelName;
end;

procedure TJVCSAddUpdateLabel.Set_LabelName(const Value: WideString); safecall;
begin
  LabelName := Value;
end;

function TJVCSAddUpdateLabel.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

procedure TJVCSAddUpdateLabel.Set_Description(const Value: WideString); safecall;
begin
  Description := Value;
end;

function TJVCSAddUpdateLabel.Get_NewLabel: WordBool; safecall;
begin
  Result := NewLabel;
end;

function TJVCSAddUpdateLabel.Get_NewLabelID: Integer; safecall;
begin
  Result := NewLabelID;
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateFileFamilies protected }

procedure TJVCSAddUpdateFileFamilies.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FFamilyID]);
      WriteFields(False, [FFamilyName]);
      WriteFields(False, [FParentExtension]);
      WriteFields(False, [FChildExtensions]);
      WriteFields(False, [FFamilyDescription]);
    end;
end;

{ TJVCSAddUpdateFileFamilies public }

procedure TJVCSAddUpdateFileFamilies.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateFileFamilies) then
    begin
      FFamilyID := TJVCSAddUpdateFileFamilies(Reference).FFamilyID;
      FFamilyName := TJVCSAddUpdateFileFamilies(Reference).FFamilyName;
      FParentExtension := TJVCSAddUpdateFileFamilies(Reference).FParentExtension;
      FChildExtensions := TJVCSAddUpdateFileFamilies(Reference).FChildExtensions;
      FFamilyDescription := TJVCSAddUpdateFileFamilies(Reference).FFamilyDescription;
      FNewFamily := TJVCSAddUpdateFileFamilies(Reference).FNewFamily;
      FNewFamilyID := TJVCSAddUpdateFileFamilies(Reference).FNewFamilyID;
    end;
end;

procedure TJVCSAddUpdateFileFamilies.Initialize; 
begin
  inherited Initialize;
  FNewFamily := False;
  FNewFamilyID := -1;
end;

procedure TJVCSAddUpdateFileFamilies.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FNewFamily := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FNewFamilyID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddUpdateFileFamilies.Get_FamilyID: Integer; safecall;
begin
  Result := FamilyID;
end;

procedure TJVCSAddUpdateFileFamilies.Set_FamilyID(Value: Integer); safecall;
begin
  FamilyID := Value;
end;

function TJVCSAddUpdateFileFamilies.Get_FamilyName: WideString; safecall;
begin
  Result := FamilyName;
end;

procedure TJVCSAddUpdateFileFamilies.Set_FamilyName(const Value: WideString); safecall;
begin
  FamilyName := Value;
end;

function TJVCSAddUpdateFileFamilies.Get_ParentExtension: WideString; safecall;
begin
  Result := ParentExtension;
end;

procedure TJVCSAddUpdateFileFamilies.Set_ParentExtension(const Value: WideString); safecall;
begin
  ParentExtension := Value;
end;

function TJVCSAddUpdateFileFamilies.Get_ChildExtensions: WideString; safecall;
begin
  Result := ChildExtensions;
end;

procedure TJVCSAddUpdateFileFamilies.Set_ChildExtensions(const Value: WideString); safecall;
begin
  ChildExtensions := Value;
end;

function TJVCSAddUpdateFileFamilies.Get_FamilyDescription: WideString; safecall;
begin
  Result := FamilyDescription;
end;

procedure TJVCSAddUpdateFileFamilies.Set_FamilyDescription(const Value: WideString); safecall;
begin
  FamilyDescription := Value;
end;

function TJVCSAddUpdateFileFamilies.Get_NewFamily: WordBool; safecall;
begin
  Result := NewFamily;
end;

function TJVCSAddUpdateFileFamilies.Get_NewFamilyID: Integer; safecall;
begin
  Result := NewFamilyID;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveFileFamilies protected }

procedure TJVCSRemoveFileFamilies.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FFamilyID]);
    end;
end;

{ TJVCSRemoveFileFamilies public }

procedure TJVCSRemoveFileFamilies.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveFileFamilies) then
    begin
      FFamilyID := TJVCSRemoveFileFamilies(Reference).FFamilyID;
      FFamilyDeleted := TJVCSRemoveFileFamilies(Reference).FFamilyDeleted;
    end;
end;

procedure TJVCSRemoveFileFamilies.Initialize; 
begin
  inherited Initialize;
  FFamilyDeleted := False;
end;

procedure TJVCSRemoveFileFamilies.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FFamilyDeleted := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveFileFamilies.Get_FamilyID: Integer; safecall;
begin
  Result := FamilyID;
end;

procedure TJVCSRemoveFileFamilies.Set_FamilyID(Value: Integer); safecall;
begin
  FamilyID := Value;
end;

function TJVCSRemoveFileFamilies.Get_FamilyDeleted: WordBool; safecall;
begin
  Result := FamilyDeleted;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveLabel protected }

procedure TJVCSRemoveLabel.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FLabelID]);
    end;
end;

{ TJVCSRemoveLabel public }

procedure TJVCSRemoveLabel.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveLabel) then
    begin
      FLabelID := TJVCSRemoveLabel(Reference).FLabelID;
      FLabelRemoved := TJVCSRemoveLabel(Reference).FLabelRemoved;
    end;
end;

procedure TJVCSRemoveLabel.Initialize; 
begin
  inherited Initialize;
  FLabelRemoved := False;
end;

procedure TJVCSRemoveLabel.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FLabelRemoved := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveLabel.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSRemoveLabel.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSRemoveLabel.Get_LabelRemoved: WordBool; safecall;
begin
  Result := LabelRemoved;
end;

{$ENDIF COMVERSION}

{ TJVCSAddRemoveRevisionLabel protected }

procedure TJVCSAddRemoveRevisionLabel.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FModuleID]);
      WriteFields(False, [FRevisionID]);
      WriteFields(False, [FLabelID]);
      WriteFields(False, [FAddLabel]);
      WriteFields(False, [FCheckOnly]);
    end;
end;

{ TJVCSAddRemoveRevisionLabel public }

procedure TJVCSAddRemoveRevisionLabel.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddRemoveRevisionLabel) then
    begin
      FModuleID := TJVCSAddRemoveRevisionLabel(Reference).FModuleID;
      FRevisionID := TJVCSAddRemoveRevisionLabel(Reference).FRevisionID;
      FLabelID := TJVCSAddRemoveRevisionLabel(Reference).FLabelID;
      FAddLabel := TJVCSAddRemoveRevisionLabel(Reference).FAddLabel;
      FCheckOnly := TJVCSAddRemoveRevisionLabel(Reference).FCheckOnly;
      FLabelAdded := TJVCSAddRemoveRevisionLabel(Reference).FLabelAdded;
      FAddedRevisionID := TJVCSAddRemoveRevisionLabel(Reference).FAddedRevisionID;
      FVersion := TJVCSAddRemoveRevisionLabel(Reference).FVersion;
      FRevision := TJVCSAddRemoveRevisionLabel(Reference).FRevision;
    end;
end;

procedure TJVCSAddRemoveRevisionLabel.Initialize; 
begin
  inherited Initialize;
  FLabelAdded := False;
  FAddedRevisionID := -1;
  FVersion := -1;
  FRevision := -1;
end;

procedure TJVCSAddRemoveRevisionLabel.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FLabelAdded := (StrToInt64Def(ResponseBuffer.Fields[0], 0) <> 0);
      if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
        FAddedRevisionID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
      if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
        FVersion := StrToInt64Def(ResponseBuffer.Fields[2], -1);
      if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
        FRevision := StrToInt64Def(ResponseBuffer.Fields[3], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSAddRemoveRevisionLabel.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSAddRemoveRevisionLabel.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSAddRemoveRevisionLabel.Get_RevisionID: Integer; safecall;
begin
  Result := RevisionID;
end;

procedure TJVCSAddRemoveRevisionLabel.Set_RevisionID(Value: Integer); safecall;
begin
  RevisionID := Value;
end;

function TJVCSAddRemoveRevisionLabel.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSAddRemoveRevisionLabel.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSAddRemoveRevisionLabel.Get_AddLabel: WordBool; safecall;
begin
  Result := AddLabel;
end;

procedure TJVCSAddRemoveRevisionLabel.Set_AddLabel(Value: WordBool); safecall;
begin
  AddLabel := Value;
end;

function TJVCSAddRemoveRevisionLabel.Get_CheckOnly: WordBool; safecall;
begin
  Result := CheckOnly;
end;

procedure TJVCSAddRemoveRevisionLabel.Set_CheckOnly(Value: WordBool); safecall;
begin
  CheckOnly := Value;
end;

function TJVCSAddRemoveRevisionLabel.Get_LabelAdded: WordBool; safecall;
begin
  Result := LabelAdded;
end;

function TJVCSAddRemoveRevisionLabel.Get_AddedRevisionID: Integer; safecall;
begin
  Result := AddedRevisionID;
end;

function TJVCSAddRemoveRevisionLabel.Get_Version: Integer; safecall;
begin
  Result := Version;
end;

function TJVCSAddRemoveRevisionLabel.Get_Revision: Integer; safecall;
begin
  Result := Revision;
end;

{$ENDIF COMVERSION}

{ TJVCSLabelUsedBy private }

procedure TJVCSLabelUsedBy.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSLabelUsedBy.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSLabelUsedBy.GetOutputItems(Index: Integer): TLabelUsedByOutputItem;
begin
  Result := PLabelUsedByOutputItem(FOutputItems[Index])^;
end;

{ TJVCSLabelUsedBy protected }

procedure TJVCSLabelUsedBy.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FLabelID]);
    end;
end;

{ TJVCSLabelUsedBy public }

constructor TJVCSLabelUsedBy.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSLabelUsedBy.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSLabelUsedBy.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSLabelUsedBy) then
    begin
      FLabelID := TJVCSLabelUsedBy(Reference).FLabelID;
      ClearOutputItems;
      for I := 0 to TJVCSLabelUsedBy(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TLabelUsedByOutputItem));
        try
          with PLabelUsedByOutputItem(P)^ do
          begin
            ModuleName := TJVCSLabelUsedBy(Reference).OutputItems[I].ModuleName;
            ModuleVersion := TJVCSLabelUsedBy(Reference).OutputItems[I].ModuleVersion;
            ModuleRevision := TJVCSLabelUsedBy(Reference).OutputItems[I].ModuleRevision;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSLabelUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSLabelUsedBy.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSLabelUsedBy.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TLabelUsedByOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PLabelUsedByOutputItem(P)^.ModuleName := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PLabelUsedByOutputItem(P)^.ModuleVersion := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PLabelUsedByOutputItem(P)^.ModuleRevision := StrToInt64Def(ResponseBuffer.Fields[2], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSLabelUsedByOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSLabelUsedByOutputItem.Create(AOwner: TComponent; APtr: PLabelUsedByOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSLabelUsedByOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSLabelUsedByOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSLabelUsedByOutputItem.Get_ModuleVersion: Integer; safecall;
begin
  Result := FPtr^.ModuleVersion;
end;

function TJVCSLabelUsedByOutputItem.Get_ModuleRevision: Integer; safecall;
begin
  Result := FPtr^.ModuleRevision;
end;

function TJVCSLabelUsedBy.Get_LabelID: Integer; safecall;
begin
  Result := LabelID;
end;

procedure TJVCSLabelUsedBy.Set_LabelID(Value: Integer); safecall;
begin
  LabelID := Value;
end;

function TJVCSLabelUsedBy.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSLabelUsedBy.Get_OutputItems(Index: Integer): IJVCSLabelUsedByOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSLabelUsedByOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetUpdateDescription protected }

procedure TJVCSGetUpdateDescription.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FItemType]);
      WriteFields(False, [FItemID]);
      WriteFields(False, [FUpdate]);
      WriteFields(False, [FUpdateDescription]);
    end;
end;

{ TJVCSGetUpdateDescription public }

procedure TJVCSGetUpdateDescription.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetUpdateDescription) then
    begin
      FItemType := TJVCSGetUpdateDescription(Reference).FItemType;
      FItemID := TJVCSGetUpdateDescription(Reference).FItemID;
      FUpdate := TJVCSGetUpdateDescription(Reference).FUpdate;
      FUpdateDescription := TJVCSGetUpdateDescription(Reference).FUpdateDescription;
      FDescription := TJVCSGetUpdateDescription(Reference).FDescription;
    end;
end;

procedure TJVCSGetUpdateDescription.Initialize; 
begin
  inherited Initialize;
  FDescription := '';
end;

procedure TJVCSGetUpdateDescription.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FDescription := ResponseBuffer.Fields[0];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetUpdateDescription.Get_ItemType: Integer; safecall;
begin
  Result := ItemType;
end;

procedure TJVCSGetUpdateDescription.Set_ItemType(Value: Integer); safecall;
begin
  ItemType := Value;
end;

function TJVCSGetUpdateDescription.Get_ItemID: Integer; safecall;
begin
  Result := ItemID;
end;

procedure TJVCSGetUpdateDescription.Set_ItemID(Value: Integer); safecall;
begin
  ItemID := Value;
end;

function TJVCSGetUpdateDescription.Get_Update: WordBool; safecall;
begin
  Result := Update;
end;

procedure TJVCSGetUpdateDescription.Set_Update(Value: WordBool); safecall;
begin
  Update := Value;
end;

function TJVCSGetUpdateDescription.Get_UpdateDescription: WideString; safecall;
begin
  Result := UpdateDescription;
end;

procedure TJVCSGetUpdateDescription.Set_UpdateDescription(const Value: WideString); safecall;
begin
  UpdateDescription := Value;
end;

function TJVCSGetUpdateDescription.Get_Description: WideString; safecall;
begin
  Result := Description;
end;

{$ENDIF COMVERSION}

{ TJVCSGetTodoFilter private }

procedure TJVCSGetTodoFilter.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetTodoFilter.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetTodoFilter.GetOutputItems(Index: Integer): TGetTodoFilterOutputItem;
begin
  Result := PGetTodoFilterOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetTodoFilter public }

constructor TJVCSGetTodoFilter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetTodoFilter.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetTodoFilter.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetTodoFilter) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetTodoFilter(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetTodoFilterOutputItem));
        try
          with PGetTodoFilterOutputItem(P)^ do
          begin
            FilterType := TJVCSGetTodoFilter(Reference).OutputItems[I].FilterType;
            ID := TJVCSGetTodoFilter(Reference).OutputItems[I].ID;
            Name := TJVCSGetTodoFilter(Reference).OutputItems[I].Name;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetTodoFilterOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetTodoFilter.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetTodoFilter.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetTodoFilterOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetTodoFilterOutputItem(P)^.FilterType := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetTodoFilterOutputItem(P)^.ID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetTodoFilterOutputItem(P)^.Name := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetTodoFilterOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetTodoFilterOutputItem.Create(AOwner: TComponent; APtr: PGetTodoFilterOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetTodoFilterOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetTodoFilterOutputItem.Get_FilterType: WideString; safecall;
begin
  Result := FPtr^.FilterType;
end;

function TJVCSGetTodoFilterOutputItem.Get_ID: Integer; safecall;
begin
  Result := FPtr^.ID;
end;

function TJVCSGetTodoFilterOutputItem.Get_Name: WideString; safecall;
begin
  Result := FPtr^.Name;
end;

function TJVCSGetTodoFilter.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetTodoFilter.Get_OutputItems(Index: Integer): IJVCSGetTodoFilterOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetTodoFilterOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSAddUpdateTodoEntries private }

procedure TJVCSAddUpdateTodoEntries.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
  begin
    Finalize(PAddUpdateTodoEntriesInputItem(FInputItems[I])^);
    FreeMem(FInputItems[I]);
  end;
  FInputItems.Clear;
end;

function TJVCSAddUpdateTodoEntries.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSAddUpdateTodoEntries.GetInputItems(Index: Integer): TAddUpdateTodoEntriesInputItem;
begin
  Result := PAddUpdateTodoEntriesInputItem(FInputItems[Index])^;
end;

{ TJVCSAddUpdateTodoEntries protected }

procedure TJVCSAddUpdateTodoEntries.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [TodoID]);
          WriteFields(False, [UserID]);
          WriteFields(False, [ProjectID]);
          WriteFields(False, [Responsible]);
          WriteFields(False, [Priority]);
          WriteFields(False, [State]);
          WriteFields(False, [Category]);
          WriteFields(False, [Description]);
          WriteFields(False, [TargetDate]);
          WriteFields(False, [DoneDate]);
        end;
    end;
end;

{ TJVCSAddUpdateTodoEntries public }

constructor TJVCSAddUpdateTodoEntries.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSAddUpdateTodoEntries.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSAddUpdateTodoEntries.AddInputItem(ATodoID: Integer; AUserID: Integer; AProjectID: Integer; AResponsible: Integer; APriority: Integer; const AState: string; const ACategory: string; const ADescription: string; ATargetDate: TDateTime; ADoneDate: TDateTime): Integer;
var
  P: PAddUpdateTodoEntriesInputItem;
begin
  P := AllocMem(SizeOf(TAddUpdateTodoEntriesInputItem));
  try
    P^.TodoID := ATodoID;
    P^.UserID := AUserID;
    P^.ProjectID := AProjectID;
    P^.Responsible := AResponsible;
    P^.Priority := APriority;
    P^.State := AState;
    P^.Category := ACategory;
    P^.Description := ADescription;
    P^.TargetDate := ATargetDate;
    P^.DoneDate := ADoneDate;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSAddUpdateTodoEntriesInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSAddUpdateTodoEntries.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddUpdateTodoEntries) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSAddUpdateTodoEntries(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TAddUpdateTodoEntriesInputItem));
        try
          with PAddUpdateTodoEntriesInputItem(P)^ do
          begin
            TodoID := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].TodoID;
            UserID := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].UserID;
            ProjectID := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].ProjectID;
            Responsible := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].Responsible;
            Priority := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].Priority;
            State := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].State;
            Category := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].Category;
            Description := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].Description;
            TargetDate := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].TargetDate;
            DoneDate := TJVCSAddUpdateTodoEntries(Reference).InputItems[I].DoneDate;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSAddUpdateTodoEntriesInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

{$IFDEF COMVERSION}
constructor TJVCSAddUpdateTodoEntriesInputItem.Create(AOwner: TComponent; APtr: PAddUpdateTodoEntriesInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSAddUpdateTodoEntriesInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_TodoID: Integer; safecall;
begin
  Result := FPtr^.TodoID;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_Responsible: Integer; safecall;
begin
  Result := FPtr^.Responsible;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_Priority: Integer; safecall;
begin
  Result := FPtr^.Priority;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_State: WideString; safecall;
begin
  Result := FPtr^.State;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_Category: WideString; safecall;
begin
  Result := FPtr^.Category;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_TargetDate: TDateTime; safecall;
begin
  Result := FPtr^.TargetDate;
end;

function TJVCSAddUpdateTodoEntriesInputItem.Get_DoneDate: TDateTime; safecall;
begin
  Result := FPtr^.DoneDate;
end;

function TJVCSAddUpdateTodoEntries.COMAddInputItem(ATodoID: Integer; AUserID: Integer; AProjectID: Integer; AResponsible: Integer; APriority: Integer; const AState: WideString; const ACategory: WideString; const ADescription: WideString; ATargetDate: TDateTime; ADoneDate: TDateTime): Integer; safecall;
begin
  Result := AddInputItem(ATodoID, AUserID, AProjectID, AResponsible, APriority, AState, ACategory, ADescription, ATargetDate, ADoneDate);
end;

function TJVCSAddUpdateTodoEntries.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSAddUpdateTodoEntries.Get_InputItems(Index: Integer): IJVCSAddUpdateTodoEntriesInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSAddUpdateTodoEntriesInputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveTodoEntries private }

procedure TJVCSRemoveTodoEntries.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
    FreeMem(FInputItems[I]);
  FInputItems.Clear;
end;

function TJVCSRemoveTodoEntries.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSRemoveTodoEntries.GetInputItems(Index: Integer): TRemoveTodoEntriesInputItem;
begin
  Result := PRemoveTodoEntriesInputItem(FInputItems[Index])^;
end;

{ TJVCSRemoveTodoEntries protected }

procedure TJVCSRemoveTodoEntries.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [TodoID]);
        end;
    end;
end;

{ TJVCSRemoveTodoEntries public }

constructor TJVCSRemoveTodoEntries.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSRemoveTodoEntries.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSRemoveTodoEntries.AddInputItem(ATodoID: Integer): Integer;
var
  P: PRemoveTodoEntriesInputItem;
begin
  P := AllocMem(SizeOf(TRemoveTodoEntriesInputItem));
  try
    P^.TodoID := ATodoID;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSRemoveTodoEntriesInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSRemoveTodoEntries.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveTodoEntries) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSRemoveTodoEntries(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TRemoveTodoEntriesInputItem));
        try
          with PRemoveTodoEntriesInputItem(P)^ do
          begin
            TodoID := TJVCSRemoveTodoEntries(Reference).InputItems[I].TodoID;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSRemoveTodoEntriesInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

{$IFDEF COMVERSION}
constructor TJVCSRemoveTodoEntriesInputItem.Create(AOwner: TComponent; APtr: PRemoveTodoEntriesInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSRemoveTodoEntriesInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSRemoveTodoEntriesInputItem.Get_TodoID: Integer; safecall;
begin
  Result := FPtr^.TodoID;
end;

function TJVCSRemoveTodoEntries.COMAddInputItem(ATodoID: Integer): Integer; safecall;
begin
  Result := AddInputItem(ATodoID);
end;

function TJVCSRemoveTodoEntries.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSRemoveTodoEntries.Get_InputItems(Index: Integer): IJVCSRemoveTodoEntriesInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSRemoveTodoEntriesInputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetTodoEntries private }

procedure TJVCSGetTodoEntries.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetTodoEntriesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetTodoEntries.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetTodoEntries.GetOutputItems(Index: Integer): TGetTodoEntriesOutputItem;
begin
  Result := PGetTodoEntriesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetTodoEntries protected }

procedure TJVCSGetTodoEntries.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FUserID]);
      WriteFields(False, [FProjectID]);
      WriteFields(False, [FCategory]);
      WriteFields(False, [FPriority]);
      WriteFields(False, [FNotDoneOnly]);
      WriteFields(False, [FTargetDate]);
    end;
end;

{ TJVCSGetTodoEntries public }

constructor TJVCSGetTodoEntries.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetTodoEntries.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetTodoEntries.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetTodoEntries) then
    begin
      FUserID := TJVCSGetTodoEntries(Reference).FUserID;
      FProjectID := TJVCSGetTodoEntries(Reference).FProjectID;
      FCategory := TJVCSGetTodoEntries(Reference).FCategory;
      FPriority := TJVCSGetTodoEntries(Reference).FPriority;
      FNotDoneOnly := TJVCSGetTodoEntries(Reference).FNotDoneOnly;
      FTargetDate := TJVCSGetTodoEntries(Reference).FTargetDate;
      ClearOutputItems;
      for I := 0 to TJVCSGetTodoEntries(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetTodoEntriesOutputItem));
        try
          with PGetTodoEntriesOutputItem(P)^ do
          begin
            TodoID := TJVCSGetTodoEntries(Reference).OutputItems[I].TodoID;
            Timestamp := TJVCSGetTodoEntries(Reference).OutputItems[I].Timestamp;
            UserName := TJVCSGetTodoEntries(Reference).OutputItems[I].UserName;
            ProjectName := TJVCSGetTodoEntries(Reference).OutputItems[I].ProjectName;
            Priority := TJVCSGetTodoEntries(Reference).OutputItems[I].Priority;
            State := TJVCSGetTodoEntries(Reference).OutputItems[I].State;
            Category := TJVCSGetTodoEntries(Reference).OutputItems[I].Category;
            TargetDate := TJVCSGetTodoEntries(Reference).OutputItems[I].TargetDate;
            DoneDate := TJVCSGetTodoEntries(Reference).OutputItems[I].DoneDate;
            Description := TJVCSGetTodoEntries(Reference).OutputItems[I].Description;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetTodoEntriesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetTodoEntries.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetTodoEntries.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetTodoEntriesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetTodoEntriesOutputItem(P)^.TodoID := StrToInt64Def(ResponseBuffer.Fields[0], -1);
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetTodoEntriesOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[1]);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetTodoEntriesOutputItem(P)^.UserName := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetTodoEntriesOutputItem(P)^.ProjectName := ResponseBuffer.Fields[3];
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetTodoEntriesOutputItem(P)^.Priority := StrToInt64Def(ResponseBuffer.Fields[4], -1);
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetTodoEntriesOutputItem(P)^.State := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetTodoEntriesOutputItem(P)^.Category := ResponseBuffer.Fields[6];
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetTodoEntriesOutputItem(P)^.TargetDate := SafeStrToFloat(ResponseBuffer.Fields[7]);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetTodoEntriesOutputItem(P)^.DoneDate := SafeStrToFloat(ResponseBuffer.Fields[8]);
          if (ResponseBuffer.FieldCount > 9) and (ResponseBuffer.FieldType[9] = mwString) then
            PGetTodoEntriesOutputItem(P)^.Description := ResponseBuffer.Fields[9];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetTodoEntriesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetTodoEntriesOutputItem.Create(AOwner: TComponent; APtr: PGetTodoEntriesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetTodoEntriesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetTodoEntriesOutputItem.Get_TodoID: Integer; safecall;
begin
  Result := FPtr^.TodoID;
end;

function TJVCSGetTodoEntriesOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetTodoEntriesOutputItem.Get_UserName: WideString; safecall;
begin
  Result := FPtr^.UserName;
end;

function TJVCSGetTodoEntriesOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetTodoEntriesOutputItem.Get_Priority: Integer; safecall;
begin
  Result := FPtr^.Priority;
end;

function TJVCSGetTodoEntriesOutputItem.Get_State: WideString; safecall;
begin
  Result := FPtr^.State;
end;

function TJVCSGetTodoEntriesOutputItem.Get_Category: WideString; safecall;
begin
  Result := FPtr^.Category;
end;

function TJVCSGetTodoEntriesOutputItem.Get_TargetDate: TDateTime; safecall;
begin
  Result := FPtr^.TargetDate;
end;

function TJVCSGetTodoEntriesOutputItem.Get_DoneDate: TDateTime; safecall;
begin
  Result := FPtr^.DoneDate;
end;

function TJVCSGetTodoEntriesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetTodoEntries.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSGetTodoEntries.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSGetTodoEntries.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetTodoEntries.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetTodoEntries.Get_Category: WideString; safecall;
begin
  Result := Category;
end;

procedure TJVCSGetTodoEntries.Set_Category(const Value: WideString); safecall;
begin
  Category := Value;
end;

function TJVCSGetTodoEntries.Get_Priority: Integer; safecall;
begin
  Result := Priority;
end;

procedure TJVCSGetTodoEntries.Set_Priority(Value: Integer); safecall;
begin
  Priority := Value;
end;

function TJVCSGetTodoEntries.Get_NotDoneOnly: WordBool; safecall;
begin
  Result := NotDoneOnly;
end;

procedure TJVCSGetTodoEntries.Set_NotDoneOnly(Value: WordBool); safecall;
begin
  NotDoneOnly := Value;
end;

function TJVCSGetTodoEntries.Get_TargetDate: TDateTime; safecall;
begin
  Result := TargetDate;
end;

procedure TJVCSGetTodoEntries.Set_TargetDate(Value: TDateTime); safecall;
begin
  TargetDate := Value;
end;

function TJVCSGetTodoEntries.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetTodoEntries.Get_OutputItems(Index: Integer): IJVCSGetTodoEntriesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetTodoEntriesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLogFilter private }

procedure TJVCSGetLogFilter.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
    FreeMem(FOutputItems[I]);
  FOutputItems.Clear;
end;

function TJVCSGetLogFilter.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLogFilter.GetOutputItems(Index: Integer): TGetLogFilterOutputItem;
begin
  Result := PGetLogFilterOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLogFilter public }

constructor TJVCSGetLogFilter.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLogFilter.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLogFilter.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLogFilter) then
    begin
      ClearOutputItems;
      for I := 0 to TJVCSGetLogFilter(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLogFilterOutputItem));
        try
          with PGetLogFilterOutputItem(P)^ do
          begin
            FilterType := TJVCSGetLogFilter(Reference).OutputItems[I].FilterType;
            ID := TJVCSGetLogFilter(Reference).OutputItems[I].ID;
            Name := TJVCSGetLogFilter(Reference).OutputItems[I].Name;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLogFilterOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLogFilter.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLogFilter.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLogFilterOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLogFilterOutputItem(P)^.FilterType := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLogFilterOutputItem(P)^.ID := StrToInt64Def(ResponseBuffer.Fields[1], -1);
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLogFilterOutputItem(P)^.Name := ResponseBuffer.Fields[2];
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLogFilterOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLogFilterOutputItem.Create(AOwner: TComponent; APtr: PGetLogFilterOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLogFilterOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLogFilterOutputItem.Get_FilterType: WideString; safecall;
begin
  Result := FPtr^.FilterType;
end;

function TJVCSGetLogFilterOutputItem.Get_ID: Integer; safecall;
begin
  Result := FPtr^.ID;
end;

function TJVCSGetLogFilterOutputItem.Get_Name: WideString; safecall;
begin
  Result := FPtr^.Name;
end;

function TJVCSGetLogFilter.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLogFilter.Get_OutputItems(Index: Integer): IJVCSGetLogFilterOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLogFilterOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLogEntries private }

procedure TJVCSGetLogEntries.ClearOutputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FOutputItems.Count - 1 do
  begin
    Finalize(PGetLogEntriesOutputItem(FOutputItems[I])^);
    FreeMem(FOutputItems[I]);
  end;
  FOutputItems.Clear;
end;

function TJVCSGetLogEntries.GetOutputItemCount: Integer;
begin
  Result := FOutputItems.Count;
end;

function TJVCSGetLogEntries.GetOutputItems(Index: Integer): TGetLogEntriesOutputItem;
begin
  Result := PGetLogEntriesOutputItem(FOutputItems[Index])^;
end;

{ TJVCSGetLogEntries protected }

procedure TJVCSGetLogEntries.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FStartDate]);
      WriteFields(False, [FEndDate]);
      WriteFields(False, [FEntryType]);
    end;
end;

{ TJVCSGetLogEntries public }

constructor TJVCSGetLogEntries.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FOutputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSGetLogEntries.Destroy;
begin
  ClearOutputItems;
  {$IFDEF COMVERSION}
  FInterfaceOutputItems.Free;
  {$ENDIF COMVERSION}
  FOutputItems.Free;
  inherited Destroy;
end;

procedure TJVCSGetLogEntries.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLogEntries) then
    begin
      FProjectID := TJVCSGetLogEntries(Reference).FProjectID;
      FModuleID := TJVCSGetLogEntries(Reference).FModuleID;
      FUserID := TJVCSGetLogEntries(Reference).FUserID;
      FStartDate := TJVCSGetLogEntries(Reference).FStartDate;
      FEndDate := TJVCSGetLogEntries(Reference).FEndDate;
      FEntryType := TJVCSGetLogEntries(Reference).FEntryType;
      ClearOutputItems;
      for I := 0 to TJVCSGetLogEntries(Reference).OutputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TGetLogEntriesOutputItem));
        try
          with PGetLogEntriesOutputItem(P)^ do
          begin
            ProjectName := TJVCSGetLogEntries(Reference).OutputItems[I].ProjectName;
            ModuleName := TJVCSGetLogEntries(Reference).OutputItems[I].ModuleName;
            UserName := TJVCSGetLogEntries(Reference).OutputItems[I].UserName;
            Timestamp := TJVCSGetLogEntries(Reference).OutputItems[I].Timestamp;
            EntryType := TJVCSGetLogEntries(Reference).OutputItems[I].EntryType;
            Description := TJVCSGetLogEntries(Reference).OutputItems[I].Description;
            ProjectID := TJVCSGetLogEntries(Reference).OutputItems[I].ProjectID;
            ModuleID := TJVCSGetLogEntries(Reference).OutputItems[I].ModuleID;
            LogID := TJVCSGetLogEntries(Reference).OutputItems[I].LogID;
          end;
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLogEntriesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

procedure TJVCSGetLogEntries.Initialize; 
begin
  inherited Initialize;
  ClearOutputItems;
end;

procedure TJVCSGetLogEntries.SetResponseFields(ResponseBuffer: TMWBuffer);
var
  P: Pointer;
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      while not ResponseBuffer.Eof do
      begin
        P := AllocMem(SizeOf(TGetLogEntriesOutputItem));
        try
          if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
            PGetLogEntriesOutputItem(P)^.ProjectName := ResponseBuffer.Fields[0];
          if (ResponseBuffer.FieldCount > 1) and (ResponseBuffer.FieldType[1] = mwString) then
            PGetLogEntriesOutputItem(P)^.ModuleName := ResponseBuffer.Fields[1];
          if (ResponseBuffer.FieldCount > 2) and (ResponseBuffer.FieldType[2] = mwString) then
            PGetLogEntriesOutputItem(P)^.UserName := ResponseBuffer.Fields[2];
          if (ResponseBuffer.FieldCount > 3) and (ResponseBuffer.FieldType[3] = mwString) then
            PGetLogEntriesOutputItem(P)^.Timestamp := SafeStrToFloat(ResponseBuffer.Fields[3]);
          if (ResponseBuffer.FieldCount > 4) and (ResponseBuffer.FieldType[4] = mwString) then
            PGetLogEntriesOutputItem(P)^.EntryType := ResponseBuffer.Fields[4];
          if (ResponseBuffer.FieldCount > 5) and (ResponseBuffer.FieldType[5] = mwString) then
            PGetLogEntriesOutputItem(P)^.Description := ResponseBuffer.Fields[5];
          if (ResponseBuffer.FieldCount > 6) and (ResponseBuffer.FieldType[6] = mwString) then
            PGetLogEntriesOutputItem(P)^.ProjectID := StrToInt64Def(ResponseBuffer.Fields[6], -1);
          if (ResponseBuffer.FieldCount > 7) and (ResponseBuffer.FieldType[7] = mwString) then
            PGetLogEntriesOutputItem(P)^.ModuleID := StrToInt64Def(ResponseBuffer.Fields[7], -1);
          if (ResponseBuffer.FieldCount > 8) and (ResponseBuffer.FieldType[8] = mwString) then
            PGetLogEntriesOutputItem(P)^.LogID := StrToInt64Def(ResponseBuffer.Fields[8], -1);
          FOutputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceOutputItems.Add(TJVCSGetLogEntriesOutputItem.Create(Self, P));
          {$ENDIF COMVERSION}
          ResponseBuffer.Next;
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
  end;
end;

{$IFDEF COMVERSION}
constructor TJVCSGetLogEntriesOutputItem.Create(AOwner: TComponent; APtr: PGetLogEntriesOutputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSGetLogEntriesOutputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSGetLogEntriesOutputItem.Get_ProjectName: WideString; safecall;
begin
  Result := FPtr^.ProjectName;
end;

function TJVCSGetLogEntriesOutputItem.Get_ModuleName: WideString; safecall;
begin
  Result := FPtr^.ModuleName;
end;

function TJVCSGetLogEntriesOutputItem.Get_UserName: WideString; safecall;
begin
  Result := FPtr^.UserName;
end;

function TJVCSGetLogEntriesOutputItem.Get_Timestamp: TDateTime; safecall;
begin
  Result := FPtr^.Timestamp;
end;

function TJVCSGetLogEntriesOutputItem.Get_EntryType: WideString; safecall;
begin
  Result := FPtr^.EntryType;
end;

function TJVCSGetLogEntriesOutputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSGetLogEntriesOutputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSGetLogEntriesOutputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSGetLogEntriesOutputItem.Get_LogID: Integer; safecall;
begin
  Result := FPtr^.LogID;
end;

function TJVCSGetLogEntries.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSGetLogEntries.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSGetLogEntries.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSGetLogEntries.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSGetLogEntries.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSGetLogEntries.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSGetLogEntries.Get_StartDate: TDateTime; safecall;
begin
  Result := StartDate;
end;

procedure TJVCSGetLogEntries.Set_StartDate(Value: TDateTime); safecall;
begin
  StartDate := Value;
end;

function TJVCSGetLogEntries.Get_EndDate: TDateTime; safecall;
begin
  Result := EndDate;
end;

procedure TJVCSGetLogEntries.Set_EndDate(Value: TDateTime); safecall;
begin
  EndDate := Value;
end;

function TJVCSGetLogEntries.Get_EntryType: WideString; safecall;
begin
  Result := EntryType;
end;

procedure TJVCSGetLogEntries.Set_EntryType(const Value: WideString); safecall;
begin
  EntryType := Value;
end;

function TJVCSGetLogEntries.Get_OutputItemCount: Integer; safecall;
begin
  Result := FInterfaceOutputItems.Count;
end;

function TJVCSGetLogEntries.Get_OutputItems(Index: Integer): IJVCSGetLogEntriesOutputItem; safecall;
begin
  FInterfaceOutputItems[Index].GetInterface(IJVCSGetLogEntriesOutputItem, Result);
end;

{$ENDIF COMVERSION}

{ TJVCSGetLogComment protected }

procedure TJVCSGetLogComment.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FLogID]);
    end;
end;

{ TJVCSGetLogComment public }

procedure TJVCSGetLogComment.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSGetLogComment) then
    begin
      FLogID := TJVCSGetLogComment(Reference).FLogID;
      FCheckinComment := TJVCSGetLogComment(Reference).FCheckinComment;
    end;
end;

procedure TJVCSGetLogComment.Initialize; 
begin
  inherited Initialize;
  FCheckinComment := '';
end;

procedure TJVCSGetLogComment.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FCheckinComment := ResponseBuffer.Fields[0];
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSGetLogComment.Get_LogID: Integer; safecall;
begin
  Result := LogID;
end;

procedure TJVCSGetLogComment.Set_LogID(Value: Integer); safecall;
begin
  LogID := Value;
end;

function TJVCSGetLogComment.Get_CheckinComment: WideString; safecall;
begin
  Result := CheckinComment;
end;

{$ENDIF COMVERSION}

{ TJVCSRemoveLogEntries protected }

procedure TJVCSRemoveLogEntries.DoExecute;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      WriteFields(True, [FProjectID]);
      WriteFields(False, [FModuleID]);
      WriteFields(False, [FUserID]);
      WriteFields(False, [FOlderThan]);
    end;
end;

{ TJVCSRemoveLogEntries public }

procedure TJVCSRemoveLogEntries.CopyFromReference(Reference: TClientObject);
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSRemoveLogEntries) then
    begin
      FProjectID := TJVCSRemoveLogEntries(Reference).FProjectID;
      FModuleID := TJVCSRemoveLogEntries(Reference).FModuleID;
      FUserID := TJVCSRemoveLogEntries(Reference).FUserID;
      FOlderThan := TJVCSRemoveLogEntries(Reference).FOlderThan;
      FAffectedEntries := TJVCSRemoveLogEntries(Reference).FAffectedEntries;
    end;
end;

procedure TJVCSRemoveLogEntries.Initialize; 
begin
  inherited Initialize;
  FAffectedEntries := -1;
end;

procedure TJVCSRemoveLogEntries.SetResponseFields(ResponseBuffer: TMWBuffer);
begin
  inherited SetResponseFields(ResponseBuffer);
  if Assigned(ResponseBuffer) then
  begin
    if not ResponseBuffer.Eof then
    begin
      if (ResponseBuffer.FieldCount > 0) and (ResponseBuffer.FieldType[0] = mwString) then
        FAffectedEntries := StrToInt64Def(ResponseBuffer.Fields[0], -1);
    end;
  end;
end;

{$IFDEF COMVERSION}
function TJVCSRemoveLogEntries.Get_ProjectID: Integer; safecall;
begin
  Result := ProjectID;
end;

procedure TJVCSRemoveLogEntries.Set_ProjectID(Value: Integer); safecall;
begin
  ProjectID := Value;
end;

function TJVCSRemoveLogEntries.Get_ModuleID: Integer; safecall;
begin
  Result := ModuleID;
end;

procedure TJVCSRemoveLogEntries.Set_ModuleID(Value: Integer); safecall;
begin
  ModuleID := Value;
end;

function TJVCSRemoveLogEntries.Get_UserID: Integer; safecall;
begin
  Result := UserID;
end;

procedure TJVCSRemoveLogEntries.Set_UserID(Value: Integer); safecall;
begin
  UserID := Value;
end;

function TJVCSRemoveLogEntries.Get_OlderThan: TDateTime; safecall;
begin
  Result := OlderThan;
end;

procedure TJVCSRemoveLogEntries.Set_OlderThan(Value: TDateTime); safecall;
begin
  OlderThan := Value;
end;

function TJVCSRemoveLogEntries.Get_AffectedEntries: Integer; safecall;
begin
  Result := AffectedEntries;
end;

{$ENDIF COMVERSION}

{ TJVCSAddLogEntries private }

procedure TJVCSAddLogEntries.ClearInputItems;
var
  I: Integer;
begin
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Clear;
  {$ENDIF COMVERSION}
  for I := 0 to FInputItems.Count - 1 do
  begin
    Finalize(PAddLogEntriesInputItem(FInputItems[I])^);
    FreeMem(FInputItems[I]);
  end;
  FInputItems.Clear;
end;

function TJVCSAddLogEntries.GetInputItemCount: Integer;
begin
  Result := FInputItems.Count;
end;

function TJVCSAddLogEntries.GetInputItems(Index: Integer): TAddLogEntriesInputItem;
begin
  Result := PAddLogEntriesInputItem(FInputItems[Index])^;
end;

{ TJVCSAddLogEntries protected }

procedure TJVCSAddLogEntries.DoExecute;
var
  I: Integer;
begin
  inherited DoExecute;
  if Assigned(FAppSrvClient) and Assigned(FAppSrvClient.Request) then
    with FAppSrvClient.Request do
    begin
      for I := 0 to InputItemCount - 1 do
        with InputItems[I] do
        begin
          WriteFields(True, [ProjectID]);
          WriteFields(False, [ModuleID]);
          WriteFields(False, [UserID]);
          WriteFields(False, [EntryType]);
          WriteFields(False, [Description]);
        end;
    end;
end;

{ TJVCSAddLogEntries public }

constructor TJVCSAddLogEntries.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInputItems := TList.Create;
  {$IFDEF COMVERSION}
  FInterfaceInputItems := TObjectList.Create;
  {$ENDIF COMVERSION}
end;

destructor TJVCSAddLogEntries.Destroy;
begin
  ClearInputItems;
  {$IFDEF COMVERSION}
  FInterfaceInputItems.Free;
  {$ENDIF COMVERSION}
  FInputItems.Free;
  inherited Destroy;
end;

function TJVCSAddLogEntries.AddInputItem(AProjectID: Integer; AModuleID: Integer; AUserID: Integer; const AEntryType: string; const ADescription: string): Integer;
var
  P: PAddLogEntriesInputItem;
begin
  P := AllocMem(SizeOf(TAddLogEntriesInputItem));
  try
    P^.ProjectID := AProjectID;
    P^.ModuleID := AModuleID;
    P^.UserID := AUserID;
    P^.EntryType := AEntryType;
    P^.Description := ADescription;
    Result := FInputItems.Add(P);
    {$IFDEF COMVERSION}
    FInterfaceInputItems.Add(TJVCSAddLogEntriesInputItem.Create(Self, P));
    {$ENDIF COMVERSION}
  except
    FreeMem(P);
    raise;
  end;
end;

procedure TJVCSAddLogEntries.CopyFromReference(Reference: TClientObject);
var
  I: Integer;
  P: Pointer;
begin
  inherited CopyFromReference(Reference);
  if Assigned(Reference) and (Reference is TJVCSAddLogEntries) then
    begin
      ClearInputItems;
      for I := 0 to TJVCSAddLogEntries(Reference).InputItemCount - 1 do
      begin
        P := AllocMem(SizeOf(TAddLogEntriesInputItem));
        try
          with PAddLogEntriesInputItem(P)^ do
          begin
            ProjectID := TJVCSAddLogEntries(Reference).InputItems[I].ProjectID;
            ModuleID := TJVCSAddLogEntries(Reference).InputItems[I].ModuleID;
            UserID := TJVCSAddLogEntries(Reference).InputItems[I].UserID;
            EntryType := TJVCSAddLogEntries(Reference).InputItems[I].EntryType;
            Description := TJVCSAddLogEntries(Reference).InputItems[I].Description;
          end;
          FInputItems.Add(P);
          {$IFDEF COMVERSION}
          FInterfaceInputItems.Add(TJVCSAddLogEntriesInputItem.Create(Self, P));
          {$ENDIF COMVERSION}
        except
          FreeMem(P);
          raise;
        end;
      end;
    end;
end;

{$IFDEF COMVERSION}
constructor TJVCSAddLogEntriesInputItem.Create(AOwner: TComponent; APtr: PAddLogEntriesInputItem);
begin
  inherited Create(AOwner);
  FPtr := APtr;
end;

destructor TJVCSAddLogEntriesInputItem.Destroy;
begin
  inherited Destroy;
end;

function TJVCSAddLogEntriesInputItem.Get_ProjectID: Integer; safecall;
begin
  Result := FPtr^.ProjectID;
end;

function TJVCSAddLogEntriesInputItem.Get_ModuleID: Integer; safecall;
begin
  Result := FPtr^.ModuleID;
end;

function TJVCSAddLogEntriesInputItem.Get_UserID: Integer; safecall;
begin
  Result := FPtr^.UserID;
end;

function TJVCSAddLogEntriesInputItem.Get_EntryType: WideString; safecall;
begin
  Result := FPtr^.EntryType;
end;

function TJVCSAddLogEntriesInputItem.Get_Description: WideString; safecall;
begin
  Result := FPtr^.Description;
end;

function TJVCSAddLogEntries.COMAddInputItem(AProjectID: Integer; AModuleID: Integer; AUserID: Integer; const AEntryType: WideString; const ADescription: WideString): Integer; safecall;
begin
  Result := AddInputItem(AProjectID, AModuleID, AUserID, AEntryType, ADescription);
end;

function TJVCSAddLogEntries.Get_InputItemCount: Integer; safecall;
begin
  Result := FInterfaceInputItems.Count;
end;

function TJVCSAddLogEntries.Get_InputItems(Index: Integer): IJVCSAddLogEntriesInputItem; safecall;
begin
  FInterfaceInputItems[Index].GetInterface(IJVCSAddLogEntriesInputItem, Result);
end;

{$ENDIF COMVERSION}

end.
